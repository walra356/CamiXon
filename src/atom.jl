# ======================== Atom(name, symbol, Z, I, Q, M, I, gI) ===============

"""
    Atom(name::String, symbol::String, Z::Int,Zc::Int,Q::Int,M::Float64,I::Real,gI::Float64)

Type with fields:
* `  .name`:  name of element
* `.symbol`:  symbol of element
* `     .Z`:  atomic number
* `    .Zc`:  Rydberg charge in a.u.
* `     .Q`:  ionic charge in a.u.
* `     .M`:  nuclear mass in amu
* `     .I`:  nuclear spin in units of ħ
* `    .gI`:  nuclear g-factor

The type `Atom` is best created by the function `castAtom`.
"""
struct Atom              # atomic properties
    name::String         # name of element
    symbol::String       # atomic symbol
    Z::Int               # atomic number
    Zc::Int              # Rydberg charge
    Q::Int               # ionic charge (a.u.)
    M::Float64           # nuclear mass (amu)
    I::Real              # nuclear spin as integer or rational number
    gI::Float64          # nucear g-factor
end


# ======== castAtomcastAtom(Z::Int; Q=0, M=1.0, I=1//2, gI=5.5) ===========

"""
    castAtom(;Z=1, Q=0, M=1.0, I=1//2, gI=5.5, msg=true)

Create Atom with fields
* `  .name`:  name of element
* `.symbol`:  symbol of element
* `     .Z`:  atomic number
* `    .Zc`:  Rydberg charge in a.u. (autogenerated)
* `     .Q`:  ionic charge in a.u.
* `     .M`:  nuclear mass in amu
* `     .I`:  nuclear spin in units of ħ
* `    .gI`:  nuclear g-factor
#### Examples:
```
castAtom(Z=1, Q=0, M=1.00782503223, I=1//2, gI=5.585694713)
 Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.00782503223, I = 1//2, gI = 5.585694713)
 Atom("Hydrogen", "¹H", 1, 1, 0, 1.00782503223, 1//2, 5.585694713)

castAtom(Z=2, Q=1, M=4.00260325413, I=1//2, gI=0.0)
 Atom created: Helium ion - ⁴Heᐩ (Z = 2, Zc = 2, Q = 1, M = 4.00260325413, I = 1//2, gI = 0.0)
 Atom("Helium ion", "⁴Heᐩ", 2, 2, 1, 4.00260325413, 1//2, 0.0)
```
"""
function castAtom(;Z=1, Q=0, M=1.0, I=1//2, gI=5.5, msg=true)

    S = typeof(I) ∈ [Float16,Float32,Float64] ? rationalize(I) : I

    strQ = abs(Q) > 1 ? sup(abs(Q)) : ""
    strQ = Q > 0 ? (strQ * 'ᐩ') : Q < 0 ? (strQ * 'ᐨ') : ""
    strT = Q ≠ 0 ? " ion" : " atom"

    (name,symbol) = mendeleev(Z)

    name = Q ≠ 0 ? (name * " ion") : name
    symbol = sup(Int(round(M))) * symbol * strQ

    Zc = 1 + Q

    msg && println("Atom created: $(name) - $(symbol) (Z = $Z, Zc = $(Zc), Q = $Q, M = $M, I = $I, gI = $gI)")

    return Atom(name, symbol, Z, Zc, Q, M, I, gI)

end

# ======================== Orbit(name, n, n′, ℓ, up) ===========

"""
    Orbit(name, n, n′, ℓ)

Type for specification of *atomic orbitals* with fields:
* `.name`: name
* ` .n`:  principal quantum number
* `.n′`:  radial quantum number (number of nodes in radial wavefunction)
* ` .ℓ`:  orbital angular momentum valence electron

The type `Orbit` is best created by the function `castOrbit`.
"""
struct Orbit
    name::String         # LS term notation
    n::Int               # principal quantum number
    n′::Int              # radial quantum number (number of nodes)
    ℓ::Int               # orbital angular momentum valence electron
end


# ======================== castOrbital(n::Int, ℓ::Int) ===========

"""
    castOrbit(;n=1, ℓ=0, msg=true)

Specify `Orbit` with fields:
* `.name`: name
* ` .n`:  principal quantum number
* `.n′`:  radial quantum number (number of nodes in radial wavefunction)
* ` .ℓ`:  orbital angular momentum valence electron
* `.ms`:  spin magnetic quantum number
#### Examples:
```
castOrbit(n=1, ℓ=0)
 Orbit created: 1s (n = 1, n′ = 0, ℓ = 0)
 Orbit("1s", 1, 0, 0)
```
"""
function castOrbit(;n=1, ℓ=0, msg=true)

    strL = ['s','p','d','f','g','h','i','k','l','m','n','o','q','r','t','u']

    name = ℓ > 15 ? "[n=$(n), ℓ=$(ℓ)]" : string(n) * strL[ℓ + 1]

    ℓ < n || return error("Error: ℓ < n rule not satisfied")

    n′ = n - ℓ - 1

    msg && println("Orbit created: $(name) - (n = $n, n′ = $(n′), ℓ = $ℓ)")

    return Orbit(name, n, n′, ℓ)

end

# ======================== SpinOrbit(name, n, n′, ℓ, ms) ===========

"""
    SpinOrbit

Type for specification of *atomic spinorbitals* with fields:
* `.name`: name
* ` .n`:  principal quantum number
* `.n′`:  radial quantum number (number of nodes in radial wavefunction)
* ` .ℓ`:  orbital angular momentum valence electron
* `.ms`:  spin magnetic quantum number

The type `SpinOrbit` is best created by the function `createSpinOrbit`.
"""
struct SpinOrbit
    name::String         # LS term notation
    n::Int               # principal quantum number
    n′::Int              # radial quantum number (number of nodes)
    ℓ::Int               # orbital angular momentum valence electron
    ms::Rational{Int}    # spin magnetic quantum number
end


# ======================== createSpinOrbit(o::Orbital; up=true) ===========

"""
    createSpinOrbital(o::Orbit; up=true, msg=true)

Specify `SpinOrbit` with fields:
* `.name`: name
* `   .n`: principal quantum number
* `  .n′`: radial quantum number (number of nodes in radial wavefunction)
* `   .ℓ`: orbital angular momentum valence electron
* `  .ms`: spin magnetic quantum number
#### Examples:
```
s1s = castOrbit(1,0)
createSpinOrbit(s1s; up=true)
  SpinOrbit created: 1s↑ (n = 1, n′ = 0, ℓ = 0, ms = 1//2)
  SpinOrbit("1s↑", 1, 0, 0, 1//2)
```
"""
function createSpinOrbit(o::Orbit; up=true, msg=true)

    name = o.name * string(up ? :↑ : :↓)

    msg && println("SpinOrbit created: $(name) (n = $(o.n), n′ = $(o.n′), ℓ = $(o.ℓ), ms = $(up ? 1//2 : -1//2))")

    return SpinOrbit(name, o.n, o.n′, o.ℓ, (up ? 1//2 : -1//2))

end


# ======================== Term(name, n, ℓ, S, L, J) ===========

"""
    Term(name::String, n::Int, ℓ::Int, S::Real, L::Int, J::Real)

Type for specification of atomic *fine-structure Terms* with fields:
* `name`: name
* ` .n`:  principal quantum number
* `.n′`:  radial quantum number (number of nodes in wavefunction)
* ` .ℓ`:  orbital angular momentum valence electron
* ` .S`:  total electron spin in units of ħ
* ` .L`:  total orbital angular momentum in units of ħ
* ` .J`:  total electronic angular momentum in units of ħ

The type `Term` is best created by the function `createTerm`.
"""
struct Term
    name::String         # LS term notation
    n::Int               # principal quantum number
    n′::Int              # radial quantum number (number of nodes)
    ℓ::Int               # orbital angular momentum valence electron
    S::Real              # total electron spin as integer or rational number
    L::Int               # total orbital angular momentum
    J::Real              # total electronic angular momentum as integer or rational number
end

# ======================== createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2) ===========

"""
    createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)

Specify Term in the *Term notatation* with fields:
* `.n`: principal quantum number
* `.n′`: radial quantum number (number of nodes - autogenerated)
* `.ℓ`: orbital angular momentum valence electron
* `.S`: total electron spin
* `.L`: total orbital angular momentum
* `.J`: total electronic angular momentum
#### Examples:
```
term_H1I = createTerm(1; ℓ=0, S=1//2, L=0, J=1//2)
 Term created: 1s ²S₁⸝₂, n = 1, n′ = 0, ℓ = 0, S = 1//2, L = 0, J = 1//2
 Term("1s ²S₁⸝₂", 1, 0, 0, 1//2, 0, 1//2)
```
"""
function createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)

    S = typeof(S) ∈ [Float16,Float32,Float64] ? rationalize(S) : S
    J = typeof(J) ∈ [Float16,Float32,Float64] ? rationalize(J) : J

    strL = ['s','p','d','f','g','h','i','k','l','m','n','o','q','r','t','u']

    name = string(n) * strL[ℓ + 1] * ' ' * sup(Int(2S + 1)) * uppercase(strL[L + 1]) * sub(J)

    ℓ < n || return error("Error: ℓ < n rule not satisfied")
    abs(L-S) ≤ J ≤ (L+S)  || return error("Error: Δ(LSJ) condition not satisfied")

    n′ = n - ℓ - 1

    msg && println("Term created: $(name); n = $n,  n′ = $(n′), ℓ = $ℓ, S = $S, L = $L, J = $J")

    return Term(name, n, n′, ℓ, S, L, J)

end

# ======================== bohrformula(atom, term) =============================

@doc raw"""
    bohrformula(Z::Int, n::Int)

Hydrogenic energy (in Hartree a.u.) for *atom* with *atomic number* `Z` and *principal quantum number* `n`.
```math
    E_n = - \frac{Z^2}{2n^2}
```
#### Example:
```
Z = 2
n = 4
bohrformula(Z,n)
 -0.125
```
"""
bohrformula(Z::Int, n::Int) = -(1//2)*(Z//n)^2

# ======================== mendeleev(Z) ========================================

@doc raw"""
    mendeleev(Z::Int)

The properties `name` and `symbol` of the *element* with *atomic number* `Z`.
#### Example:
```
mendeleev(11)
 ("Sodium", "Na")
```
"""
function mendeleev(Z::Int)

    0 < Z < 45 || return error("Error: element not ot to be inplemeted")

    element = Dict(1 => ("Hydrogen", "H"), 2 => ("Helium", "He"),
    3 => ("Lithium", "Li"), 4 => ("Beryllium", "Be"), 5 => ("Boron", "B"), 6 => ("Carbon", "C"),
    7 => ("Oxygen", "O"), 8 => ("Nitrogen", "N"), 9 => ("Fluorine", "F"), 10 => ("Neon", "Ne"),
    11 => ("Sodium", "Na"), 12 => ("Magnesium", "Mg"), 13 => ("Aluminium", "Al"), 14 => ("Silicon", "Si"),
    15 => ("Phosphorus", "P"), 16 => ("Sulphor", "S"), 17 => ("Chlorine", "Cl"), 18 => ("Argon", "Ar"),
    19 => ("Potassium", "K"), 20 => ("Calcium", "Ca"), 21 => ("Scandium", "Sc"), 22 => ("Titanium", "Ti"),
    23 => ("Vanadium", "Va"), 24 => ("Chromium", "Cr"), 25 => ("Manganese", "Cl"),26 => ("Iron", "Fe"),
    27 => ("Cobalt", "Co"), 28 => ("Nickel", "Ni"), 29 => ("Copper", "Cu"), 30 => ("Zinc", "Zn"),
    31 => ("Gallium", "Ga"), 32 => ("Germanium", "Ge"), 33 => ("Arsenic", "As"), 34 => ("Selenium", "Se"),
    35 => ("Bromine", "Br"), 36 => ("Krypton", "Mg"),
    37 => ("Rubidium", "Rb"), 38 => ("Strontium", "Sr"), 39 => ("Yttrium", "Y"), 40 => ("Zirconium", "Zr"),
    41 => ("Niobium", "Nb"), 42 => ("Molybdenium", "Mo"), 43 => ("Technetium", "Tc"), 44 => ("Ruthenium", "Ru"))

    return (name,symbol) = get(element,Z,nothing)

end
