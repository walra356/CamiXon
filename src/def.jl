# ======================== Pos(Nmin, Na, Nctp, Nb, N, nodes) ===================
"""
    Pos(Nmin::Int, Na::Int, Nctp::Int, Nb::Int, N::Int, nodes::Int)

Type with fields:
* ` .Nmin`: grid index of (screened) potential minimum
* `   .Na`: grid index of last leading point
* ` .Nctp`: grid index of classical turning point
* `   .Nb`: grid index first trailing point
* `    .N`: grid index last point
* `.nodes`: number of nodes

Mutable struct to hold special grid indices as well as the number of nodes
#### Examples:
```
pos = Pos(1,2,3,4,5,6)
pos.Nctp
 3

pos.Nctp = 7
pos
 Pos(1, 2, 7, 4, 5, 6)
```
"""
mutable struct Pos
    Nmin::Int
    Na::Int
    Nctp::Int
    Nb::Int
    N::Int
    nodes::Int
end

# ===========   Grid (ID, name, Type, N, r, r′, h, r0, epn, epw, k) ============

"""
    Def(T, atom, orbit, pot, scr, o1, o2, o3, pos, epn, k, am, matLD)

Type with fields:
* `    .T`: gridType (`::Type`)
* ` .atom`: atom object (`::Atom`)
* `.orbit`: orbit object (`::Orbit`)
* `  .pot`: tabulated potential function (`::Vector{T}`)
* `  .scr`: tabulated screening function (`::Vector{T}`)
* `   .o1`: vector of zero-filled matrices (`::Vector{Matrix{T}}`)
* `   .o2`: vector of zero-filled matrices (`::Vector{Matrix{T}}`)
* `   .o3`: vector of unit-filled matrices (`::Vector{Matrix{T}}`)
* `  .pos`: object containing Nmin, Na, Nctp, Nb, N and nodes (`::Pos`)
* `  .epn`: number of endpoints used for trapezoidal endpoint correction
- must be odd (`::Int`)
* `    .k`: Adams-Moulton order (`::Int`)
* `   .am`: Adams-Moulton weight coefficients (`::Vector{T}`)
* `.matLD`: Lagrangian differentiation matrix (`::Matrix{T} )

The object `Def` is best created by the function `castDef`.
"""
struct Def{T}
    T::Type
    atom::Atom
    orbit::Orbit
    pot::Vector{T}          # tabulated potential function
    scr::Vector{T}          # tabulated screening function
    o1::Vector{Matrix{T}}   # vector of zero-filled matrices
    o2::Vector{Matrix{T}}   # vector of zero-filled matrices
    o3::Vector{Matrix{T}}   # vector of unit-filled matrices
    pos::Pos                # object containing Nmin, Na, Nctp, Nb, N and nodes
    epn::Int                # number of endpoints used for trapezoidal endpoint correction (must be odd)
    k::Int                  # Adams-Moulton order
    am::Vector{T}           # Adams-Moulton weight coefficients
    matLD::Matrix{T}        # Lagrangian differentiation matrix
end

"""
    castDef(grid::Grid{T}, atom::Atom, orbit::Orbit) where T <: Real

Create the Def object starting from the Grid and atomic properties.
"""
function castDef(grid::Grid{T}, atom::Atom, orbit::Orbit; scr=nothing) where T <: Real
# ================================================================================
# castDef(grid, atom, orbit) # reference arrays
# ================================================================================
    N = grid.N
    r = grid.r
    k = grid.k
    epn = grid.epn
    Z = atom.Z
    ℓ = orbit.ℓ

    r[N]^(ℓ+1) < Inf || error("Error: numeric overflow, consider arbitrary precision type)")

    Z = myconvert(T, Z)
    num = myconvert(T, ℓ*(ℓ + 1)//2)

    r1 = T(1.0e-100)  # quasi zero
    pot = ℓ > 0 ? [(-Z + num/r[n])/r[n] for n=1:N] : [-Z/r[n] for n=1:N]
    pot[1] = ℓ > 0 ? (-Z + num/r1)/r1 : -Z/r1
    pot = convert.(T,pot)
    scr = isnothing(scr) ? zeros(T,N) : scr
    o1 = [fill(myconvert(T,0), (2,2)) for n=1:N]
    o2 = [fill(myconvert(T,0), (2,2)) for n=1:N]
    o3 = [fill(myconvert(T,1), (2,2)) for n=1:N]
    pos = Pos(1, 1, 0, N, N, 0)         # placeholders for Nmin, Na, Nctp, Nb, N and nodes
    am = myconvert.(T, create_adams_moulton_weights(k; rationalize=true))
    matLD = myconvert.(T, create_lagrange_differentiation_matrix(k))

    return Def(T, atom, orbit, pot, scr, o1, o2, o3, pos, epn, k, am, matLD)

end

"""
    initE(def::Def{T}[; E=nothing]) where T<:Real

Autogenerated seed value for the energy (option: E as a manual seed)
#### Example:
```
codata = castCodata(2018)
atom = castAtom(Z=1, Q=0, M=1.00782503223, I=1//2, gI=5.585694713)
orbit = castOrbit(n=1, ℓ=0)
Ecal = convert(Float64, bohrformula(atom.Z, orbit.n))
grid = autoGrid(atom, orbit, codata; msg=false)
def = castDef(grid, atom, orbit)
  Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.00782503223, I = 1//2, gI = 5.585694713)
  Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)

E = initE(def); println("E = $E")
  E = -0.03508495857961283

E = initE(def; E=Ecal); println("E = $E")
  E = -0.5
```
"""
function initE(def::Def{T}; E=nothing) where T<:Real

    isnothing(E) || return E

    N = def.pos.N
    ℓ = def.orbit.ℓ
    v = def.pot
    s = def.scr

    pot = v .+ s

    Emax = pot[N]
    Emin = minimum(pot[2:N])

    E = iszero(ℓ) ? 2.0Emax : 0.9Emin

    return E

end
