<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CamiXon.jl</title><link rel="canonical" href="https://walra356.github.io/CamiXon.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CamiXon.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Table-of-contents"><span>Table of contents</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Codata"><span>Codata</span></a></li><li><a class="tocitem" href="#Atomic-properties"><span>Atomic properties</span></a></li><li><a class="tocitem" href="#Grid"><span>Grid</span></a></li><li><a class="tocitem" href="#Adams-Moulton-integration"><span>Adams-Moulton integration</span></a></li><li><a class="tocitem" href="#FITS"><span>FITS</span></a></li><li><a class="tocitem" href="#FORTRAN"><span>FORTRAN</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Search-and-conversion-tools"><span>Search and conversion tools</span></a></li><li><a class="tocitem" href="#Math"><span>Math</span></a></li><li><a class="tocitem" href="#Finite-difference-methods"><span>Finite-difference methods</span></a></li><li><a class="tocitem" href="#Strings"><span>Strings</span></a></li><li><a class="tocitem" href="#Dicts"><span>Dicts</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/walra356/CamiXon.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CamiXon.jl"><a class="docs-heading-anchor" href="#CamiXon.jl">CamiXon.jl</a><a id="CamiXon.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CamiXon.jl" title="Permalink"></a></h1><p>A package for image analysis of backscattered light</p><hr/><h2 id="Table-of-contents"><a class="docs-heading-anchor" href="#Table-of-contents">Table of contents</a><a id="Table-of-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-contents" title="Permalink"></a></h2><ul><li><a href="#CamiXon.jl">CamiXon.jl</a></li><ul><li><a href="#Table-of-contents">Table of contents</a></li><li><a href="#Introduction">Introduction</a></li><li><a href="#Codata">Codata</a></li><li><a href="#Atomic-properties">Atomic properties</a></li><li><a href="#Grid">Grid</a></li><li><a href="#Adams-Moulton-integration">Adams-Moulton integration</a></li><li><a href="#FITS">FITS</a></li><li><a href="#FORTRAN">FORTRAN</a></li><li><a href="#Plotting">Plotting</a></li><li><a href="#Search-and-conversion-tools">Search and conversion tools</a></li><li><a href="#Math">Math</a></li><li><a href="#Finite-difference-methods">Finite-difference methods</a></li><li><a href="#Strings">Strings</a></li><li><a href="#Dicts">Dicts</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>CamiXon is a package for the numerical solution of the radial Schrödinger equation allowing for screening.</p><p>In this package the solution is obtained for a single electron, acting as a <em>spectator</em> in the central field of the atomic nucleus screened by &#39;the other&#39; electrons (the <em>screening</em> electrons).</p><p>The starting point is the 1D Schrödinger equation,</p><p class="math-container">\[\tilde{χ}_{l}^{′′}+2[Z_{\mathrm{eff}}(ρ)/ρ-l(l+1)/2ρ^{2}+ε_{l}]\tilde{χ}_{l}=0,\]</p><p>where <span>$\tilde{\chi}_{l}(\rho)=\rho\tilde{R}_{l}(\rho)$</span> is the reduced radial wavefunction and <span>$ε_{l}=-κ _{l}^{2}$</span> is the corresponding binding energy in Hartree atomic units (a.u.). As compared to the hydrogenic case, the atomic number <span>$Z$</span> has been replaced by <span>$Z_{\mathrm{eff}}(ρ)$</span>, the <em>effective nuclear charge</em> at radial distance <span>$ρ$</span> from the atomic center (in a.u.). In other words, the energy of the electron in the Coulomb field of the nucleus is replaced by an effective, central field potential of the form</p><p class="math-container">\[U_{\mathrm{CF}}(ρ)=-Z_{\mathrm{eff}}(ρ)/ρ=-Z/ρ+U_{\mathrm{scr}}(ρ),\]</p><p>consisting of the bare Coulomb contribution, <span>$-Z/ρ$</span>, and the screening field <span>$U_{\mathrm{scr}}(ρ)$</span>, subject to the boundary conditions <span>$U_{\mathrm{scr}}(0)=Z$</span> and <span>$\mathrm{lim}_{ρ→\infty}U_{\mathrm{scr}}(ρ)=Z_{c}/ρ$</span>. Here <span>$Z_{c}$</span> is the Rydberg charge; i.e. the effective nuclear charge for a spectator electron in the far field <span>$(ρ→\infty)$</span>. Within these assumptions we can optimize <span>$U_{\mathrm{scr}}(ρ)$</span>, while preserving the bare Coulomb field close to the nucleus as well as the Rydberg potential in the far field. The price we pay is that the radial Schrödinger equation has to be solved numerically by radial integration. Our strategy is to use both <em>inward</em> and <em>outward</em> integration and match the two branches by <em>equating the two solutions</em> for the <em>wavefunction</em>, <span>$χ(ρ)$</span>, and its <em>derivative</em>, <span>$χ^′(ρ)$</span>, at a point near the classical turning point of the radial motion of the electron. The basics of the solution can be found in the book <em>Atomic Structure Theory</em> by Walter R.Johnson.</p><h4 id="Illustration:-the-hydrogen-3d-orbital"><a class="docs-heading-anchor" href="#Illustration:-the-hydrogen-3d-orbital">Illustration: the hydrogen 3d orbital</a><a id="Illustration:-the-hydrogen-3d-orbital-1"></a><a class="docs-heading-anchor-permalink" href="#Illustration:-the-hydrogen-3d-orbital" title="Permalink"></a></h4><p>Shown below are the reduced radial wavefunction <span>$(χ)$</span> and its derivative <span>$(χ^′)$</span> in the near field (left), the far field (right), and in the region about the classical turning point (center).</p><p><img src="assets/H1_3d.png" alt="Image"/></p><h2 id="Codata"><a class="docs-heading-anchor" href="#Codata">Codata</a><a id="Codata-1"></a><a class="docs-heading-anchor-permalink" href="#Codata" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Codata" href="#CamiXon.Codata"><code>CamiXon.Codata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Codata</code></pre><p>Object to hold the natural constants from CODATA. It is best created with the function <a href="#CamiXon.castCodata-Tuple{Int64}"><code>castCodata</code></a></p><p>The fields are:</p><ul><li><code>.∆νCs</code>: Cs hyperfine transition frequency (<code>::Value</code>)</li><li><code>.c</code>: speed of light in vacuum (<code>::Value</code>)</li><li><code>.h</code>: Planck constant (<code>::Value</code>)</li><li><code>.ħ</code>: Planck constant - reduced (<code>::Value</code>)</li><li><code>.e</code>: elementary charge (<code>::Value</code>)</li><li><code>.kB</code>: Boltzmann constant (<code>::Value</code>)</li><li><code>.NA</code>: Avogadro constant (<code>::Value</code>)</li><li><code>.Kcd</code>: Luminous efficacy (<code>::Value</code>)</li><li><code>.me</code>: electron rest mass (<code>::Value</code>)</li><li><code>.R∞</code>: Rydberg constant (<code>::Value</code>)</li><li><code>.Ry</code>: Rydberg frequency (<code>::Value</code>)</li><li><code>.Eh</code>: Hartree a.u. (<code>::Value</code>)</li><li><code>.α</code>: fine-structure constant (<code>::Value</code>)</li><li><code>.μ0</code>: magnetic permitivity of vacuum (<code>::Value</code>)</li><li><code>.ε0</code>: electric permitivity of vacuum (<code>::Value</code>)</li><li><code>.KJ</code>: Josephson constant (<code>::Value</code>)</li><li><code>.RK</code>: Von Klitzing constant (<code>::Value</code>)</li><li><code>.R</code>: Molar gas constant (<code>::Value</code>)</li><li><code>.matE</code>: unit conversion matrix (Matrix{Float64})</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
codata.μ0
  Value(1.2566370621250601e-6, &quot;N A⁻²&quot;)

codata.μ0.val
  1.2566370621250601e-6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/codata.jl#LL107-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Value" href="#CamiXon.Value"><code>CamiXon.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Value(val::Real, unit::String)</code></pre><p>Object to hold a real numerical value together with a unit specifier.</p><p>The fields are:</p><ul><li><code>.val</code>: numerical value (<code>::Real</code>)</li><li><code>.unit</code>: unit specifier (<code>::String</code>)</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">f = Value(1,&quot;Hz&quot;)
  Value(1, &quot;Hz&quot;)

f.val
  1

f.unit
  &quot;Hz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/codata.jl#LL3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.strValue-Tuple{Value}" href="#CamiXon.strValue-Tuple{Value}"><code>CamiXon.strValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">strValue(f::Value)</code></pre><p>String expression for a <a href="#CamiXon.Value"><code>Value</code></a> object in <code>:compact =&gt; true</code> representation</p><p><strong>Example:</strong></p><pre><code class="language-none">f = Value(1,&quot;Hz&quot;)
strValue(f)
  &quot;1 Hz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/codata.jl#LL32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.NamedValue" href="#CamiXon.NamedValue"><code>CamiXon.NamedValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NamedValue(val::Value, name::String, comment::String)</code></pre><p>Object to hold a <a href="#CamiXon.Value"><code>Value</code></a> together with its <code>symbolic name</code> and a <code>short</code> description</p><p>The fields are:</p><ul><li><code>.val</code>: Value  (<code>::Value</code>)</li><li><code>.name</code>: symbolic name (<code>::String</code>)</li><li><code>.comment</code>: description (<code>::String</code>)</li></ul><p>Named Value object The object <code>NamedValue</code> is best created using <a href="#CamiXon.castNamedValue-Tuple{Value}"><code>castNamedValue</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = Value(1,&quot;Hz&quot;)
  Value(1, &quot;Hz&quot;, &quot;frequency&quot;)

f.name
  &quot;frequency&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/codata.jl#LL55-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castNamedValue-Tuple{Value}" href="#CamiXon.castNamedValue-Tuple{Value}"><code>CamiXon.castNamedValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castNamedValue(val::Value; name=&quot; &quot;, comment=&quot; &quot;)</code></pre><p>Method to create a <a href="#CamiXon.NamedValue"><code>NamedValue</code></a> object</p><p><strong>Example</strong></p><pre><code class="language-none">v = Value(1.602176634e-19, &quot;C&quot;)
nv = castNamedValue(v; name=&quot;e&quot;)
nv.name * &quot; = &quot; * strValue2(nv.val)
  &quot;e = 1.60218e-19 C&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/codata.jl#LL87-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castCodata-Tuple{Int64}" href="#CamiXon.castCodata-Tuple{Int64}"><code>CamiXon.castCodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castCodata(year::Int)</code></pre><p>Method to create the <a href="#CamiXon.Codata"><code>Codata</code></a> object</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
strValue.([codata.∆νCs,codata.c,codata.h])
 3-element Vector{String}:
  &quot;9192631770 Hz&quot;
  &quot;299792458 m s⁻¹&quot;
  &quot;6.62607e-34 J Hz⁻¹&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/codata.jl#LL170-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.listCodata-Tuple{Codata}" href="#CamiXon.listCodata-Tuple{Codata}"><code>CamiXon.listCodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">listCodata(codata::Codata)</code></pre><p>Method to list the fields of <a href="#CamiXon.Codata"><code>Codata</code></a> by their symbolic name</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
listCodata(codata::Codata)
  ∆νCs = 9192631770 Hz
  c = 299792458 m s⁻¹
  h = 6.62607e-34 J Hz⁻¹
  ħ = 1.05457e-34 J s
  e = 1.60218e-19 C
  kB = 1.38065e-23 J K⁻¹
  NA = 6.02214e23 mol⁻¹
  Kcd = 683 lm W⁻¹
  mₑ = 9.10938e-31 Kg
  R∞ = 1.09737e7 m⁻¹
  Ry = 3.28984e15 Hz
  Eₕ = 4.35974e-18 Hartree a.u.
  α = 0.00729735
  μ₀ = 1.25664e-6 N A⁻²
  ε₀ = 8.85419e-12 F m⁻¹
  KJ = 4.83598e14 Hz V⁻¹
  RK = 25812.8 Ω
  R = 8.31446 J mol⁻¹K⁻¹</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/codata.jl#LL241-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.convertUnit-Tuple{Any, Codata}" href="#CamiXon.convertUnit-Tuple{Any, Codata}"><code>CamiXon.convertUnit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convertUnit(val, codata::Codata; unitIn=&quot;Hartree&quot;, unitOut=&quot;xHz&quot;)</code></pre><p>Unit conversion between μHz,⋯ EHz, Hartree, Rydberg, Joule, and eV</p><p>default input: Hartree</p><p>default output: xHz ∈ {μHz, mHz, Hz, kHz, MHz, GHz, THz, PHz, EHz}</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = createCodata(2018)
convertUnit(1, codata; unitIn=&quot;Hz&quot;, unitOut=&quot;Joule&quot;)
  6.62607015e-34

convertUnit(1, codata; unitIn=&quot;Hartree&quot;, unitOut=&quot;Hz&quot;)
  Value(6.57968392050182e15, &quot;Hz&quot;)

f = convertUnit(1, codata) # default input (Hartree) and output (xHz)
strf = strValue(f)
  &quot;6.57968 PHz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/codata.jl#LL303-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.calibrationReport-Tuple{Any, Any, Codata}" href="#CamiXon.calibrationReport-Tuple{Any, Any, Codata}"><code>CamiXon.calibrationReport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calibrationReport(E, Ecal, codata::Codata; unitIn=&quot;Hartree&quot;)</code></pre><p>Comparison of energy E with calibration value Ecal</p><p>default input: Hartree</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
calibrationReport1(1.1, 1.0, codata; unitIn=&quot;Hartree&quot;)
  calibration report (Float64):
  Ecal = 1.0 Hartree
  E = 1.1 Hartree
  absolute accuracy: ΔE = 0.1 Hartree (657.968 THz)
  relative accuracy: ΔE/E = 0.0909091</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/codata.jl#LL366-L382">source</a></section></article><h2 id="Atomic-properties"><a class="docs-heading-anchor" href="#Atomic-properties">Atomic properties</a><a id="Atomic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Element" href="#CamiXon.Element"><code>CamiXon.Element</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Element(name, symbol, weight)</code></pre><p>Type with fields:</p><ul><li><code>.name</code>:  name of element (<code>::String</code>)</li><li><code>.symbol</code>:  symbol of element  (<code>::String</code>)</li><li><code>.weight</code>:  relative atomic mass - atomic weight (<code>::Float64</code>)</li></ul><p>The type <code>Element</code> is best created with the function <a href="#CamiXon.castElement-Tuple{}"><code>castElement</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Isotope" href="#CamiXon.Isotope"><code>CamiXon.Isotope</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Isotope(Z, A, radius, mass, I, π, lifetime, mdm, eqm, ra)</code></pre><p>Type with fields:</p><ul><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.N</code>:  neutron number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.R</code>:  rms charge radius in Fermi (<code>::Float64</code>)</li><li><code>.M</code>:  <em>atomic</em> mass in amu (<code>::Float64</code>)</li><li><code>.I</code>:  nuclear spin in units of ħ  (<code>::Rational{Int}</code>)</li><li><code>.π</code>:  parity of nuclear state (<code>::Int</code>)</li><li><code>.lt</code>:  lifetime inyears (<code>::Float64</code>)</li><li><code>.mdm</code>: nuclear magnetic dipole moment (<code>::Float64</code>)</li><li><code>.eqm</code>: nuclear electric quadrupole moment (<code>::Float64</code>)</li><li><code>.ra</code>:  relative abundance in % (<code>::Float64</code>)</li></ul><p>The type <code>Isotope</code> is best created with the function <a href="#CamiXon.castIsotope-Tuple{}"><code>castIsotope</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL21-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Atom" href="#CamiXon.Atom"><code>CamiXon.Atom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Atom(Z, A, Q, Zc, element, isotope)</code></pre><p>Type with fields:</p><ul><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.Q</code>:  ionic charge in a.u. (<code>::Int</code>)</li><li><code>.Zc</code>:  Rydberg charge in a.u. (<code>::Int</code>)</li><li><code>.element</code>:  (<code>::Element</code>)</li><li><code>.isotope</code>:  (<code>::Isotope</code>)</li></ul><p>The type <code>Atom</code> is best created with the function <a href="#CamiXon.castAtom-Tuple{}"><code>castAtom</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Orbit" href="#CamiXon.Orbit"><code>CamiXon.Orbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Orbit(name, n, n′, ℓ)</code></pre><p>Type for specification of <em>atomic orbitals</em> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li></ul><p>The type <code>Orbit</code> is best created with the function <code>castOrbit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL79-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.SpinOrbit" href="#CamiXon.SpinOrbit"><code>CamiXon.SpinOrbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpinOrbit</code></pre><p>Type for specification of <em>atomic spinorbitals</em> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.ms</code>:  spin magnetic quantum number</li></ul><p>The type <code>SpinOrbit</code> is best created with the function <code>createSpinOrbit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL372-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Term" href="#CamiXon.Term"><code>CamiXon.Term</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Term(name::String, n::Int, ℓ::Int, S::Real, L::Int, J::Real)</code></pre><p>Type for specification of atomic <em>fine-structure Terms</em> with fields:</p><ul><li><code>name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.S</code>:  total electron spin in units of ħ</li><li><code>.L</code>:  total orbital angular momentum in units of ħ</li><li><code>.J</code>:  total electronic angular momentum in units of ħ</li></ul><p>The type <code>Term</code> is best created with the function <code>createTerm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL425-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castElement-Tuple{}" href="#CamiXon.castElement-Tuple{}"><code>CamiXon.castElement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castElement(;Z=1, msg=true)</code></pre><p>Create Atom with fields</p><ul><li><code>.name</code>:  name of element</li><li><code>.symbol</code>:  symbol of element</li><li><code>.weight</code>:  relative atomic mass (atomic weight)</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">castElement(;Z=1, msg=true)
  Element created: hydrogen
    symbol: H
    atomic number (Z): 1
    atomic weight (relative atomic mass): 1.008 amu

  Element(&quot;hydrogen&quot;, &quot;H&quot;, 1.008)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL116-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castIsotope-Tuple{}" href="#CamiXon.castIsotope-Tuple{}"><code>CamiXon.castIsotope</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castIsotope(;Z=1, A=1, msg=true)</code></pre><p>Create Isotope with fields</p><ul><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.N</code>:  neutron number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.R</code>:  rms charge radius in Fermi (<code>::Float64</code>)</li><li><code>.M</code>:  atomic mass in amu (<code>::Float64</code>)</li><li><code>.I</code>:  nuclear spin in units of ħ (<code>::Rational{Int}</code>)</li><li><code>.π</code>:  parity of nuclear state (<code>::Int</code>)</li><li><code>.ra</code>:  relative abundance in % (<code>::Float64</code>)</li><li><code>.mdm</code>: nuclear magnetic dipole moment (<code>::Float64</code>)</li><li><code>.eqm</code>: nuclear electric quadrupole moment (<code>::Float64</code>)</li><li><code>.lt</code>:  lifetime in years (<code>::Float64</code>)</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">isotope = castIsotope(Z=1, A=3, msg=false)
  Isotope(1,-2, 3, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0, nothing)

isotope.ra
  99.9855

castIsotope(Z=1,A=3);
  Isotope created: ³H
      element: tritium
      atomic number: Z = 1
      neutron number: n = 2
      atomic mass number: A =  3 amu
      rms nuclear charge radius: R = 1.7591 fm
      atomic mass: mass = 3.016049281 amu
      nuclear spin: I = 1//2 ħ
      parity of nuclear state: π = 1
      lifetime: 12.33 years
      nuclear magnetic dipole moment: mdm = 2.97896246
      nuclear electric quadrupole moment: eqm = 0
      relative abundance: RA = trace</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL188-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castAtom-Tuple{}" href="#CamiXon.castAtom-Tuple{}"><code>CamiXon.castAtom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castAtom(;Z=1, A=1, Q=0, msg=true)</code></pre><p>Create Atom with fields:</p><ul><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.Q</code>:  ionic charge in a.u. (<code>::Int</code>)</li><li><code>.Zc</code>:  Rydberg charge in a.u. (<code>::Int</code>)</li></ul><p>*<code>.element</code>:  (<code>::Element</code>) *<code>.isotope</code>:  (<code>::Isotope</code>)</p><p><strong>Examples:</strong></p><pre><code class="language-none">atom = castAtom(Z=1, A=1, Q=0, msg=false)
  Atom(1, 1, 0, 1, Element(&quot;hydrogen&quot;, &quot;H&quot;, 1.008), Isotope(1, 0, 1, 0.8783,
  1.007825032, 1//2, 1, 1.0e100, 2.792847351, 0.0, 99.9855))

atom.isotope.ra
  99.9855

castAtom(Z=1, A=3, Q=0);
  Element created: hydrogen
      symbol: H
      atomic number (Z): 1
      atomic weight (relative atomic mass): 1.008 amu
  Isotope created: ³H
      element: tritium
      atomic number: Z = 1
      neutron number: n = 2
      atomic mass number: A =  3 amu
      rms nuclear charge radius: R = 1.7591 fm
      atomic mass: mass = 3.016049281 amu
      nuclear spin: I = 1//2 ħ
      parity of nuclear state: π = 1
      lifetime: 12.33 years
      nuclear magnetic dipole moment: mdm = 2.97896246
      nuclear electric quadrupole moment: eqm = 0
      relative abundance: RA = trace
Atom created: hydrogen - ³H (Z = 1, Zc = 1, Q = 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL275-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castOrbit-Tuple{}" href="#CamiXon.castOrbit-Tuple{}"><code>CamiXon.castOrbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castOrbit(;n=1, ℓ=0, msg=true)</code></pre><p>Create <code>Orbit</code> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">castOrbit(n=1, ℓ=0)
 Orbit created: 1s (n = 1, n′ = 0, ℓ = 0)
 Orbit(&quot;1s&quot;, 1, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL339-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.createSpinOrbit-Tuple{Orbit}" href="#CamiXon.createSpinOrbit-Tuple{Orbit}"><code>CamiXon.createSpinOrbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">createSpinOrbital(o::Orbit; up=true, msg=true)</code></pre><p>Specify <code>SpinOrbit</code> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>: principal quantum number</li><li><code>.n′</code>: radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>: orbital angular momentum valence electron</li><li><code>.ms</code>: spin magnetic quantum number</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">s1s = castOrbit(1,0)
createSpinOrbit(s1s; up=true)
  SpinOrbit created: 1s↑ (n = 1, n′ = 0, ℓ = 0, ms = 1//2)
  SpinOrbit(&quot;1s↑&quot;, 1, 0, 0, 1//2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL395-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.createTerm-Tuple{Int64}" href="#CamiXon.createTerm-Tuple{Int64}"><code>CamiXon.createTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)</code></pre><p>Specify Term in the <em>Term notatation</em> with fields:</p><ul><li><code>.n</code>: principal quantum number</li><li><code>.n′</code>: radial quantum number (number of nodes - autogenerated)</li><li><code>.ℓ</code>: orbital angular momentum valence electron</li><li><code>.S</code>: total electron spin</li><li><code>.L</code>: total orbital angular momentum</li><li><code>.J</code>: total electronic angular momentum</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">term_H1I = createTerm(1; ℓ=0, S=1//2, L=0, J=1//2)
 Term created: 1s ²S₁⸝₂, n = 1, n′ = 0, ℓ = 0, S = 1//2, L = 0, J = 1//2
 Term(&quot;1s ²S₁⸝₂&quot;, 1, 0, 0, 1//2, 0, 1//2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL451-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.bohrformula-Tuple{Int64, Int64}" href="#CamiXon.bohrformula-Tuple{Int64, Int64}"><code>CamiXon.bohrformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bohrformula(Z::Int, n::Int)</code></pre><p>Hydrogenic energy (in Hartree a.u.) for <em>atom</em> with <em>atomic number</em> <code>Z</code> and <em>principal quantum number</em> <code>n</code>.</p><p class="math-container">\[    E_n = - \frac{Z^2}{2n^2}\]</p><p><strong>Example:</strong></p><pre><code class="language-none">Z = 2
n = 4
bohrformula(Z,n)
 -0.125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/atom.jl#LL490-L505">source</a></section></article><h2 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h2><p>The <code>Grid</code> object is the backbone for the numerical procedure on a non-uniform grid. Its principal fields are <code>grid.r</code> and <code>grid.r′</code>, which are discrete functions of <code>N</code> elements representing the grid function and its derivative.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Grid" href="#CamiXon.Grid"><code>CamiXon.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Grid(ID, name, T, N, r, r′, h, r0, epn, epw, k)</code></pre><p>Type with fields:</p><ul><li><code>.ID</code>:   grid identifer name (<code>::Int</code>)</li><li><code>.name</code>: grid identifer name (<code>::String</code>)</li><li><code>.T</code>:    gridType (<code>::Type</code>)</li><li><code>.N</code>:    number of grid points (<code>::Int</code>)</li><li><code>.r</code>:   tabulated grid function (<code>::Vector{T}</code>)</li><li><code>.r′</code>:   tabulated derivative of grid function (<code>::Vector{T}</code>)</li><li><code>.h</code> :   grid step multiplyer (<code>::T</code>)</li><li><code>.r0</code>:   grid scale factor (<code>::T</code>)</li><li><code>.epn</code>:  number of endpoints used for trapezoidal endpoint correction (must be odd) (<code>::Int</code>)</li><li><code>.epw</code>:  trapezoidal endpoint weights for n=1:epn (<code>::Vector{Vector{T}}</code>)</li><li><code>.k</code>:    Adams-Moulton order (<code>::Int</code>)</li></ul><p>The object <code>Grid</code> is best created with the function <a href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>castGrid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid.jl#LL3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.gridname-Tuple{Int64}" href="#CamiXon.gridname-Tuple{Int64}"><code>CamiXon.gridname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gridname(ID::Int)</code></pre><p>Name corresponding to the grid ID.</p><p><strong>Example:</strong></p><pre><code class="language-none">n = gridname(2); println(&quot;The grid type with ID = 2 is called &#39;$n&#39;.&quot;)
  The grid type with ID = 2 is called &#39;quasi-exponential&#39;.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid_autoset.jl#LL48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.gridfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T &lt;: Real</code></pre><ul><li><code>ID = 1</code>: exponential grid function,</li></ul><p class="math-container">\[    f[n] = \text{exp}(h(n-1)) - 1.0\]</p><ul><li><code>ID = 2</code>: quasi-exponential grid function (linear grid for p = 1),</li></ul><p class="math-container">\[    f[n] = h(n-1) + \frac{1}{2}(h(n-1))^2 + ⋯ + \frac{1}{p!}(h(n-1))^p\]</p><ul><li><code>ID = 3</code>: polynomial grid function based on <code>polynom</code> <span>$c = [c_1,c_2,⋯\ c_p]$</span>,</li></ul><p class="math-container">\[    f[n] = c_1h(n-1) + c_2(h(n-1))^2 + ⋯ + c_p(h(n-1))^p\]</p><ul><li><code>ID = 4</code>: linear grid function,</li></ul><p class="math-container">\[    f[n] = (n-1) * h\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">h = 0.1
r = [gridfunction(1, n-1, h) for n=1:5]                            # exponential
 [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032, 0.49182469764127035]

r = [gridfunction(2, n-1, h; p = 4) for n=1:5]  # quasi exponential (degree p=4)
 [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375, 0.49173333333333336]

r = [gridfunction(3, n-1, h; coords = [0,1,1/2,1/6,1/24]) for n=1:5]  # polynomial (degree p=4)
 [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001, 0.49173333333333336]

r = [gridfunction(4, n-1, h) for n=1:5]              # linear
  [0.0, 0.1, 0.2, 0.3, 0.4]

r′= [gridfunction(4, n-1, h; deriv=1) for n=1:5]     # linear (first derivative)
   [0.1, 0.1, 0.1, 0.1, 0.1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid_autoset.jl#LL215-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castGrid-Tuple{Int64, Int64, Type}" href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>CamiXon.castGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castGrid(ID::Int, N::Int, T::Type; h=1, r0=1,  p=5, coords=[0,1], epn=7, k=7, msg=true)</code></pre><p>Method to create the Grid object</p><p><code>ID = 1</code>: exponential grid, <code>ID = 2</code>: quasi-exponential grid, <code>ID = 3</code>: polynomial grid <code>ID = 4</code>: linear grid</p><p><strong>Examples:</strong></p><pre><code class="language-none">h = 0.1
r0 = 1.0
grid = castGrid(1, 4, Float64; h, r0)
grid.r
  create exponential Grid: Float64, Rmax = 0.491825 a.u., Ntot = 4, h = 0.1, r0 = 1.0
  [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]

grid = castGrid(2, 4, Float64; p = 4, h, r0)
grid.r
  create quasi-exponential Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, p = 4, h = 0.1, r0 = 1.0
  [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375]

grid = castGrid(3, 4, Float64; coords=[0, 1, 1/2, 1/6, 1/24], h, r0)
grid.r
  create polynomial Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, coords = [0.0, 1.0, 0.5, 0.166666, 0.0416666], h = 0.1, r0 = 1.0
  [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001]

grid = castGrid(4, 4, Float64; h, r0)
grid.r
  create linear Grid: Float64, Rmax = 0.4 a.u., Ntot = 4, p = 1, h = 0.1, r0 = 1.0
  [0.0, 0.1, 0.2, 0.3]

grid.r′
  [0.1, 0.1, 0.1, 0.1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid.jl#LL36-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoRmax-Tuple{Atom, Orbit}" href="#CamiXon.autoRmax-Tuple{Atom, Orbit}"><code>CamiXon.autoRmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoRmax(atom::Atom, orbit::Orbit)</code></pre><p>Largest relevant radial distance in a.u. (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
atom = castAtom(Z=1, Q=0, M=1.00782503223, I=1//2, gI=5.585694713; msg=true)
orbit = castOrbit(n=1, ℓ=0)
rmax = autoRmax(atom::Atom, orbit::Orbit); println(&quot;rmax = $(rmax) a.u.&quot;)
  Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.00782503223, I = 1//2, gI = 5.585694713)
  Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)
  rmax = 63.0 a.u.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid_autoset.jl#LL99-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoNtot-Tuple{Orbit}" href="#CamiXon.autoNtot-Tuple{Orbit}"><code>CamiXon.autoNtot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoNtot(orbit::Orbit)</code></pre><p>Total number of gridpoints (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="language-none">orbit = castOrbit(1,0)
autoNtot(orbit)
 Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)

 100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid_autoset.jl#LL129-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real" href="#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real"><code>CamiXon.autoPrecision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoPrecision(Rmax::T, orbit::Orbit) where T&lt;:Real</code></pre><p>Floating point precision (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(1)
orbit = castOrbit(1,0)
Rmax = autoRmax(atom, orbit)
autoPrecision(Rmax, orbit)
 Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.0, I = 1//2, gI = 5.5)
 Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)

 Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid_autoset.jl#LL157-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.autoSteps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoSteps(ID::Int, Ntot::Int, Rmax::T; p=5, coords=[0,1]) where T&lt;:Real</code></pre><p>Step size parameter (h) and range parameter (r0) (rule of thumb values).</p><p><strong>Example:</strong></p><pre><code class="language-none">(h, r0) = autoSteps(1, 100, 100)
 (0.1, 0.004540199100968777)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid_autoset.jl#LL190-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoGrid-Tuple{Atom, Orbit, Codata, Type}" href="#CamiXon.autoGrid-Tuple{Atom, Orbit, Codata, Type}"><code>CamiXon.autoGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoGrid(atom::Atom, orbit::Orbit, codata::Codata, T::Type ; p=0, coords=[], Nmul=1, epn=7, k=7, msg=true)</code></pre><p>Automatic setting of grid parameters. Important cases:</p><ul><li><code>p=0</code> (exponential grid default)</li><li><code>p=1</code> (linear grid)</li><li><code>p&gt;1</code> (quasi-exponential grid)</li></ul><p><strong>Example:</strong></p><p>NB. plot_gridfunction is not part of the package</p><pre><code class="language-none">atom = castAtom(;Z=1, A=1, Q=0, msg=false)
orbit = castOrbit(n=75, ℓ=0, msg=false)
codata = castCodata(2018)
grid = autoGrid(atom, orbit, codata, Float64)
plot_gridfunction(1:grid.N, grid; title=&quot;&quot;)
  create exponential Grid: Float64, Rmax = 16935.0 (a.u.), Ntot = 3800, h = 0.00263158, r0 = 0.768883</code></pre><p><img src="assets/exponential_grid.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid_autoset.jl#LL266-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.grid_lagrange_derivative-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real" href="#CamiXon.grid_lagrange_derivative-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_lagrange_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_lagrange_derivative(f::Vector{T}, grid::Grid{T}; k=5) where T&lt;:Real</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the analytic function <span>$f$</span>, tabulated in forward order on a <a href="#CamiXon.Grid"><code>Grid</code></a> of <span>$n$</span> points, <span>$f[1],\ ⋯, \ f[n]$</span>; <span>$m$</span> is the multiplier for intermediate positions (for <span>$m=1$</span> <em>without</em> intermediate points).</p><p><strong>Example:</strong></p><pre><code class="language-none">ID = 4 # linear grid
f = [0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0, 81.0, 100.0]
grid = castGrid(ID, length(f), Float64; r0=1.0, h=1.0, k=3)  # linear grid
f′= grid_lagrange_derivative(f, grid, k=4)
f′= ceil.(f′;sigdigits=2); println(f′)
  create linear Grid: Float64, Rmax = 11.0 (a.u.), Ntot = 11, p = 1, h = 1.0, r0 = 1.0
  [0.0, 2.0, 4.0, 6.0, 8.1, 11.0, 12.0, 14.0, 17.0, 18.0, 20.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid.jl#LL94-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.grid_trapezoidal_integral-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{T}}} where T&lt;:Real" href="#CamiXon.grid_trapezoidal_integral-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_trapezoidal_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_trapezoidal_integral(f::Vector{T}, n1::Int, n2::Int, grid::Grid{T}) where T&lt;:Real</code></pre><p>Integral of the function <span>$f=[f_0,⋯\ f_n]$</span> tabulated on a <a href="#CamiXon.Grid"><code>Grid</code></a> using the trapezoidal rule optimized with endpoint correction by the weightsvector <code>grid.epw</code>,</p><p class="math-container">\[    ∫_{0}^{r_n} f(r) dr = ∫_{0}^{n} f(x) r^{\prime}(x) dx,\]</p><p>where the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see <a href="#CamiXon.trapezoidal_integration-Tuple{Any, Any, Any}"><code>trapezoidal_integration</code></a>). The rule is exact for polynonials of degree <span>$d=0,\ 1,⋯\ k-1$</span>, where <span>$k=$</span> <code>grid.epn</code>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Example:</strong></p><pre><code class="language-none">f1s(r) = 2.0*r*exp(-r)  # hydrogen 1s wavefunction (reduced and unit normalized)
N = 1000
grid = castGrid(1, N, Float64; h=0.01, r0=0.005)
r = grid.r
f2 = [f1s(r[n])^2 for n=1:N]
norm = grid_trapezoidal_integral(f2, 1:N, grid)
  create exponential Grid: Float64, Rmax = 110.127 (a.u.), Ntot = 1000, h = 0.01, r0 = 0.005

  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/grid.jl#LL131-L156">source</a></section></article><h2 id="Adams-Moulton-integration"><a class="docs-heading-anchor" href="#Adams-Moulton-integration">Adams-Moulton integration</a><a id="Adams-Moulton-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-integration" title="Permalink"></a></h2><p>The Adams-Moulton method is used for numerical integration of the reduces radial wave equation. In the present implementation it is constructed on top the objects <a href="#CamiXon.Atom"><code>Atom</code></a>, <a href="#CamiXon.Orbit"><code>Orbit</code></a>, <a href="#CamiXon.Grid"><code>Grid</code></a>, <a href="#CamiXon.Def"><code>Def</code></a> and <a href="#CamiXon.Adams"><code>Adams</code></a> using 5 globally defined instances called <code>atom</code>, <code>orbit</code>, <code>grid</code>, <code>def</code> and <code>adams</code>.</p><h3 id="Pos"><a class="docs-heading-anchor" href="#Pos">Pos</a><a id="Pos-1"></a><a class="docs-heading-anchor-permalink" href="#Pos" title="Permalink"></a></h3><p>The <code>Pos</code> object serves within <a href="#CamiXon.Def"><code>Def</code></a> object to contain the position indices <code>def.Na</code>, <code>def.Nb</code>, <code>def.Nlctp</code>, <code>def.Nmin</code>, <code>def.Nuctp</code> used in Adams-Moulton integration. These positions are contained in the fields <code>def.pos.Na</code>, <code>def.pos.Nb</code>, <code>def.pos.Nlctp</code>, <code>def.pos.Nmin</code>, <code>def.pos.Nuctp</code>. Alternatively, they can be determined with the functions <a href="#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>get_Na</code></a>, <a href="#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>get_Nb</code></a>, <a href="#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>get_Nlctp</code></a>, <a href="#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>get_Nmin</code></a>, <a href="#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>get_Nuctp</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Pos" href="#CamiXon.Pos"><code>CamiXon.Pos</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pos(Na::Int, Nlctp::Int, Nmin::Int, Nuctp::Int, Nb::Int, N::Int, nodes::Int)</code></pre><p>Type with fields:</p><ul><li><code>.Na</code>: grid index of last leading point (<code>::Int</code>)</li><li><code>.Nlctp</code>: grid index of classical turning point (<code>::Int</code>)</li><li><code>.Nmin</code>: grid index of (screened) potential minimum (<code>::Int</code>)</li><li><code>.Nuctp</code>: grid index of classical turning point (<code>::Int</code>)</li><li><code>.Nb</code>: grid index first trailing point (<code>::Int</code>)</li><li><code>.N</code>: grid index last point (<code>::Int</code>)</li><li><code>.nodes</code>: number of nodes  (<code>::Int</code>)</li></ul><p>Mutable struct to hold special grid indices as well as the number of nodes; <code>Pos</code> is one of the fields of the <a href="#CamiXon.Def"><code>Def</code></a> object</p><p><strong>Examples:</strong></p><pre><code class="language-none">pos = Pos(1, 2, 3, 4, 5, 6, 7)
pos.Nuctp
 4

pos.Nuctp = 8
pos
 Pos(1, 2, 3, 8, 5, 6, 7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL2-L26">source</a></section></article><h3 id="Def"><a class="docs-heading-anchor" href="#Def">Def</a><a id="Def-1"></a><a class="docs-heading-anchor-permalink" href="#Def" title="Permalink"></a></h3><p>The <code>Def</code> object serves to define the problem to be solved and to contain in the field <code>def.Z</code> the solution as a discrete function of <code>N</code> elements.</p><h4 id="Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index"><a class="docs-heading-anchor" href="#Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index">Illustration: central field potential <span>$U_{\mathrm{CF}}$</span> versus grid index</a><a id="Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index-1"></a><a class="docs-heading-anchor-permalink" href="#Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index" title="Permalink"></a></h4><p>NB. plot_potentials is not part of the package</p><pre><code class="language-none">atom = castAtom(Z=1, Q=0, M=1.00782503223, I=1//2, gI=5.585694713)
orbit = castOrbit(n=7, ℓ=2)
codata = castCodata(2018)
grid = autoGrid(atom, orbit, codata, Float64)
def = castDef(grid, atom, orbit)
E = convert(grid.T,bohrformula(atom.Z, orbit.n))
@printf &quot;E = %.15g %s \n&quot; E &quot;Hartree&quot;
adams = castAdams(E, grid, def)
plot_potentials(E, grid, def)
  Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.00782503223, I = 1//2, gI = 5.585694713)
  Orbit created: 7d - (n = 7, n′ = 4, ℓ = 2)
  create exponential Grid: Float64, Rmax = 207.0 (a.u.), Ntot = 400, h = 0.025, r0 = 0.00939821
  E = -0.0102040816326531 Hartree
  Nlctp = 234, Nmin = 259, Nuctp = 369 (Ructp = 93.0059202490 a.u.)</code></pre><p><img src="assets/potential.png" alt="Image"/></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Def" href="#CamiXon.Def"><code>CamiXon.Def</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Def(T, atom, orbit, pot, scr, o1, o2, o3, pos, epn, k, am, matLD)</code></pre><p>Type with fields:</p><ul><li><code>.T</code>: gridType (<code>::Type</code>)</li><li><code>.atom</code>: atom object (<code>::Atom</code>)</li><li><code>.orbit</code>: orbit object (<code>::Orbit</code>)</li><li><code>.pot</code>: tabulated potential function (<code>::Vector{T}</code>)</li><li><code>.scr</code>: tabulated screening function (<code>::Vector{T}</code>)</li><li><code>.o1</code>: vector of zero-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.o2</code>: vector of zero-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.o3</code>: vector of unit-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.pos</code>: object containing Na, Nlctp, Nmin, Nuctp, Nb, N and nodes (<code>::Pos</code>)</li><li><code>.epn</code>: number of endpoints trapezoidal correction - must be odd (<code>::Int</code>)</li><li><code>.k</code>: Adams-Moulton order (<code>::Int</code>)</li><li><code>.am</code>: Adams-Moulton weight coefficients (<code>::Vector{T}</code>)</li><li><code>.matLD</code>: Lagrangian differentiation matrix (<code>::Matrix{T}</code>)</li></ul><p>The object <code>Def</code> is best created with the function <a href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit}} where T&lt;:Real"><code>castDef</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL39-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit}} where T&lt;:Real" href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit}} where T&lt;:Real"><code>CamiXon.castDef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castDef(grid::Grid{T}, atom::Atom, orbit::Orbit) where T &lt;: Real</code></pre><p>Create the <a href="#CamiXon.Def"><code>Def</code></a> object starting from the <a href="#CamiXon.Grid"><code>Grid</code></a> object and the atomic properties of the objects <a href="#CamiXon.Atom"><code>Atom</code></a> and <a href="#CamiXon.Orbit"><code>Orbit</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(Z=1, Q=0, M=1.00782503223, I=1//2, gI=5.585694713)
orbit = castOrbit(n=7, ℓ=2)
codata = castCodata(2018)
grid = autoGrid(atom, orbit, codata, Float64)
def = castDef(grid, atom, orbit);
    Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.00782503223, I = 1//2, gI = 5.585694713)
    Orbit created: 7d - (n = 7, n′ = 4, ℓ = 2)
    Grid created: exponential, Float64, Rmax = 207.0 (a.u.), Ntot = 400, h = 0.025, r0 = 0.00939821
    Def created for Hydrogen 7d on exponential grid in Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL88-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.initE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initE(def::Def{T}; E=nothing) where T&lt;:Real</code></pre><p>Autogenerated seed value for the energy (default: no manual E seed)</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
atom = castAtom(Z=1, Q=0, M=1.00782503223, I=1//2, gI=5.585694713)
orbit = castOrbit(n=1, ℓ=0)
Ecal = convert(Float64, bohrformula(atom.Z, orbit.n))
grid = autoGrid(atom, orbit, codata; msg=false)
def = castDef(grid, atom, orbit)
  Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.00782503223, I = 1//2, gI = 5.585694713)
  Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)

E = initE(def); println(&quot;E = $E&quot;)
  E = -0.03508495857961283

E = initE(def; E=Ecal); println(&quot;E = $E&quot;)
  E = -0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL140-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Na</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Na(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the starting point for outward numerical integration. This is the first point where the integration threshold value (1.0e-10) is exceeded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Nb(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the stopping for outward numerical integration. This is the last point where the integration threshold value (1.0e-10) is exceeded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL205-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nlctp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Nlctp(E::T, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the *lower classical turning point * of the screened potential curve. By definition <code>get_Nlctp(E, def) = 2</code> for zero orbital angular momentum (<span>$ℓ=0$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL253-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.get_Nmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Nmin(def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the minimum of the screened potential curve. By definition <code>get_Nmin(def) = 1</code> for zero orbital angular momentum (<span>$ℓ=0$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL227-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nuctp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Nuctp(E::T, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the <em>upper classical turning point</em> of the screened potential curve. By definition <code>get_Nuctp(E, def) = N-1</code> for zero orbital angular momentum (<span>$ℓ=0$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL289-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real" href="#CamiXon.get_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_nodes(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</code></pre><p>Number of nodes (excluding the origin) of the reduced radial wavefunction χ(r) = real(Z).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/def.jl#LL323-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matG(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams-moulton.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matσ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matσ(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams-moulton.jl#LL26-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T&lt;:Real" href="#CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T&lt;:Real"><code>CamiXon.matMinv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matMinv(E::T, grid::Grid{T}, def::Def{T}, amEnd::T) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams-moulton.jl#LL59-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.OUTSCH-Union{Tuple{T}, Tuple{Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T&lt;:Real" href="#CamiXon.OUTSCH-Union{Tuple{T}, Tuple{Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T&lt;:Real"><code>CamiXon.OUTSCH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OUTSCH(grid::Grid{T}, def::Def{T}, σ::Vector{Matrix{T}}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/outsch.jl#LL47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.OUTSCH_WKB-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.OUTSCH_WKB-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.OUTSCH_WKB</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OUTSCH_WKB(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/outsch.jl#LL89-L92">source</a></section></article><h3 id="Adams"><a class="docs-heading-anchor" href="#Adams">Adams</a><a id="Adams-1"></a><a class="docs-heading-anchor-permalink" href="#Adams" title="Permalink"></a></h3><p>The <code>Adams</code> object serves to hold the Adams-Moulton integration matrices <code>matG</code>, <code>matσ</code>, <code>matMinv</code> as well as the <em>actual</em> normalized solution <code>Z</code> in the form of a tabulated function of <code>N</code> elements.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Adams" href="#CamiXon.Adams"><code>CamiXon.Adams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Adams</code></pre><ul><li>G: (<code>:Vector{Matrix{T}}</code>)</li><li>σ: (<code>:Vector{Matrix{T}}</code>)</li><li>Minv: (<code>:Vector{Matrix{T}}</code>)</li><li>Z: (<code>:Vector{Complex{T}}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams.jl#LL3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.castAdams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castAdams(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams.jl#LL20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.updateAdams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams.jl#LL44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.INSCH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">INSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/insch.jl#LL59-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_inward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_inward(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams-moulton.jl#LL143-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_outward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_outward(def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams-moulton.jl#LL93-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_normalized(Z::Vector{Complex{T}}, ΔQ::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams-moulton.jl#LL174-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.solve_adams_moulton-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T&lt;:Real" href="#CamiXon.solve_adams_moulton-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T&lt;:Real"><code>CamiXon.solve_adams_moulton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve_adams_moulton(E::T, grid::Grid{T}, def::Def{T}, adams::Adams) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/adams-moulton.jl#LL195-L198">source</a></section></article><h2 id="FITS"><a class="docs-heading-anchor" href="#FITS">FITS</a><a id="FITS-1"></a><a class="docs-heading-anchor-permalink" href="#FITS" title="Permalink"></a></h2><p>FITS stands for &#39;Flexible Image Transport System&#39;. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.</p><p>Within CamiXon only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.</p><p>A FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.</p><p>By the command <code>f = fits_read(filnam)</code> we asign a collection of <code>FITS_HDU</code> objects from the file <code>filnam</code> to the variable <code>f</code>.</p><h3 id="FITS-Types"><a class="docs-heading-anchor" href="#FITS-Types">FITS - Types</a><a id="FITS-Types-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_HDU" href="#CamiXon.FITS_HDU"><code>CamiXon.FITS_HDU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_HDU{T,V}</code></pre><p>Object to hold a single &quot;Header-Data Unit&quot; (HDU).</p><p>The fields are</p><ul><li><code>.filename</code>:  name of the corresponding FITS file (<code>::String</code>)</li><li><code>.hduindex:</code>:  identifier (a file may contain more than one HDU) (<code>:Int</code>)</li><li><code>.header</code>:  the header object where T=FITS_header (<code>::T</code>)</li><li><code>.dataobject</code>:  the data object where V=FITS_data (<code>::V</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_objects.jl#LL3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_header" href="#CamiXon.FITS_header"><code>CamiXon.FITS_header</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_header</code></pre><p>Object to hold the header information of a <a href="#CamiXon.FITS_HDU"><code>FITS_HDU</code></a>.</p><p>The fields are:</p><ul><li><code>.hduindex</code>:  identifier (a file may contain more than one HDU) (<code>::Int</code>)</li><li><code>.records</code>:  the header formated as an array of strings of 80 ASCII characters (<code>::Array{String,1}</code>)</li><li><code>.keys</code>:  <code>keys[i]</code> - key corresponding to <code>records[i]</code> (record of index <code>i</code>)  (<code>::Array{String,1}</code>)</li><li><code>.values</code>:  <code>value[i]</code> - corresponding to <code>records[i]</code>  (<code>::Array{Any,1}</code>)</li><li><code>.comments</code>:  <code>comments[i]</code> - comment corresponding to <code>records[i]</code> (<code>::String</code>)</li><li><code>.dict</code>:  Dictionary <code>key[i] =&gt; value[i]</code> (<code>::Dict{String,Any}</code>)</li><li><code>.maps</code>:  Dictionary <code>key[i] =&gt; i</code> (<code>::Dict{String,Int}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_objects.jl#LL47-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_data" href="#CamiXon.FITS_data"><code>CamiXon.FITS_data</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_data</code></pre><p>Object to hold the data of the <a href="#CamiXon.FITS_HDU"><code>FITS_HDU</code></a> of given <code>hduindex</code> and <code>hdutype</code>.</p><p>The fields are:</p><ul><li><code>.hduindex</code>:  identifier (a file may contain more than one HDU) (<code>::Int</code>)</li><li><code>.hdutype</code>:  accepted types are &#39;PRIMARY&#39;, &#39;IMAGE&#39; and &#39;TABLE&#39; (<code>::String</code>)</li><li><code>.data</code>:  in the from appropriate for the <code>hdutype</code> (::Any)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_objects.jl#LL75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_table" href="#CamiXon.FITS_table"><code>CamiXon.FITS_table</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_table</code></pre><p>Object to hold the data of a <code>TABLE HDU</code> (a <a href="#CamiXon.FITS_HDU"><code>FITS_HDU</code></a> for ASCII tables). It contains the data in the form of records (rows) of ASCII strings.</p><p>The fields are:</p><ul><li><code>.hduindex</code>:  identifier (a file may contain more than one HDU) (<code>::Int</code>)</li><li><code>.rows</code>:  the table formated as an array of rows of ASCII strings (<code>::Array{String,1}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_objects.jl#LL96-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_name" href="#CamiXon.FITS_name"><code>CamiXon.FITS_name</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_name</code></pre><p>FITS object to hold the decomposed name of a .fits file.</p><p>The fields are:</p><ul><li><code>.name</code>:  for &#39;p#.fits&#39; this is &#39;p#.fits&#39; (<code>::String</code>)</li><li><code>.prefix</code>:  for &#39;p#.fits&#39; this is &#39;p&#39; (<code>::String</code>)</li><li><code>.numerator</code>:  for &#39;p#.fits&#39; this is &#39;#&#39;, a serial number (e.g., &#39;3&#39;) or a range (e.g., &#39;3-7&#39;) (<code>::String</code>)</li><li><code>.extension</code>:  for &#39;p#.fits&#39; this is &#39;.fits&#39; (<code>::String</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_objects.jl#LL25-L35">source</a></section></article><h3 id="FITS-HDU-Methods"><a class="docs-heading-anchor" href="#FITS-HDU-Methods">FITS - HDU Methods</a><a id="FITS-HDU-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-HDU-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_info-Tuple{FITS_HDU}" href="#CamiXon.fits_info-Tuple{FITS_HDU}"><code>CamiXon.fits_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_info(hdu)</code></pre><p>Print metafinformation and data of given <code>FITS_HDU</code></p><p><strong>Example:</strong></p><pre><code class="language-none">strExample = &quot;remove.fits&quot;
data = [11,21,31,12,22,23,13,23,33]
data = reshape(data,(3,3,1))
fits_create(strExample, data; protect=false)

f = fits_read(strExample)
fits_info(f[1])

  File: remove.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Int64
  Datasize: (3, 3, 1)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  BITPIX  =                   64 / number of bits per data pixel
  NAXIS   =                    3 / number of data axes
  NAXIS1  =                    3 / length of data axis 1
  NAXIS2  =                    3 / length of data axis 2
  NAXIS3  =                    1 / length of data axis 3
  BZERO   =                  0.0 / offset data range to that of unsigned integer
  BSCALE  =                  1.0 / default scaling factor
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  END

  3×3×1 Array{Int64, 3}:
  [:, :, 1] =
   11  12  13
   21  22  23
   31  23  33
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL208-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.parse_FITS_TABLE-Tuple{FITS_HDU}" href="#CamiXon.parse_FITS_TABLE-Tuple{FITS_HDU}"><code>CamiXon.parse_FITS_TABLE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_FITS_TABLE(hdu)</code></pre><p>Parse <code>FITS_TABLE</code> (ASCII table) into a Vector of its columns for further processing by the user. Default formatting in ISO 2004 FORTRAN data format specified by keys &quot;TFORMS1&quot; - &quot;TFORMSn&quot;). Display formatting in ISO 2004 FORTRAN data format (&quot;TDISP1&quot; - &quot;TDISPn&quot;) prepared for user editing.</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample = &quot;example.fits&quot;
data = [10, 20, 30]
fits_create(strExample, data; protect=false)

t1 = Float16[1.01E-6,2.0E-6,3.0E-6,4.0E-6,5.0E-6]
t2 = [0x0000043e, 0x0000040c, 0x0000041f, 0x0000042e, 0x0000042f]
t3 = [1.23,2.12,3.,4.,5.]
t4 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]
t5 = [&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;,&quot;dddd&quot;,&quot;ABCeeaeeEEEEEEEEEEEE&quot;]
data = [t1,t2,t3,t4,t5]
fits_extend(strExample, data, &quot;TABLE&quot;)

f = fits_read(strExample)
d = f[2].header.dict
d = [get(d,&quot;TFORM$i&quot;,0) for i=1:5]; println(strip.(d))
  SubString{String}[&quot;&#39;E6.1    &#39;&quot;, &quot;&#39;I4      &#39;&quot;, &quot;&#39;F4.2    &#39;&quot;, &quot;&#39;A1      &#39;&quot;, &quot;&#39;A20     &#39;&quot;]

f[2].dataobject.data                            # this is the table hdu
  5-element Vector{String}:
   &quot;1.0e-6 1086 1.23 a a                    &quot;
   &quot;2.0e-6 1036 2.12 b bb                   &quot;
   &quot;3.0e-6 1055 3.0  c ccc                  &quot;
   &quot;4.0e-6 1070 4.0  d dddd                 &quot;
   &quot;5.0e-6 1071 5.0  e ABCeeaeeEEEEEEEEEEEE &quot;

parse_FITS_TABLE(f[2])
  5-element Vector{Vector{T} where T}:
   [1.0e-6, 2.0e-6, 3.0e-6, 4.0e-6, 5.0e-6]
   [1086, 1036, 1055, 1070, 1071]
   [1.23, 2.12, 3.0, 4.0, 5.0]
   [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
   [&quot;a                   &quot;, &quot;bb                  &quot;, &quot;ccc                 &quot;, &quot;dddd                &quot;, &quot;ABCeeaeeEEEEEEEEEEEE&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL743-L785">source</a></section></article><h3 id="FITS-File-Methods"><a class="docs-heading-anchor" href="#FITS-File-Methods">FITS - File Methods</a><a id="FITS-File-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-File-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.cast_FITS_name-Tuple{String}" href="#CamiXon.cast_FITS_name-Tuple{String}"><code>CamiXon.cast_FITS_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cast_FITS_name(filename::String)</code></pre><p>Decompose the FITS filename &#39;filnam.fits&#39; into its name, prefix, numerator and extension.</p><p><strong>Examples:</strong></p><pre><code class="language-none">strExample = &quot;T23.01.fits&quot;
f = cast_FITS_name(strExample)
FITS_name(&quot;T23.01&quot;, &quot;T23.&quot;, &quot;01&quot;, &quot;.fits&quot;)

f.name, f.prefix, f.numerator, f.extension
(&quot;T23.01&quot;, &quot;T23.&quot;, &quot;01&quot;, &quot;.fits&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_private_sector.jl#LL7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_combine-Tuple{String, String}" href="#CamiXon.fits_combine-Tuple{String, String}"><code>CamiXon.fits_combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_combine(strFirst, strLast [; protect=true])</code></pre><p>Copy &quot;filenameFirst&quot; to &quot;filenameLast&quot; (with mandatory &quot;.fits&quot; extension)</p><p>Key:</p><ul><li><code>protect::Bool</code>: overwrite protection</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">fits_combine(&quot;T01.fits&quot;, &quot;T22.fits&quot;)
  &#39;T01-T22.fits&#39;: file created</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_copy" href="#CamiXon.fits_copy"><code>CamiXon.fits_copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fits_copy(filenameA [, filenameB=&quot;&quot; [; protect=true]])</code></pre><p>Copy &quot;filenameA&quot; to &quot;filenameB&quot; (with mandatory &quot;.fits&quot; extension) Key:</p><ul><li><code>protect::Bool</code>: overwrite protection</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">fits_copy(&quot;T01.fits&quot;)
  &#39;T01.fits&#39; was saved as &#39;T01 - Copy.fits&#39;

fits_copy(&quot;T01.fits&quot;, &quot;T01a.fits&quot;)
  FitsError: &#39;T01a.fits&#39; in use (set &#39;;protect=false&#39; to lift overwrite protection)

fits_copy(&quot;T01.fits&quot;, &quot;T01a.fits&quot;; protect=false)
  &#39;T01.fits&#39; was saved as &#39;T01a.fits&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_create" href="#CamiXon.fits_create"><code>CamiXon.fits_create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fits_create(filename [, data [; protect=true]])</code></pre><p>Create FITS file of given filename [, optional data block [, default overwrite protection]] and return Array of HDUs. Key:</p><ul><li><code>protect::Bool</code>: overwrite protection</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">strExample = &quot;minimal.fits&quot;
fits_create(strExample;protect=false)

f = fits_read(strExample)
a = f[1].dataobject.data
b = f[1].header.keys
println(a);println(b)
  Any[]
  [&quot;SIMPLE&quot;, &quot;NAXIS&quot;, &quot;EXTEND&quot;, &quot;COMMENT&quot;, &quot;END&quot;]

strExample = &quot;remove.fits&quot;
data = [11,21,31,12,22,23,13,23,33]
data = reshape(data,(3,3,1))
fits_create(strExample, data; protect=false)

f = fits_read(strExample)
fits_info(f[1])

  File: remove.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Int64
  Datasize: (3, 3, 1)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  BITPIX  =                   64 / number of bits per data pixel
  NAXIS   =                    3 / number of data axes
  NAXIS1  =                    3 / length of data axis 1
  NAXIS2  =                    3 / length of data axis 2
  NAXIS3  =                    1 / length of data axis 3
  BZERO   =                  0.0 / offset data range to that of unsigned integer
  BSCALE  =                  1.0 / default scaling factor
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  END

  3×3×1 Array{Int64, 3}:
  [:, :, 1] =
   11  12  13
   21  22  23
   31  23  33</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL115-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_extend" href="#CamiXon.fits_extend"><code>CamiXon.fits_extend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fits_extend(filename, data_extend, hdutype=&quot;IMAGE&quot;)</code></pre><p>Extend the FITS file of given filename with the data of <code>hdutype</code> from <code>data_extend</code>  and return Array of HDUs.</p><p><strong>Examples:</strong></p><pre><code class="language-none">strExample = &quot;test_example.fits&quot;
data = [0x0000043e, 0x0000040c, 0x0000041f]
fits_create(strExample, data, protect=false)

f = fits_read(strExample)
a = Float16[1.01E-6,2.0E-6,3.0E-6,4.0E-6,5.0E-6]
b = [0x0000043e, 0x0000040c, 0x0000041f, 0x0000042e, 0x0000042f]
c = [1.23,2.12,3.,4.,5.]
d = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]
e = [&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;,&quot;dddd&quot;,&quot;ABCeeaeeEEEEEEEEEEEE&quot;]
data = [a,b,c,d,e]
fits_extend(strExample, data, &quot;TABLE&quot;)

f = fits_read(strExample)
f[2].dataobject.data
  5-element Vector{String}:
   &quot;1.0e-6 1086 1.23 a a                    &quot;
   &quot;2.0e-6 1036 2.12 b bb                   &quot;
   &quot;3.0e-6 1055 3.0  c ccc                  &quot;
   &quot;4.0e-6 1070 4.0  d dddd                 &quot;
   &quot;5.0e-6 1071 5.0  e ABCeeaeeEEEEEEEEEEEE &quot;

rm(strExample); f = data = a = b = c = d = e = nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL324-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_read-Tuple{String}" href="#CamiXon.fits_read-Tuple{String}"><code>CamiXon.fits_read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_read(filename)</code></pre><p>Read FITS file and return Array of <code>FITS_HDU</code>s</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample = &quot;minimal.fits&quot;
fits_create(strExample;protect=false)

f = fits_read(strExample)
f[1].dataobject.data
  Any[]

rm(strExample); f = nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL273-L288">source</a></section></article><h3 id="FITS-Key-Methods"><a class="docs-heading-anchor" href="#FITS-Key-Methods">FITS - Key Methods</a><a id="FITS-Key-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-Key-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_add_key-Tuple{String, Int64, String, Real, String}" href="#CamiXon.fits_add_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_add_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_add_key(filename, hduindex, key, value, comment)</code></pre><p>Add a header record of given &#39;key, value and comment&#39; to &#39;HDU[hduindex]&#39; of file with name &#39;filename&#39;</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;FITS dataset may contain extension&quot;)

f = fits_read(strExample)
fits_info(f[1])

  File: minimal.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Any
  Datasize: (0,)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  NAXIS   =                    0 / number of data axes
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  KEYNEW1 =                    T / FITS dataset may contain extension
  END

  Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL413-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_delete_key-Tuple{String, Int64, String}" href="#CamiXon.fits_delete_key-Tuple{String, Int64, String}"><code>CamiXon.fits_delete_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_delete_key(filename, hduindex, key)</code></pre><p>Delete a header record of given <code>key</code>, <code>value</code> and <code>comment</code> to <code>FITS_HDU[hduindex]</code> of file with name  &#39;filename&#39;</p><p><strong>Examples:</strong></p><pre><code class="language-none">strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;this is record 5&quot;)

f = fits_read(strExample)
get(f[1].header.maps,&quot;KEYNEW1&quot;,0)
  5

fits_delete_key(strExample, 1, &quot;KEYNEW1&quot;)

f = fits_read(strExample)
get(f[1].header.maps,&quot;KEYNEW1&quot;,0)
  0

fits_delete_key(filnam, 1, &quot;NAXIS&quot;)
 &#39;NAXIS&#39;: cannot be deleted (key protected under FITS standard)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL573-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_edit_key-Tuple{String, Int64, String, Real, String}" href="#CamiXon.fits_edit_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_edit_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_edit_key(filename, hduindex, key, value, comment)</code></pre><p>Edit a header record of given &#39;key, value and comment&#39; to &#39;HDU[hduindex]&#39; of file with name &#39;filename&#39;</p><p><strong>Example:</strong></p><pre><code class="language-none">data = DateTime(&quot;2020-01-01T00:00:00.000&quot;)
strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;this is record 5&quot;)
fits_edit_key(strExample, 1, &quot;KEYNEW1&quot;, data, &quot;record 5 changed to a DateTime type&quot;)

f = fits_read(strExample)
fits_info(f[1])

  File: minimal.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Any
  Datasize: (0,)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  NAXIS   =                    0 / number of data axes
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  KEYNEW1 = &#39;2020-01-01T00:00:00&#39; / record 5 changed to a DateTime type
  END

  Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL489-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_rename_key-Tuple{String, Int64, String, String}" href="#CamiXon.fits_rename_key-Tuple{String, Int64, String, String}"><code>CamiXon.fits_rename_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_rename_key(filename, hduindex, keyold, kewnew)</code></pre><p>Rename the key of a header record of file with name &#39;filename&#39;</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;this is record 5&quot;)
fits_rename_key(strExample, 1, &quot;KEYNEW1&quot;,  &quot;KEYNEW2&quot;)

f = fits_read(strExample)
fits_info(f[1])

  File: minimal.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Any
  Datasize: (0,)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  NAXIS   =                    0 / number of data axes
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  KEYNEW2 =                    T / this is record 5
  END

  Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/fits_public_sector.jl#LL654-L684">source</a></section></article><h2 id="FORTRAN"><a class="docs-heading-anchor" href="#FORTRAN">FORTRAN</a><a id="FORTRAN-1"></a><a class="docs-heading-anchor-permalink" href="#FORTRAN" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FORTRAN_format" href="#CamiXon.FORTRAN_format"><code>CamiXon.FORTRAN_format</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FORTRAN_format</code></pre><p>Object to hold a FORTRAN format specifier decomposed in its fields.</p><p>Accepted <em>datatype specifiers</em> are:  <code>Aw</code>,  <code>Iw</code>,  <code>Fw.d</code>,  <code>Ew.d</code>,  <code>Dw.d</code></p><p>Accepted <em>output formating specifiers</em> are: <code>Aw</code>,  <code>Iw.m</code>,  <code>Bw.m</code>,  <code>Ow.m</code>, <code>Zw.m</code>,  <code>Fw.d</code>,  <code>Ew.dEe</code>,  <code>ENw.d</code>,  <code>ESw.d</code>,  <code>Gw.dEe</code>,  <code>Dw.dEe</code>. Notation: <code>w</code> - width, <code>m</code> (optional) - minimum number of digits, <code>d</code> - number of digits to right of decimal, <code>e</code> - number of digits in exponent <code>N</code>/<code>S</code> (optional) indicates engineering/scientific formating of the <code>E</code> type.</p><p>The fields are:</p><ul><li><code>.Type</code>: primary FORTRAN datatype (<code>::String</code>)</li><li><code>.TypeChar</code>: primary FORTRAN datatype character (<code>::Char</code>)</li><li><code>.EngSci</code>: secundary datatype character - N for engineering/ S for scientific (<code>::Union{Char,Nothing}</code>)</li><li><code>.width</code>: width of numeric field (<code>::Int</code>)</li><li><code>.nmin</code>: minimum number of digits displayed (<code>::Int</code>)</li><li><code>.ndec</code>: number of digits to right of decimal (<code>::Int</code>)</li><li><code>.nexp</code>: number of digits in exponent (<code>::Int</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/FORTRAN.jl#LL3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.cast_FORTRAN_format-Tuple{String}" href="#CamiXon.cast_FORTRAN_format-Tuple{String}"><code>CamiXon.cast_FORTRAN_format</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cast_FORTRAN_format(format::String)</code></pre><p>Decompose the format specifier <code>format</code> into its fields and cast this into the <a href="#CamiXon.FORTRAN_format"><code>FORTRAN_format</code></a> object. Allowed format specifiers are of the types: <code>Aw</code>, <code>Iw.m</code>, <code>Bw.m</code>, <code>Ow.m</code>, <code>Zw.m</code>, <code>Fw.d</code>, <code>Ew.dEe</code>, <code>ENw.d</code>, <code>ESw.d</code>, <code>Gw.dEe</code>, <code>Dw.dEe</code>, with: <code>w</code> - width, <code>m</code>(optional) - minimum number of digits, <code>d</code> - number of digits to right of decimal, <code>e</code> - number of digits in exponent; <code>N</code>/<code>S</code> (optional) indicates engineering/scientific formating of the <code>E</code> type.</p><p><strong>Examples:</strong></p><pre><code class="language-none">f = cast_FORTRAN_format(&quot;I10&quot;)
  FORTRAN_format(&quot;Iw&quot;, &#39;I&#39;, nothing, 10, 0, 0, 0)

f = cast_FORTRAN_format(&quot;I10.12&quot;)
  FORTRAN_format(&quot;Iw.m&quot;, &#39;I&#39;, nothing, 10, 12, 0, 0)

f = cast_FORTRAN_format(&quot;E10.5E3&quot;)
  FORTRAN_format(&quot;Ew.dEe&quot;, &#39;E&#39;, nothing, 10, 0, 5, 3)

f.Type, f.TypeChar, f.EngSci, f.width, f.nmin, f.ndec, f.nexp
  (&quot;Ew.dEe&quot;, &#39;E&#39;, nothing, 10, 0, 5, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/FORTRAN.jl#LL39-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.cast_FORTRAN_datatype-Tuple{String}" href="#CamiXon.cast_FORTRAN_datatype-Tuple{String}"><code>CamiXon.cast_FORTRAN_datatype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cast_FORTRAN_datatype(format::String)</code></pre><p>Decompose the format specifier <code>format</code> into its fields and cast this into the <a href="#CamiXon.FORTRAN_format"><code>FORTRAN_format</code></a> object. Allowed format specifiers are of the types: <code>Aw</code>, <code>Iw</code>, <code>Fw.d</code>, <code>Ew.d</code>, <code>Dw.d</code>, where: <code>w</code> - width, <code>d</code> - number of digits to right of decimal point.</p><p><strong>Examples:</strong></p><pre><code class="language-none">f = cast_FORTRAN_datatype(&quot;I10&quot;)
  FORTRAN_format(&quot;Iw&quot;, &#39;I&#39;, nothing, 10, 0, 0, 0)

f = cast_FORTRAN_datatypet(&quot;F10.4&quot;)
  FORTRAN_format(&quot;Fw.d&quot;, &#39;F&#39;, nothing, 10, 0, 4, 0)

f = cast_FORTRAN_datatype(&quot;E10.5&quot;)
  FORTRAN_format(&quot;Ew.d&quot;, &#39;E&#39;, nothing, 10, 0, 5, 0)

f.Type, f.TypeChar, f.EngSci, f.width, f.nmin, f.ndec, f.nexp
  (&quot;Ew.d&quot;, &#39;E&#39;, nothing, 10, 0, 5, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/FORTRAN.jl#LL113-L134">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.step125-Tuple{Real}" href="#CamiXon.step125-Tuple{Real}"><code>CamiXon.step125</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step125(x)</code></pre><p>Step used for deviding the number x in steps according to 1-2-5 scheme</p><p><strong>Examples:</strong></p><pre><code class="language-none">step125.([5,10,21.3,50,100.1])
5-element Vector{Int64}:
  1
  2
  5
 10
 20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/plot_public_sector.jl#LL3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.select125-Tuple{Any}" href="#CamiXon.select125-Tuple{Any}"><code>CamiXon.select125</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">select125(x)</code></pre><p>Select elements of the collection x by index according to 1-2-5 scheme</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [1,2,4,6,8,10,13,16,18,20,40,60,80,100]
select125(x)
 [2, 6, 10, 16, 20, 60, 100]

x = string.(x)
select125(x)
 [&quot;2&quot;, &quot;6&quot;, &quot;10&quot;, &quot;16&quot;, &quot;20&quot;, &quot;60&quot;, &quot;100&quot;]

x = 1:100
select125(x)
 [20, 40, 60, 80, 100]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/plot_public_sector.jl#LL31-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.steps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">steps(x)</code></pre><p>Heatmap range transformation for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [4,2,6]
steps(x)
 [0, 4, 6, 12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/plot_public_sector.jl#LL78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepcenters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stepcenters(x)</code></pre><p>Stepcenter positions for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [4,2,6]
stepcenters(x)
 [2.0, 5.0, 9.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/plot_public_sector.jl#LL99-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepedges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stepedges(x)</code></pre><p>Stepedges for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [4,2,6]
stepedges(x)
 [0, 4, 6, 12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/plot_public_sector.jl#LL120-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.edges" href="#CamiXon.edges"><code>CamiXon.edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edges(px [, Δx[, x0]])</code></pre><p>Heatmap range transformation from pixel coordinates to physical coordinates, with pixelsize Δx and offset x0, both in physical units.</p><p><strong>Examples:</strong></p><pre><code class="language-">px = 1:5
Δx = 2.5
x0 = 2.5
edges(px)
 [0.5, 1.5, 2.5, 3.5, 4.5]

edges(px, Δx)
 [1.25, 3.75, 6.25, 8.75, 11.25]

edges(px, Δx, x0)
 [-1.25, 1.25, 3.75, 6.25, 8.75]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/plot_public_sector.jl#LL54-L73">source</a></section></article><h2 id="Search-and-conversion-tools"><a class="docs-heading-anchor" href="#Search-and-conversion-tools">Search and conversion tools</a><a id="Search-and-conversion-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Search-and-conversion-tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_all(A [,a...]; count=false)</code></pre><p>A: string/array of elements of the same type</p><p>default   : Array containing the index (indices) of selected elements of A (default: all elements)</p><p>count=true: The number of indices found for selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="language-none">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;
find_all(A) == find_all(B) == find_all(str)
true

find_all(A,:📌)
1-element Array{Array{Int64,1},1}:
 [2, 4]

find_all(str)
4-element Array{Array{Int64,1},1}:
 [1]
 [2, 4]
 [3]
 [5]

find_all(A; count=true)
4-element Array{Int64,1}:
 1
 2
 1
 1

str = &quot;📑📌📢📌📞&quot;
find_all(str,&#39;📌&#39;)
1-element Array{Array{Int64,1},1}:
 [2, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/search_algorithms.jl#LL1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_first(A [,a...]; dict=false)</code></pre><p>The first index of selected Array element</p><p>A: string/array of elements of the same type</p><p>default  : Array containing the first index (indices) of selected elements of A (default: all elements)</p><p>dict=true: Dict for the first index (indices) of selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="language-none">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;

find_first(A) == find_first(B) == find_first(str)
true

find_first(A,:📌)
1-element Array{Array{Int64,1},1}:
 2

find_last(A,:📌; dict=true)
1-element Array{Pair{Symbol,Int64},1}:
 :📌 =&gt; 2

find_last(A; dict=true)
4-element Array{Pair{Symbol,Int64},1}:
 :📑 =&gt; 1
 :📌 =&gt; 2
 :📢 =&gt; 3
 :📞 =&gt; 5

find_first(str)
4-element Array{Int64,1}:
 1
 2
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/search_algorithms.jl#LL53-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_last(A [,a...]; dict=false)</code></pre><p>The last index of selected Array element</p><p>A: string/array of elements of the same type</p><p>default  : Array containing the lasst index (indices) of selected elements of A (default: all elements)</p><p>dict=true: Dict for the lasst index (indices) of selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="language-none">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;
find_last(A) == find_first(B) == find_first(str)
true

find_last(A,:📌)
1-element Array{Array{Int64,1},1}:
 4

find_last(A,:📌; dict=true)
1-element Array{Pair{Symbol,Int64},1}:
 :📌 =&gt; 4

find_last(A; dict=true)
4-element Array{Pair{Symbol,Int64},1}:
 :📑 =&gt; 1
 :📌 =&gt; 4
 :📢 =&gt; 3
 :📞 =&gt; 5

find_last(str)
4-element Array{Int64,1}:
 1
 4
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/search_algorithms.jl#LL106-L146">source</a></section></article><h2 id="Math"><a class="docs-heading-anchor" href="#Math">Math</a><a id="Math-1"></a><a class="docs-heading-anchor-permalink" href="#Math" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.bernoulli_numbers-Tuple{Int64}" href="#CamiXon.bernoulli_numbers-Tuple{Int64}"><code>CamiXon.bernoulli_numbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bernoulli_numbers(nmax [, T=Int])</code></pre><p>Bernoulli numbers <span>$B_0,⋯\ B_{nmax}$</span> calculated by repetative use of the recurrence relation</p><p class="math-container">\[    B_n = - \frac{1}{n+1}\sum_{k=0}^{n-1}\frac{(n+1)!}{k!(n+1-k)}B_k.\]</p><p>Special numbers: <span>$B_0=1,\ B_1=-1/2,\ B_{2n+1}=0\ (\rm{for}\ n&gt;1)$</span>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">bernoulli_numbers(10)
11-element Vector{Rational{Int64}}:
  1//1
 -1//2
  1//6
  0//1
 -1//30
  0//1
  1//42
  0//1
 -1//30
  0//1
  5//66</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.canonical_partitions" href="#CamiXon.canonical_partitions"><code>CamiXon.canonical_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">canonical_partitions(n; header=false, reverse=true)</code></pre><p>The canonical partition in integers of the integer n</p><p>header=true : unit patition included in output</p><p><strong>Examples:</strong></p><pre><code class="language-none">canonical_partitions(6; header=true, reverse=false)
6-element Array{Array{Int64,1},1}:
 [6]
 [5, 1]
 [4, 2]
 [3, 3]
 [2, 2, 2]
 [1, 1, 1, 1, 1, 1]

canonical_partitions(6; header=true)
6-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1]
 [2, 2, 2]
 [3, 3]
 [4, 2]
 [5, 1]
 [6]

canonical_partitions(6)
5-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1]
 [2, 2, 2]
 [3, 3]
 [4, 2]
 [5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL325-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.faulhaber_polynom-Tuple{Int64}" href="#CamiXon.faulhaber_polynom-Tuple{Int64}"><code>CamiXon.faulhaber_polynom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">faulhaber_polynom(p [, T=Int])</code></pre><p>Vector representation of the Faulhaber polynomial of degree <span>$p$</span>,</p><p class="math-container">\[    F(n,p)=\frac{1}{p}\sum_{j=1}^{p}{\binom {p}{p-j}}B_{p-j}n^{j}.\]</p><p><span>$F(n,p)=$</span> <code>polynomial(c,n)</code>, where <span>$c=[c_0,⋯\ c_p]$</span> is the coefficient vector, with</p><p class="math-container">\[    c_0=0,\ c_j=\frac{1}{p}{\binom {p}{p-j}}B_{p-j},\]</p><p>with <span>$j∈\{ 1,⋯\ p\}$</span>. The <span>$B_0,⋯\ B_{p-1}$</span> are Bernoulli numbers (but with <span>$B_1=+\frac{1}{2}$</span> rather than <span>$-\frac{1}{2}$</span>).</p><p><strong>Example:</strong></p><pre><code class="language-none">faulhaber_polynom(6)
7-element Vector{Rational{Int64}}:
  0//1
  0//1
 -1//12
  0//1
  5//12
  1//2
  1//6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL71-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.faulhaber_summation-Tuple{Int64, Int64}" href="#CamiXon.faulhaber_summation-Tuple{Int64, Int64}"><code>CamiXon.faulhaber_summation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">faulhaber_summation(n, p [, T=Int])</code></pre><p>Sum of powers of natural numbers <span>$1,⋯\ n$</span>,</p><p class="math-container">\[    FS(n,p)=\sum_{k=1}^{n}k^{p}=F(n,p+1).\]</p><p>where <span>$F(n,p)$</span> is the Faulhamer polynomial of degree <span>$p$</span>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">faulhaber_summation(5,1)
 15

faulhaber_summation(3,60; T=BigInt)
  42391158276369125018901280178</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL130-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.harmonic_number-Tuple{Int64, Int64}" href="#CamiXon.harmonic_number-Tuple{Int64, Int64}"><code>CamiXon.harmonic_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">harmonic_number(n, p [, T=Int])</code></pre><p>Sum of the <span>$p_{th}$</span> power of reciprocals of the first <span>$n$</span> numbers</p><p class="math-container">\[    H_{n,p}=\sum_{k=1}^{n}\frac{1}{k^p}.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">harmonic_number(12, 3)
 25535765062457//21300003648000

harmonic_number(12, 5; T=BigInt)
 16971114472329088045481//16366888723117363200000

harmonic_number(12, -3) == faulhaber_summation(12, 3)
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL234-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.harmonic_number-Tuple{Int64}" href="#CamiXon.harmonic_number-Tuple{Int64}"><code>CamiXon.harmonic_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">harmonic_number(n [, T=Int])</code></pre><p>Sum of the reciprocals of the first <span>$n$</span> natural numbers</p><p class="math-container">\[    H_n=\sum_{k=1}^{n}\frac{1}{k}.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">o = [harmonic_number(i) for i=1:10]; println(o)
 [1//1, 3//2, 11//6, 25//12, 137//60, 49//20, 363//140, 761//280, 7129//2520, 7381//2520]

harmonic_number(60; T=BigInt)
 15117092380124150817026911//3230237388259077233637600

harmonic_number(12) == harmonic_number(12, 1)
 true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL186-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.integer_partitions" href="#CamiXon.integer_partitions"><code>CamiXon.integer_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">integer_partitions(n [,m]; transpose=false, count=false)</code></pre><p>default              : The integer partitions of n</p><p>count=true           : The number of integer partitions of n</p><p>transpose=false/true : for m&gt;0 restricted to partitions with maximum part/length m</p><p>definitions:</p><p>The integer partition of the positive integer n is a nonincreasing sequence of positive integers p1, p2,... pk whose sum is n.</p><p>The elements of the sequence are called the parts of the partition.</p><p><strong>Examples:</strong></p><pre><code class="language-none">integer_partitions(7)
15-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1, 1]
 [2, 2, 2, 1]
 [3, 3, 1]
 [4, 3]
 [5, 2]
 [6, 1]
 [7]
 [2, 2, 1, 1, 1]
 [3, 2, 2]
 [4, 2, 1]
 [5, 1, 1]
 [2, 1, 1, 1, 1, 1]
 [3, 2, 1, 1]
 [4, 1, 1, 1]
 [3, 1, 1, 1, 1]

integer_partitions(7; count=true)
15

integer_partitions(7,4; count=true)
3

integer_partitions(7,4)
3-element Array{Array{Int64,1},1}:
 [4, 3]
 [4, 2, 1]
 [4, 1, 1, 1]

integer_partitions(7,4; transpose=true)
3-element Array{Array{Int64,1},1}:
 [2, 2, 2, 1]
 [3, 2, 1, 1]
 [4, 1, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL413-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.log10_characteristic_power-Tuple{Any}" href="#CamiXon.log10_characteristic_power-Tuple{Any}"><code>CamiXon.log10_characteristic_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log10_characteristic_power(x)</code></pre><p>characteristic power-of-10 of the number x</p><p><strong>Examples:</strong></p><pre><code class="language-none">log10_characteristic_power.([3,30,300])
3-element Vector{Int64}:
 0
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL501-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.log10_mantissa-Tuple{Any}" href="#CamiXon.log10_mantissa-Tuple{Any}"><code>CamiXon.log10_mantissa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log10_mantissa(x)</code></pre><p>log10 mantissa of the number x</p><p><strong>Examples:</strong></p><pre><code class="language-none">log10_mantissa.([3,30,300])
3-element Vector{Float64}:
 0.47712125471966244
 0.4771212547196624
 0.4771212547196626</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL517-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.permutations_unique_count-Tuple{Vector{Vector{Int64}}, Int64}" href="#CamiXon.permutations_unique_count-Tuple{Vector{Vector{Int64}}, Int64}"><code>CamiXon.permutations_unique_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permutations_unique_count(p::Array{Array{Int64,1},1}, i::Int)</code></pre><p>Number of unique permutations of the subarray <span>$p[i]$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">p = [[1,2,3],[2,3,1,4,3]]
permutations_unique_count(p,2)
 60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL612-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.pascal_triangle-Tuple{Int64}" href="#CamiXon.pascal_triangle-Tuple{Int64}"><code>CamiXon.pascal_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pascal_triangle(nmax [, T=Int])</code></pre><p>Pascal triangle of binomial coefficients <span>$\binom{n}{k}$</span> for <span>$n=0,\ 1,⋯\ nmax$</span></p><p><strong>Example:</strong></p><pre><code class="language-none">pascal_triangle(5)
6-element Vector{Vector{Int64}}:
 [1]
 [1, 1]
 [1, 2, 1]
 [1, 3, 3, 1]
 [1, 4, 6, 4, 1]
 [1, 5, 10, 10, 5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL534-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.pascal_next-Tuple{Vector{Int64}}" href="#CamiXon.pascal_next-Tuple{Vector{Int64}}"><code>CamiXon.pascal_next</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pascal_next(nmax)</code></pre><p>Next row of Pascal triangle</p><p><strong>Example:</strong></p><pre><code class="language-none">a = [1, 4, 6, 4, 1]
pascal_next(a)
 [1, 5, 10, 10, 5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL585-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real" href="#CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>CamiXon.pochhammer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pochhammer(x::T, p::Int) where T&lt;:Real</code></pre><p>Pochhammer symbol <span>$(x)_{p}$</span>,</p><p class="math-container">\[(x)_{p}=\begin{cases}
1 &amp; p=0\\
x(x+1)(x+2)⋯(x+p-1) &amp; p&gt;0
\end{cases}\]</p><p>Note that <span>$(x)_{p}=0$</span> for <span>$x=0,-1,⋯\ -(p-1)$</span></p><p><strong>Examples:</strong></p><pre><code class="language-none">x = [-4,-3,-2,-1, 0, 1, 2 , 3, 4]
pochhammer.(x,5) == [0, 0, 0, 0, 0, 120, 720, 2520, 6720]
  true

pochhammer.(x,0) == [1, 1, 1, 1, 1, 1, 1, 1, 1]
  true

o = [pochhammer.([x for x=0:-1:-p],p) for p=0:5]
println(&quot;non-positive integer x = 0,⋯\ -p:&quot;)
for p=0:5
    println(&quot;p = $p: $(o[p+1])&quot;)
end
  non-positive integer x = 0,⋯\ -p:
  p = 0: [1]
  p = 1: [0, -1]
  p = 2: [0, 0, 2]
  p = 3: [0, 0, 0, -6]
  p = 4: [0, 0, 0, 0, 24]
  p = 5: [0, 0, 0, 0, 0, -120]

 o = [pochhammer.([x for x=0:p],p) for p=0:5]
 println(&quot;non-negative integer x = 0,⋯\  p:&quot;)
 for p=0:5
     println(&quot;p = $p: $(o[p+1])&quot;)
 end
   non-negative integer x = 0,⋯\  p:
   p = 0: [1]
   p = 1: [0, 1]
   p = 2: [0, 2, 6]
   p = 3: [0, 6, 24, 60]
   p = 4: [0, 24, 120, 360, 840]
   p = 5: [0, 120, 720, 2520, 6720, 15120]

x = -1//50
pochhammer(x,20)
  OverflowError: -1491212300990613201 * 449 overflowed for type Int64

x = convert(Rational{BigInt}, -1//50)
pochhammer(x,20)
  -21605762356630090481082546653745369902321614221999//9536743164062500000000000000000000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL638-L693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynomial-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Number" href="#CamiXon.polynomial-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Number"><code>CamiXon.polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynomial(coords::Vector{T}, x::T[; deriv=0]) where T&lt;:Number</code></pre><p>Method to evaluate the function <span>$f(x)=\text{polynomial}(c,x)$</span>, where <span>$c=[c_0,⋯\ c_d]$</span> is the vector representation of a polynomial of degree <span>$d$</span>.</p><p class="math-container">\[    \text{polynomial}(c,x)=c_0 + c_1 x + ⋯ + c_d x^d.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords = ones(Int,6)                     # for polynomial of degree 5 with unit coefficients
f0(x) = polynomial(coords,x)             # default
fd(x) = polynomial(coords,x; deriv=1)    # first derivative
fp(x) = polynomial(coords,x; deriv=-1)   # primitive (with zero integration constant)
f0(1)
 6

fd(1)
 15

fp(1)
 49//20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL710-L733">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_derivative-Tuple{Vector{&lt;:Number}}" href="#CamiXon.polynom_derivative-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_derivative(coords)</code></pre><p>Vector representation of the first derivative of the polynomial <code>coords</code>,</p><p class="math-container">\[    p&#39;(c,x)=c_1 + 2 c_2 x + ⋯ + d c_d x^{d-1},\]</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]                 # vector representation of polynomial of degree d=4
polynom_derivative(coords)         # (first) derivative of polynomial `coords`
4-element Vector{Int64}:
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL751-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_derivatives-Tuple{Vector{&lt;:Number}}" href="#CamiXon.polynom_derivatives-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivatives</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_derivatives(coords::Vector{&lt;:Number}[;deriv=0])</code></pre><p>Vector representation of derivatives of the polynomial <code>coords</code>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><code>deriv</code>: derivative of choice; <code>default</code>: <code>coords</code> remains unchanged.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]               # vector representation of a polynomial of degree d=4
polynom_derivatives(coords)      # default no (zero) derivative of polynomial `coords`
5-element Vector{Vector{Int64}}:
 1
 1
 1
 1
 1

polynom_derivatives(coords; deriv=2)        # second derivative of polynomial `coords`
3-element Vector{Int64}:
  2
  6
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL783-L811">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_derivatives_all-Tuple{Vector{&lt;:Number}}" href="#CamiXon.polynom_derivatives_all-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivatives_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_derivatives_all(coords::Vector{&lt;:Number})</code></pre><p>Vector representation of all nontrivial derivatives of the polynomial <code>coords</code>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]               # vector representation of a polynomial of degree d=4
polynom_derivatives_all(coords)      # `all&#39; (nontrivial) derivatives of polynomial `coords`
5-element Vector{Vector{Int64}}:
 [1, 2, 3, 4]
 [2, 6, 12]
 [6, 24]
 [24]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL826-L845">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_power-Tuple{Vector{&lt;:Number}, Int64}" href="#CamiXon.polynom_power-Tuple{Vector{&lt;:Number}, Int64}"><code>CamiXon.polynom_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_power(coords, p)</code></pre><p>Vector representation of the polynomial <code>coords</code> raised to the power <code>p</code> which results in a polynomial in a vector space of dimension <span>$p d + 1$</span>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1]             # vector representation of polynomial of degree ``d=2``
polynom_power(coords,2)
5-element Vector{Int64}:
 1
 2
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL864-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_powers-Tuple{Vector{&lt;:Number}, Int64}" href="#CamiXon.polynom_powers-Tuple{Vector{&lt;:Number}, Int64}"><code>CamiXon.polynom_powers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_powers(coords, pmax)</code></pre><p>The polynomial <code>coords</code> raised to the powers 1,...,pmax  which results in a collection of polynomials in vector spaces of dimension <span>$d+1$</span> tot <span>$p d + 1$</span>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1]                   # vector representation of polynomial of degree d=2
polynom_powers(coords,3)
3-element Vector{Vector{Int64}}:
 [1, 1, 1]
 [1, 2, 3, 2, 1]
 [1, 3, 6, 7, 6, 3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL904-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_primitive-Tuple{Vector{&lt;:Number}}" href="#CamiXon.polynom_primitive-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_primitive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_primitive(coords)</code></pre><p>Vector representation of the primitive of the polynomial <code>coords</code> which is a polynomial in a vector space of dimension <span>$p d + 1$</span>.</p><p class="math-container">\[    P(c,x)=c_{int} +c_0 x + \frac{1}{2} c_1 x^2 + \frac{1}{3} c_2 x^3 + ⋯ + \frac{1}{d+1} c_d x^{d+1},\]</p><p>The constant of integration is set to zero, <span>$c_{int} = 0$</span>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]         # vector representation of polynomial of degree ``d=4``
polynom_primitive(coords)
6-element Vector{Rational{Int64}}:
 0//1
 1//1
 1//2
 1//3
 1//4
 1//5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL939-L964">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_product-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number" href="#CamiXon.polynom_product-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>CamiXon.polynom_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_product(a::Vector{T}, b::Vector{V}) where {T&lt;:Number, V&lt;:Number}</code></pre><p>Vector representation of the product of two polynomials, <span>$a$</span> and <span>$b$</span> which is a polynomial in a vector space of dimension <span>$d=m+n$</span>,</p><p class="math-container">\[    p(c,x)=a_0b_0 + (a_0b_1 + b_0a_1)x + ⋯ + a_n b_m x^{n+m}.\]</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span> The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong></strong></p><pre><code class="language-none">[polynom_product1([1.0,1],[1,-1,2])]
 [1.0, 0.0, 1.0, 2.0]

[polynom_product1([1//1,1],[1,-1,2])]
 [1//1, 0//1, 1//1, 2//1]

[polynom_product([1,1],[1,- 1,2])]
 [1, 0, 1, 2]

[polynom_product([1,- 1,2],[1,1])]
 [1, 0, 1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL977-L1002">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_product_expansion-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:Number" href="#CamiXon.polynom_product_expansion-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:Number"><code>CamiXon.polynom_product_expansion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_product_expansion(a::Vector{T}, b::Vector{T}, p::Int) where T&lt;:Number</code></pre><p>Vector representation of the product of two polynomials, <span>$a$</span> (of degree <span>$n$</span>) and <span>$b$</span> (of degree <span>$m$</span>), with <span>$m≤n$</span> truncated at the order <span>$p$</span> is a polynomial in a vector space of dimension <span>$d=p+1$</span>. If <span>$ab$</span> is the <code>polynom_product</code>, the <code>polynom_product_expansion</code> is <span>$ab[1:p+1]$</span></p><p><strong></strong></p><pre><code class="language-none">a = [1,-1,1]
b = [1,1,-1,1,1,1]
o = polynom_product(a, b); println(o)
 [1, 0, -1, 3, -1, 1, 0, 1]

o = expand_product(a, b, 4); println(o)
 [1, 0, -1, 3, -1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL1026-L1043">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.texp-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Real" href="#CamiXon.texp-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Real"><code>CamiXon.texp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">texp(x::T, a::T, p::Int) where T &lt;: Real</code></pre><p>Taylor expansion of exp(x) about <span>$x = a$</span> up to order p.</p><p class="math-container">\[    \mathsf{texp}(x,a,p) = 1 + (x-a) + \frac{1}{2}(x-a)^2 + ⋯ + \frac{1}{p!}(x-a)^p.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">p = 5
texp(1.0, 0.0, 5)
 2.7166666666666663

texp(1, 0, 5)
 163//60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL1101-L1117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.VectorRational" href="#CamiXon.VectorRational"><code>CamiXon.VectorRational</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorRational</code></pre><p>Object to decompose a vector of rational numbers</p><p>The fields are:</p><ul><li><code>.num::Vector{Int}</code>`: vector of normalized numerators</li><li><code>.den::Int</code>: common denominator</li><li><code>.val::Vector{Rational}</code>: vector of rational numbers (simplified = not normalized)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL1130-L1139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.normalize_VectorRational-Tuple{Vector{Rational{Int64}}}" href="#CamiXon.normalize_VectorRational-Tuple{Vector{Rational{Int64}}}"><code>CamiXon.normalize_VectorRational</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize_VectorRational(vec::Vector{Rational{Int}})</code></pre><p>Decompose vector of rational numbers.</p><p><strong>Example:</strong></p><pre><code class="language-none">v = [2//3,4//5]
normalize_VectorRational(v)
 VectorRational([10, 12], 15, Rational{Int64}[2//3, 4//5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/mathematics.jl#LL1150-L1160">source</a></section></article><h2 id="Finite-difference-methods"><a class="docs-heading-anchor" href="#Finite-difference-methods">Finite-difference methods</a><a id="Finite-difference-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-methods" title="Permalink"></a></h2><h3 id="Finite-differences"><a class="docs-heading-anchor" href="#Finite-differences">Finite differences</a><a id="Finite-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-differences" title="Permalink"></a></h3><p>Consider the analytical function <span>$f$</span> tabulated in <em>forward order</em>   (growing index) at <span>$n$</span> positions on a <em>uniform grid</em>.</p><p><strong>Forward difference notation</strong></p><p>In <em>forward difference</em> notation, the <em>finite difference</em> of two adjacent values on the grid is defined as</p><p class="math-container">\[Δ f[n] = f[n+1]-f[n],\]</p><p>where <span>$Δ$</span> is the forward difference operator. In this notation, the  <span>$k^{th}$</span>-<em>order forward difference</em> involves <span>$k+1$</span> points and is defined as a <em>weighted sum</em> over the function values <span>$f[n],⋯\ f[n+k]$</span>,</p><p class="math-container">\[Δ^k f[n] = c_{k}^kf[n] + c_{k-1}^kf[n+1] + ⋯  + f[n+k]
= \sum_{j=0}^{k} c_{k-j}^k f[n-j].\]</p><p>The <span>$k+1$</span> coefficients</p><p class="math-container">\[c_{j}^{k}=(-1)^{j}\binom{k}{j}\]</p><p>are the <em>summation weights</em> (short: <em>weights</em>) which define the summation. Note that <span>$c_{0}^{k}≡1$</span> and <span>$c_{k}^{k}≡(-1)^{k}$</span>. In inner-product form the forward difference equation is given by</p><p class="math-container">\[Δ^k f[n]
= \sum_{j=0}^{k} c_{k-j}^kf[n+j]=\bar{c}^k \cdot f[n:n+k],\]</p><p>where the bar indicates backward order and</p><p class="math-container">\[f[n:n+k] = \left[\begin{array}{c}
f[n]\\
\vdots\\
f[n+k]
\end{array}\right].\]</p><p>Functions:  </p><p><a href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>fdiff_weight(k,j)</code></a> <span>$→ c_{j}^{k}=(-1)^{j}\binom{k}{j}$</span></p><p><a href="#CamiXon.fdiff_weights-Tuple{Int64}"><code>fdiff_weights(k)</code></a> <span>$→ \bar{c}^k ≡ [c_k^k,\ c_1^k,⋯\ c_0^k]$</span></p><p><a href="#CamiXon.fdiff_weights_array-Tuple{Int64}"><code>fdiff_weights_array(kmax)</code></a> <span>$→ Λ ≡ [\bar{c}^0,\ \bar{c}^1,⋯\ \bar{c}^{kmax} ]$</span></p><p><strong>Backward difference notation</strong></p><p>In <em>backward difference</em> notation, the <em>finite difference</em> of two adjacent values on the grid is defined as</p><p class="math-container">\[∇ f[n] = f[n]-f[n-1],\]</p><p>where <span>$∇$</span> is the backward difference operator. In this notation, the <span>$k^{th}$</span>-<em>order backward difference</em> (which involves <span>$k+1$</span> points) is defined as a <em>weighted sum</em> over the function values in backward order, <span>$f[n],⋯\ f[n-k]$</span>,</p><p class="math-container">\[∇^k f[n] = f[n] + c_1^kf[n-1] + ⋯ + c_k^kf[n-k]
= \sum_{j=0}^{k} c_j^kf[n-j]=c^k \cdot f[n:-1:n-k],\]</p><p>where the <span>$c_{j}^{k}$</span> are the <span>$k+1$</span> <em>summation weights</em> defined above. As the function <span>$f$</span> is tabulated in forward order it is good practice to change dummy index to also write the function iterator in forward order (coefficients in backward order). In inner product notation this becomes</p><p class="math-container">\[∇^k f[n]
= \sum_{j=0}^{k} c_{k-j}^kf[n-k+j]=\bar{c}^k \cdot f[n-k:n],\]</p><p>Functions:  </p><p><a href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>fdiff_weight(k,j)</code></a> <span>$→ c_{j}^{k}=(-1)^{j}\binom{k}{j}$</span></p><p><a href="#CamiXon.fdiff_weights-Tuple{Int64}"><code>fdiff_weights(k)</code></a> <span>$→ \ \bar{c}^k ≡ [c_k^k,c_1^k,⋯\ c_0^k]$</span></p><p><a href="#CamiXon.fdiff_weights_array-Tuple{Int64}"><code>fdiff_weights_array(kmax)</code></a> <span>$→ Λ ≡ [\bar{c}^0,\ \bar{c}^1,⋯\ \bar{c}^{kmax} ]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_weight-Tuple{Int64, Int64}" href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>CamiXon.fdiff_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_weight(k, j)</code></pre><p>Finite difference weight coefficient</p><p class="math-container">\[c_{j}^{k}=(-1)^{j}\binom{k}{j},\]</p><p>Function:</p><p><code>fdiff_weight(k,j)</code>] <span>$→ c_j^k$</span></p><p><strong>Example:</strong></p><pre><code class="language-none">c(k,j) = fdiff_weight(k,j)
c(5,3)
 -10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_weights-Tuple{Int64}" href="#CamiXon.fdiff_weights-Tuple{Int64}"><code>CamiXon.fdiff_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_weights(k)</code></pre><p>Finite difference weights vector defining the <span>$k^{th}$</span> <em>order finite difference summation weights</em>,</p><p><a href="#CamiXon.fdiff_weights-Tuple{Int64}"><code>fdiff_weights(k)</code></a> <span>$→ \ \bar{c}^k ≡ [c_k^k,\ c_1^k,⋯\ c_0^k]$</span>,</p><p>where <a href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>fdiff_weight(k,j)</code></a> <span>$→ \bar{c}_j^k$</span>.</p><p>Applications:</p><p><strong>Forward difference notation</strong></p><p>The <em>forward difference</em> summation is</p><p class="math-container">\[Δ^k f[n]=\sum_{j=0}^{k} c_{k-j}^kf[n+j]=\bar{c}^k \cdot f[n:n+k].\]</p><p>This convention applies to <em>analytical</em> functions, <span>$f$</span>, tabulated in <em>forward</em> order as <span>$f[n],⋯\ f[n+k]$</span>.</p><p><strong>Backward difference notation</strong></p><p>The <em>backward difference</em> summation is</p><p class="math-container">\[∇^{k}f[n]=\sum_{j=0}^{k}c_{k-j}^kf[n-k+j]=\bar{c}^k \cdot f[n-k:n].\]</p><p>This convention applies to <em>analytical</em> functions, <span>$f$</span>, tabulated in <em>forward</em> order as <span>$f[n-k],⋯\ f[n]$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">c(k) = fdiff_weights(k)
c(3)
4-element Vector{Int64}:
  1
 -3
  3
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL23-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_weights_array-Tuple{Int64}" href="#CamiXon.fdiff_weights_array-Tuple{Int64}"><code>CamiXon.fdiff_weights_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_weights_array(kmax)</code></pre><p>Collection of finite difference weight vectors,</p><p><a href="#CamiXon.fdiff_weights_array-Tuple{Int64}"><code>fdiff_weights_array(kmax)</code></a> <span>$→ Λ ≡ [\bar{c}^0,\ \bar{c}^1,⋯\ \bar{c}^{kmax} ]$</span>,</p><p>where <a href="#CamiXon.fdiff_weights-Tuple{Int64}"><code>fdiff_weights(k)</code></a> <span>$→ \bar{c}^k ≡ [c_k^k,\ c_{k-1}^k,⋯\ c_0^k]$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">kmax = 3
Λ = fdiff_weights_array(kmax)
4-element Vector{Vector{Int64}}:
 [1]
 [-1, 1]
 [1, -2, 1]
 [-1, 3, -3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL69-L89">source</a></section></article><h3 id="Finite-difference-expansions"><a class="docs-heading-anchor" href="#Finite-difference-expansions">Finite difference expansions</a><a id="Finite-difference-expansions-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-expansions" title="Permalink"></a></h3><p>Finite-difference calculus builds on the <em>finite-difference expansion</em>.</p><p><strong>Forward difference notation</strong></p><p>In terms of forward differences the expansion takes the form</p><p class="math-container">\[\sum_{p=0}^{\infty}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}Δ^{p}f[n]+⋯.\]</p><p>A finite-difference expansion truncated order <span>$k$</span> is defined by <span>$k+1$</span> <em>finite-difference expansion coefficients</em>, defined by the vector <span>$α = [α_{0},⋯\ α_{k}]$</span>. It takes some bookkeeping to rewrite the expansion in the form of a <em>weighted sum</em> over the <span>$k+1$</span> <em>function values</em> <span>$f[n],⋯\ f[n-k]$</span> (note the <em>backward order</em>). Substituting the finite difference expression for <span>$Δ^k$</span>, we obtain</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}\sum_{j=0}^{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}α_{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j],\]</p><p>where the weighted summation is defined by the <em>weights</em></p><p class="math-container">\[F_{j}^{k}=\sum_{p=j}^{k}α_{p}c_{p-j}^{p}
=\sum_{p=j}^{k}(-1)^{p+j}\binom{p}{j}α_{p},\]</p><p>with <span>$j=0,⋯\ k$</span>. In inner product form the expansion becomes</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$F^k  ≡ [F_0^k,⋯\ F_k^k]$</span>.</p><p>Function:</p><p><a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(coeff, Δ(k))</code></a> <span>$→ F^k ≡ [F_0^k,⋯\ F_k^k]$</span></p><p><strong>Backward difference notation</strong></p><p>In terms of backward differences the expansion takes the form</p><p class="math-container">\[\sum_{p=0}^{\infty}β_{p}∇^{p}f[n]=\sum_{p=0}^{k}β_{p}∇^{p}f[n]+⋯.\]</p><p>In this case the <span>$k+1$</span> <em>finite-difference expansion coefficients</em> are defined by the vector <span>$β = [β_{0},⋯\ β_{k}]$</span>. We rewrite the expansion in the form of a <em>weighted sum</em> over the <span>$k+1$</span> <em>function values</em> <span>$f[n],\ ⋯,f[n-k]$</span> (note the <em>backward order</em>). Substituting the finite difference expression for <span>$∇^k$</span>, we obtain</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{p=0}^{k}β_{p}\sum_{j=0}^{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}β_{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}B_{j}^{k}f[n-j],\]</p><p>where the weighted summation is defined as the <em>weights</em> <span>$B_{j}^{k}=\sum_{p=j}^{k}β_{p}c_{j}^{p}$</span>, with <span>$j=0,⋯\ k$</span>. By a change of dummy index we turn to <em>forward order</em></p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^{k}B_{k-j}^kf[n-k+j]
=\bar{B}^k \cdot f[n-k:n].\]</p><p>Note that the <em>weights vector</em> <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> contains the weights in backward order.</p><p>In general <span>$β ≠ α$</span> and there is <em>no simple symmetry relation</em> between <span>$B^k$</span> and <span>$F^k$</span>. In the special case <span>$β = α$</span> we find <span>$\bar{B}^k = \reverse(F^k)$</span>.</p><p>Functions:</p><p><a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(coeff, ∇(k))</code></a> <span>$→ \bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Δ-Tuple{Int64}" href="#CamiXon.Δ-Tuple{Int64}"><code>CamiXon.Δ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Δ(k::Int)</code></pre><p>Collection of finite difference weight vectors for use in <span>$k^{th}$</span>-order finite difference expansions in <em>forward-difference</em> notation</p><p><strong>Example:</strong></p><pre><code class="language-none">k=4
Δ(k) == (true, k, [[1], [-1, 1], [1, -2, 1], [-1, 3, -3, 1], [1, -4, 6, -4, 1]])
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL94-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.∇-Tuple{Int64}" href="#CamiXon.∇-Tuple{Int64}"><code>CamiXon.∇</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇(k::Int)</code></pre><p>Collection of finite difference weight vectors for use in <span>$k^{th}$</span>-order finite difference expansions in <em>backward-difference</em> notation</p><p><strong>Example:</strong></p><pre><code class="language-none">k=4
∇(k) == (false, k, [[1], [-1, 1], [1, -2, 1], [-1, 3, -3, 1], [1, -4, 6, -4, 1]])
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL110-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_expansion_weights-Tuple{Any, Any}" href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>CamiXon.fdiff_expansion_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_expansion_weights(coeffs, fdiff)</code></pre><p>Expansion weights corresponding to the expansion coefficients <code>coeffs</code> for the finite difference expansion <code>fdiff</code>.</p><p><strong>Forward difference notation</strong> (<code>fdiff = Δ(k)</code>)</p><p>Weight vector <span>$F^k ≡ [F_k^k,⋯\ F_0^k]$</span> corresponding to the expansion coefficients <span>$α ≡ [α_0^k,⋯\ α_k^k]$</span> of the <span>$k^{th}$</span>-order <em>forward-difference</em> expansion,</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$f[n],⋯\ f[n+k]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order.</p><p><a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(coeff, Δ(k))</code></a> <span>$→ F^k ≡ [F_0^k,⋯\ F_k^k]$</span></p><p><strong>Backward difference notation</strong> (<code>fdiff = ∇(k)</code>)</p><p>Weight vector <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> corresponding to the expansion coefficients <span>$β ≡ [β_0,⋯\ β_k]$</span> of the <span>$k^{th}$</span>-order <em>backward-difference</em> expansion,</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^{k}B_{k-j}^kf[n-k+j]
=\bar{B}^k \cdot f[n-k:n].\]</p><p>where <span>$f[n-k],⋯\ f[n]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order.</p><p><a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(coeff, ∇(k))</code></a> <span>$→ \bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span></p><p><strong>Example:</strong></p><pre><code class="language-none">k=5
α = β = UnitRange(0,k)
Fk = fdiff_expansion_weights(α,Δ(k)); println(&quot;Fk = $(Fk)&quot;)
bBk = fdiff_expansion_weights(β,∇(k)); println(&quot;bBk = $(bBk)&quot;)
  Fk = [15, -55, 85, -69, 29, -5]
  bBk = [-5, 29, -69, 85, -55, 15]

bBk == reverse(Fk)
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL126-L178">source</a></section></article><h3 id="Lagrangian-interpolation"><a class="docs-heading-anchor" href="#Lagrangian-interpolation">Lagrangian interpolation</a><a id="Lagrangian-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-interpolation" title="Permalink"></a></h3><p>This section build on the finite difference expansion methods</p><p><strong>Forward difference notation</strong></p><p>Starting from the relation</p><p class="math-container">\[f[n]=(1+Δ)f[n+1],\]</p><p>we obtain by formal inversion of the operator</p><p class="math-container">\[f[n+1] = (1 + Δ)^{-1} f[n] \equiv \sum_{p=0}^{\infty}(-1)^p Δ^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 + Δ)^{-2} f[n] \equiv \sum_{p=0}^{\infty}(-1)^p pΔ^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>which can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n-x] = (1 + Δ)^{-x} f[n] \equiv \sum_{p=0}^{\infty} α_p(x) Δ^p f[n],\]</p><p>where <span>$α_p(x) ≡ (-1)^p(x)_p/p!$</span> is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient for lagrangian lagrangian_extrapolation</em> over the interval <span>$-k ≤x ≤0\ \ (n \le n-x \le n+k)$</span>,</p><p class="math-container">\[(x)_{p}=\begin{cases}
1 &amp; p=0\\
x(x+1)(x+2)\cdots(x+p-1) &amp; p&gt;0
\end{cases}\]</p><p>being the Pochhammer symbol (<a href="#CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>pochhammer</code></a>). Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[f[n-x] =\sum_{p=0}^{k}α_p(x)Δ^pf[n]
=\sum_{j=0}^{k}F_j^k(x)f[n+j]
=F^k(x) \cdot f[n:n+k],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[F_j^k(x)= \sum_{p=j}^{k} (-1)^k α_p(x) c_j^p
=\sum_{p=j}^{k} (-1)^j \binom{p}{j}(x)_p/p!\]</p><p>are the <em>lagrangian interpolation weights</em> corresponding to the point <span>$f[n-x]$</span>.</p><p>Functions:</p><p><a href="#CamiXon.fdiff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>fdiff_expansion_coeffs_lagrange(k,x)</code></a> <span>$→ α(x) ≡ [α_0(x),⋯\ α_k(x)]$</span></p><p><a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(α(x), Δ(k))</code></a> <span>$→ F^k(x) ≡ [F^k_0(x),⋯\ F^k_k]$</span></p><p><strong>Backward difference notation</strong></p><p>Starting from the relation</p><p class="math-container">\[f[n]=(1-∇)f[n+1].\]</p><p>we obtain by formal inversion of the operator</p><p class="math-container">\[f[n+1] = (1 - ∇)^{-1} f[n] \equiv \sum_{p=0}^{\infty}∇^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 - ∇)^{-2} f[n] \equiv \sum_{p=0}^{\infty}p∇^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>which can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n+x] = (1 - ∇)^{-x} f[n] \equiv \sum_{p=0}^{\infty} β_p(x) ∇^p f[n],\]</p><p>where <span>$β_p(x) ≡ (-1)^p(x)_p/p!$</span> is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient for lagrangian lagrangian_extrapolation</em> over the interval <span>$-k ≤x ≤0\ \ (n-k \le n+x \le n)$</span>, with</p><p class="math-container">\[(x)_{p}=\begin{cases}
1 &amp; p=0\\
x(x+1)(x+2)\cdots(x+p-1) &amp; p&gt;0
\end{cases}\]</p><p>being the Pochhammer symbol (<a href="#CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>pochhammer</code></a>). Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[f[n+x] =\sum_{p=0}^{k}β_p(x)∇^pf[n]
= \sum_{j=0}^{k}B^k_j(x)f[n-j]
= B^k(x) ⋅ f[n:-1:n-k],\]</p><p>where the <span>$k+1$</span> <em>weights</em> <span>$B^k_j(x)= \sum_{p=j}^{k} β_p(x) c_j^p$</span> are the corresponding <em>lagrangian interpolation weights</em>.  After changing dummy index to obtain forward order the expansion becomes</p><p class="math-container">\[f[n+x]
=\sum_{p=0}^{k}β_p(x)∇^pf[n]
= \sum_{j=0}^{k}B_{k-j}^k(x)f[n-k+j]
=\bar{B}^k(x) ⋅ f[n-k:n].\]</p><p>Function:</p><p><a href="#CamiXon.fdiff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>fdiff_expansion_coeffs_lagrange(k,x)</code></a> <span>$→ β ≡ [β_0(x),⋯\ β_k(x)]$</span></p><p><a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(β(x), ∇(k))</code></a> <span>$→ \bar{B}^k(x) ≡ [B_k^k(x),⋯\ B_0^k(x)]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real" href="#CamiXon.fdiff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.fdiff_expansion_coeffs_lagrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_expansion_coeffs_lagrange(k::Int, x::T) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector <span>$α^k=[(x)_0,⋯\ (x)_k]$</span> defining the <span>$k^{th}$</span>-order lagrangian interpolation of the tabulated analytic function <span>$f(n+x)$</span> at offset position <span>$x$</span> with respect to position <span>$n$</span>,</p><p class="math-container">\[f[n+x] = (1 - ∇)^{-x} f[n] \equiv \sum_{p=0}^{\infty}(x)_{p}∇^p f[n],\]</p><p>where <span>$(x)_{p}$</span> is the <a href="#CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>pochhammer</code></a> symbol. Interpolation corresponds to the interval <span>$-k\le\ x\le 0$</span>; extrapolation to <span>$x\ge 0$</span>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">k = 5; x = 1
l = fdiff_expansion_coeffs_lagrange(k,x); println(l)
 [1, 1, 1, 1, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL235-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.summation_range-NTuple{4, Int64}" href="#CamiXon.summation_range-NTuple{4, Int64}"><code>CamiXon.summation_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">summation_range(n, i, k, m)</code></pre><p>Summation range for interpolation position <span>$0\le i/m \le 1$</span> used in <span>$k^{th}$</span>-order lagrangian interpolation of the anaytic function <span>$f$</span> tabulated in forward order on a uniform grid of <span>$n$</span> points, <span>$f[1],⋯\ f[n]$</span>; <span>$m$</span> is the multiplier defining the interpolation grid size.</p><p><strong>Examples:</strong></p><pre><code class="language-none">n = 7; k = 2; m = 1
o = [summation_range(n,i,k,m) for i=0:(n-1)*m]; println(o)
 UnitRange{Int64}[1:3, 2:4, 3:5, 4:6, 5:7, 5:7, 5:7]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL265-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_function_sequences" href="#CamiXon.fdiff_function_sequences"><code>CamiXon.fdiff_function_sequences</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fdiff_function_sequences(f, k::Int, m=1)</code></pre><p>Finite-difference summation sequences of function values given in forward order for use in <span>$k^{th}$</span>-order lagrangian interpolation of the anaytic function <span>$f$</span> tabulated in forward order on a uniform grid of <span>$n$</span> points, <span>$f[1],⋯\ f[n]$</span>; <span>$m$</span> is the multiplier defining the interpolation grid size. Each sequence consists of <span>$k⋅m+1$</span> function values.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = [0,1,2,3,4,5,6]
k = 2
o = fdiff_function_sequences(f, k); println(o)
 [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL293-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.lagrange_interpolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}" href="#CamiXon.lagrange_interpolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_interpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lagrangian_interpolation(f::Vector{Float64},
                                  domain::ClosedInterval{Float64}; k=1, m=1)</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>interpolation</em> of the analytic function <span>$f$</span> tabulated in forward order on a uniform grid of <span>$n$</span> points, <span>$f[1],\ ⋯, \ f[n]$</span>; <span>$m$</span> is the multiplier defining the interpolation grid size.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = [0.0,1,2,3,4,5,6,7]
domain = 0.0..1.0
(X,Y) = lagrangian_interpolation(f, domain; k=2, m=2); println((X,Y))
 (0.0:0.07142857142857142:1.0, [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,
                                                  4.5, 5.0, 5.5, 6.0, 6.5, 7.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL322-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.lagrange_extrapolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}" href="#CamiXon.lagrange_extrapolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_extrapolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lagrangian_extrapolation(f::Vector{Float64},
                             domain::ClosedInterval{Float64}; k=1, e=1, m=1)</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>extrapolation</em> up to position <span>$n+e$</span> of the analytic function <span>$f$</span> tabulated in forward order at <span>$n$</span> points, <span>$f[1],⋯\ f[n]$</span>; <span>$m$</span> is the multiplier defining the interpolation grid size.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = [0.0,1,2,3,4,5,6,7]
domain = 0.0..1.0
(X,Y) = lagrangian_extrapolation(f, domain; k=2, e=1, m=2); println((X,Y))
  (0.0:0.07142857142857142:1.0, [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0,
                                                  4.5, 5.0, 5.5, 6.0, 6.5, 7.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL358-L374">source</a></section></article><h3 id="Lagrangian-differentiation"><a class="docs-heading-anchor" href="#Lagrangian-differentiation">Lagrangian differentiation</a><a id="Lagrangian-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-differentiation" title="Permalink"></a></h3><p>To derive the <em>lagrangian differentiation</em> formulas we formally differentiate</p><p class="math-container">\[f[n+x] = (1 - ∇)^{-x} f[n]\]</p><p>with respect to <span>$x$</span>.</p><p class="math-container">\[\frac{df}{dx}[n+x]=-ln(1-∇)\ (1-∇)^{-x}f[n]=\sum_{q=1}^{k}\tfrac{1}{q}∇^{q}\sum_{p=0}^{k}l_{p}(x)∇^{p}f[n]+⋯.\]</p><p>Rewriting the r.h.s. as a single summation in powers of <span>$∇$</span> for given values of <span>$n$</span> and <span>$x$</span> we obtain an expression of the form</p><p class="math-container">\[\frac{df}{dx}[n+x]=\sum_{p=1}^{k}l_{p}^{\prime}(x)∇^{p}f[n]+⋯,\]</p><p>where <span>$l_{p}^{\prime}(x)$</span> represents the <em>finite-difference expansion coefficients</em> for <em>lagrangian differentiation</em> at position <span>$n+x$</span>. These coefficients are determined numerically by polynomial multiplication after adding the <span>$p=0$</span> term, <span>$l_{0}^{\prime}(x)\equiv 0$</span>, to the first sum. The corresponding coefficient vector is generated in <em>forward order</em> by the function <a href="#CamiXon.fdiff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>fdiff_expansion_coeffs_differentiation(k,x)</code></a>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[\frac{df}{dx}[n+x]=\sum_{p=0}^{k}l_{p}^{\prime}(x)∇^{p}f[n]=\sum_{j=0}^{k}s_{j}^{k}(x)f[n-j],\]</p><p>where the <span>$s_{j}^{k}(x)=\sum_{p=j}^{k}l_{p}^{\prime}(x)c_{j}^{p}$</span> are the <span>$k^{th}$</span>-order lagrangian differentiation weights.  After changing dummy index to reverse the summation from backward to forward order the expansion becomes</p><p class="math-container">\[\frac{df}{dx}[n+x]]= \sum_{j=0}^{k}s^k_x[j]f[n-k+j],\]</p><p>where <span>$s^k_x[j] ≡ s^k_{k-j}(x)$</span>. The weights vector <span>$s^k_x$</span> is generated by the function <a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(coeffs,∇(k))</code></a>.</p><p>Functions:</p><p><code>β</code> = <a href="#CamiXon.fdiff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>fdiff_expansion_coeffs_differentiation(k,x)</code></a> <span>$→ [l_0^{\prime}(x),⋯\ l_k^{\prime}(x)]$</span></p><p><code>Lagrange differentiation weights</code> = <a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(coeffs,∇(k))</code></a> <span>$s^k_x[j] ≡ → [s_k^k(x),⋯\ s_0^k(x)]$</span></p><p><code>Lagrange differentiation weights</code> = <a href="#CamiXon.create_lagrange_differentiation_weights-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>create_lagrange_differentiation_weights(k,x)</code></a> <span>$s^k_x[j] ≡ → [s_k^k(x),⋯\ s_0^k(x)]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real" href="#CamiXon.fdiff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.fdiff_expansion_coeffs_differentiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_expansion_coeffs_differentiation(k::Int, x::T) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector <span>$[l_0^{\prime}(x),\ ⋯, \ l_p^{\prime}(x)]$</span> defining <span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the tabulated analytic function <span>$f(n+x)$</span> at position <span>$x$</span>,</p><p class="math-container">\[\frac{df}{dx}[n+x]=\sum_{p=0}^{k}l_{p}^{\prime}(x)∇^{p}f[n]\]</p><p><strong>Example:</strong></p><pre><code class="language-none">k = 2; x = 0
o = fdiff_expansion_coeffs_differentiation(k,x); println(o)
 [0.0, 1.0, -1.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL397-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.create_lagrange_differentiation_weights-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real" href="#CamiXon.create_lagrange_differentiation_weights-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.create_lagrange_differentiation_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_lagrange_differentiation_weights(k::Int, x::T) where T&lt;:Real</code></pre><p><span>$k^{th}$</span>-order Lagrange differentiation weights vector, <span>$s^k(x) ≡ [s_k^k(x),⋯\ s_0^k(x)]$</span>, where <span>$x$</span> is the position relative point <span>$n$</span>.</p><p class="math-container">\[\frac{df}{dx}[n+x]= \sum_{j=0}^{k}s_{k-j}^k(x)f[n-k+j],\]</p><p>where <span>$s^k_x[j] ≡ s_{k-j}(x)^k$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">k = 3
x = 0
ldw = create_lagrange_differentiation_weights(k,x); println(ldw)
  Rational{Int64}[-11//6, 3//1, -3//2, 1//3]

 sum(ldw)
   0//1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL429-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}" href="#CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiXon.create_lagrange_differentiation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_lagrange_differentiation_matrix(k::Int)</code></pre><p>Lagrange differentiation matrix, <span>$m[i,j]=s_{k-j}^k(i)$</span>, for <span>$k^{th}$</span>-order lagrangian differentiation,</p><p class="math-container">\[\frac{dy}{dx}[i]= \sum_{j=0}^{k}m[i,j]y[j],\]</p><p><strong>Example:</strong></p><pre><code class="language-none">k = 3
create_lagrange_differentiation_matrix(k)
 4×4 Matrix{Rational{Int64}}:
  -11//6   3//1  -3//2   1//3
   -1//3  -1//2   1//1  -1//6
    1//6  -1//1   1//2   1//3
   -1//3   3//2  -3//1  11//6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL462-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.lagrange_differentiation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}" href="#CamiXon.lagrange_differentiation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_differentiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lagrange_differentiation(f::Vector{Float64},
                    domain::ClosedInterval{Float64}; k=1, m=1)</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the analytic function <span>$f$</span>, tabulated in forward order on a uniform grid of <span>$n$</span> points, <span>$f[1],\ ⋯, \ f[n]$</span>; <span>$m$</span> is the multiplier for intermediate positions (for <span>$m=1$</span> <em>without</em> intermediate points).</p><p><strong>Example:</strong></p><pre><code class="language-none">f = [0.0,1,4,9,16,25] # f = x^2
domain = 0.0..5.0
X,Y = lagrange_differentiation(f, domain; k=2, m = 1)
  (0.0:1.0:5.0, [0.0, 2.0, 4.0, 6.0, 8.0, 10.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL498-L513">source</a></section></article><h3 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.trapezoidal_weights-Tuple{Int64}" href="#CamiXon.trapezoidal_weights-Tuple{Int64}"><code>CamiXon.trapezoidal_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trapezoidal_weights(k::Int [; rationalize=false [, devisor=false]])</code></pre><p>Weight coefficient vector <span>$a=[a_1,⋯\ a_k]$</span> of trapeziodal rule optimized for functions of polynomial form,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}),\]</p><p>where <span>$k$</span> is <em>odd</em>. The rule is exact for polynonials of degree <span>$d=0,\ 1, ⋯,\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.</p><p><strong>Example::</strong></p><pre><code class="language-none">[trapezoidal_weights(k; rationalize=true, devisor=true) for k=1:2:9]
5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
  (1, 2, [1])
  (3, 24, [9, 28, 23])
  (5, 1440, [475, 1902, 1104, 1586, 1413])
  (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])
  (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922,
                                                     5095890, 7783754, 7200319])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL537-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.trapezoidal_integration-Tuple{Any, Any, Any}" href="#CamiXon.trapezoidal_integration-Tuple{Any, Any, Any}"><code>CamiXon.trapezoidal_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trapezoidal_integration(f, domain, weights)</code></pre><p>Integral of the tabulated function <span>$f=[f_0,⋯\ f_n]$</span> over the <code>domain</code> <span>$a..b$</span> using the optimized trapezoidal rule with endpoint correction by the weightsvector <code>weights</code>,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}).\]</p><p>The rule is exact for polynonials of degree <span>$d=0,\ 1,⋯\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Examples::</strong></p><pre><code class="language-none">p = 3
c = [1 for i=0:p]
pol = ImmutablePolynomial(c,:z)
Ipol = integrate(pol)
n = 10

domain = 0.0..5.0
x = collect(range(domain, n))
f = pol.(x .-2.5)

w3 = trapezoidal_weights(3)
trapezoidal_integration(f, domain, w3)
 15.416666666666673

Ipol(2.5)-Ipol(-2.5)
 15.41666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_differences.jl#LL601-L632">source</a></section></article><h3 id="Adams-Method"><a class="docs-heading-anchor" href="#Adams-Method">Adams Method</a><a id="Adams-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Method" title="Permalink"></a></h3><h4 id="Adams-Bashford-expansion"><a class="docs-heading-anchor" href="#Adams-Bashford-expansion">Adams-Bashford expansion</a><a id="Adams-Bashford-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Bashford-expansion" title="Permalink"></a></h4><p>The <em>Adams-Bashford integration step</em> is given by the expansion</p><p class="math-container">\[y[n+1]-y[n] = -\frac{h ∇}{(1-∇)ln(1-∇)}f[n+1]=h (\sum_{p=0}^{\infty}B_p∇^p)f[n+1].\]</p><p>A closed expression for the <em>Adams-Bashford expansion coefficients</em>, <span>$B_k$</span>, is not available. As we already have a finite-difference expansion for the operator <span>$(1-∇)^{-1}$</span>,</p><p class="math-container">\[\frac{1}{1-∇}\equiv\sum_{p=0}^{\infty}∇^p,\]</p><p>we ask for the expansion of</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}=(1-\frac{1}{2}∇-\frac{1}{24}∇^2-\frac{1}{12}∇^3+⋯)f[n+1]= (\sum_{p=0}^{\infty}b_p∇^p)f[n+1].\]</p><p>This is known as the <em>Adams-Moulton expansion</em>. Its coefficients are calculated numerically by the function <code>fdiff_expansion_adams_moulton_coeffs(k)</code>. The <em>Adams-Bashford expansion</em> is obtained as the polynomial product of the two expansions,</p><p class="math-container">\[(\sum_{p=0}^{\infty}B_p∇^p)f[n+1]=(\sum_{p=0}^{\infty}∇^p)(\sum_{p=0}^{\infty}b_p∇^p)f[n+1]=\ ( 1 + \frac{1}{2}∇ + \frac{5}{12}∇^2 + ⋯)f[n+1].\]</p><p>The coefficients <span>$B_p$</span> are calculated numerically with the function <code>fdiff_expansion_adams_bashford_coeffs(k)</code>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}B_p∇^pf[n]=\sum_{p=0}^{k}B_p\sum_{j=0}^{p} c_j^if[n-j]= \sum_{j=0}^{k}A_j^k(x)f[n-j]= \sum_{j=0}^{k}A_{k-j}^k(x)f[n-k+j],\]</p><p>where the <span>$A_j^k(x)= \sum_{p=j}^{k} B_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Bashford integration weights</em>.</p><p>Function:</p><p><code>β</code> = <a href="#CamiXon.fdiff_expansion_coeffs_adams_bashford-Tuple{Int64}"><code>fdiff_expansion_coeffs_adams_bashford(k)</code></a> <span>$→ [B_k^k(x),⋯\ B_0^k(x)]$</span></p><p><code>adams_bashford_integration_weights</code> = <a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(β,∇(k))</code></a> <span>$→ [A_k^k(x),⋯\ A_0^k(x)]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_expansion_coeffs_adams_bashford-Tuple{Int64}" href="#CamiXon.fdiff_expansion_coeffs_adams_bashford-Tuple{Int64}"><code>CamiXon.fdiff_expansion_coeffs_adams_bashford</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_expansion_coeffs_adams_bashford(k [; T=Int])</code></pre><p><span>$(k+1)$</span>-point Adams-Bashford expansion coefficients <span>$B_p$</span>.</p><p class="math-container">\[-\frac{∇}{(1-∇)ln(1-∇)}=\sum_{p=0}^{\infty}B_p∇^p=1+\ \frac{1}{2}∇+\ \frac{5}{12}∇^2+\ ⋯.\]</p><p>The weights are stored in <em>forward</em> order: <span>$[B_0^k,⋯\ B_k^k]$</span> - order of use in summation.</p><p><strong>Examples:</strong></p><pre><code class="language-none">k = 5
o = fdiff_expansion_coeffs_adams_bashford(k); println(o)
 Rational{Int64}[1//1, 1//2, 5//12, 3//8, 251//720, 95//288]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_difference_adams.jl#LL95-L111">source</a></section></article><h3 id="Adams-Moulton-expansion"><a class="docs-heading-anchor" href="#Adams-Moulton-expansion">Adams-Moulton expansion</a><a id="Adams-Moulton-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-expansion" title="Permalink"></a></h3><p>The <em>Adams-Moulton integration</em> step is given by the expansion</p><p class="math-container">\[y[n+1]-y[n] = -\frac{∇}{ln(1-∇)}f[n+1] = ( 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯)f[n+1].\]</p><p>For the evaluation of the integration step we limit the summation to <span>$k+1$</span> terms (order <span>$k$</span>),</p><p class="math-container">\[y[n+1]-y[n]= (\sum_{p=0}^{k}b_p∇^p)f[n+1]+⋯.\]</p><p>where <span>$b_0,⋯\ b_k$</span> are the <em>Adams-Moulton expansion coefficients</em>, rational numbers generated numerically by the function <a href="#CamiXon.fdiff_expansion_coeffs_adams_moulton-Tuple{Int64}"><code>fdiff_expansion_coeffs_adams_moulton(k)</code></a>. Extracting the greatest common denominator, <span>$1/D$</span>, the step becomes</p><p class="math-container">\[y[n+1]-y[n]= \frac{1}{D}(\sum_{p=0}^{k}b_p^{\prime}∇^p)f[n+1]+⋯,\]</p><p>where <span>$b_0^{\prime},⋯\ b_k^{\prime}$</span> are integers and <span>$b_p=b_p^{\prime}/D$</span>. In practice the expansion is restricted to <span>$k&lt;18$</span> (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to <span>$k = 10$</span>). Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}b_p∇^pf[n]=\sum_{p=0}^{k}b_p\sum_{j=0}^{p} c_j^if[n-j]= \sum_{j=0}^{k}a_j^k(x)f[n-j]= \sum_{j=0}^{k}a_{k-j}^k(x)f[n-k+j],\]</p><p>where the <span>$a_j^k(x)= \sum_{p=j}^{k} b_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Moulton integration weights</em>. These are generated in <em>backward order</em> by the function <a href="@ref"><code>bwd_diff_expansion_weights(coeffs,∇)</code></a>, with <code>∇ =</code><a href="#CamiXon.fdiff_weights_array-Tuple{Int64}"><code>fdiff_weights_array(k)</code></a>.</p><p>Functions:</p><p><code>β</code> = <a href="#CamiXon.fdiff_expansion_coeffs_adams_moulton-Tuple{Int64}"><code>fdiff_expansion_coeffs_adams_moulton(k)</code></a> <span>$→ [b_0,⋯\ b_k]$</span></p><p><code>adams_moulton_weights</code> = <a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>fdiff_expansion_weights(β,∇(k))</code></a><span>$→ [a_k^k,⋯\ a_0^k]$</span></p><p><code>adams_moulton_weights</code> = <a href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>create_adams_moulton_weights(k)</code></a><span>$→ [a_k^k,⋯\ a_0^k]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_expansion_coeffs_adams_moulton-Tuple{Int64}" href="#CamiXon.fdiff_expansion_coeffs_adams_moulton-Tuple{Int64}"><code>CamiXon.fdiff_expansion_coeffs_adams_moulton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_expansion_coeffs_adams_moulton(k [; T=Int])</code></pre><p><span>$k^{th}$</span>-order Adams-Moulton expansion coefficients,</p><p class="math-container">\[-\frac{∇}{ln(1-∇)} = \sum_{p=0}^{\infty}b_p∇^p= 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯.\]</p><p>The weights are stored in <em>forward</em> order: <span>$[b_0^k,⋯\ b_k^k]$</span> - order of use in summation.</p><p><strong>Examples:</strong></p><pre><code class="language-none">k = 5
b = fdiff_expansion_coeffs_adams_moulton(k::Int); println(b)
 Rational[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]

D = denominator(gcd(b)); println(D)
 1440

o = convert(Vector{Int},(b .* D)); println(o)
 [1440, -720, -120, -60, -38, -27]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_difference_adams.jl#LL3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.create_adams_moulton_weights-Tuple{Int64}" href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>CamiXon.create_adams_moulton_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])</code></pre><p><span>$k^{th}$</span>-order Adams-Moulton weights vector,</p><p class="math-container">\[y[n+1] = y[n] + \frac{1}{D}\sum_{j=0}^{k}a^k[j]f[n+1-k+j]\]</p><p>The weights are stored in the vector <span>$a^k \equiv[a_k^k/D,⋯\ a_0^k/D]$</span> under the convention <span>$a^k[j] \equiv a_{k-j}^k/D$</span>, where <span>$a_j^k$</span> are the Adams-Moulton weight coefficients and <span>$D$</span> the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational,  with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="language-none">[create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:8]
8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
 (1, 2, [1, 1])
 (2, 12, [-1, 8, 5])
 (3, 24, [1, -5, 19, 9])
 (4, 720, [-19, 106, -264, 646, 251])
 (5, 1440, [27, -173, 482, -798, 1427, 475])
 (6, 60480, [-863, 6312, -20211, 37504, -46461, 65112, 19087])
 (7, 120960, [1375, -11351, 41499, -88547, 123133, -121797, 139849, 36799])
 (8, 3628800, [-33953, 312874, -1291214, 3146338, -5033120, 5595358, -4604594, 4467094, 1070017])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/finite_difference_adams.jl#LL49-L74">source</a></section></article><h2 id="Strings"><a class="docs-heading-anchor" href="#Strings">Strings</a><a id="Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Strings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.sup-Tuple{T} where T&lt;:Real" href="#CamiXon.sup-Tuple{T} where T&lt;:Real"><code>CamiXon.sup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sup(i::T) where T&lt;:Real</code></pre><p>Superscript notation for integers and rational numbers</p><p><strong>Examples:</strong></p><pre><code class="language-none">sup(3) * &#39;P&#39;
 &quot;³P&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/strings.jl#LL58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.sub-Tuple{T} where T&lt;:Real" href="#CamiXon.sub-Tuple{T} where T&lt;:Real"><code>CamiXon.sub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sub(i::T) where T&lt;:Real</code></pre><p>Subscript notation for integers, rational numbers and a <em>subset</em> of lowercase characters (&#39;a&#39;,&#39;e&#39;,&#39;h&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;x&#39;)</p><p><strong>Examples:</strong></p><pre><code class="language-none">&#39;D&#39; * sub(5//2)
 &quot;D₅⸝₂&quot;

&quot;m&quot; * sub(&quot;e&quot;)
 &quot;mₑ&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/strings.jl#LL81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.frac-Tuple{Rational{Int64}}" href="#CamiXon.frac-Tuple{Rational{Int64}}"><code>CamiXon.frac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">frac(i)</code></pre><p>Fraction notation for rational numbers</p><p><strong>Examples:</strong></p><pre><code class="language-none">frac(-5//2)
 &quot;-⁵/₂&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/strings.jl#LL118-L127">source</a></section></article><h2 id="Dicts"><a class="docs-heading-anchor" href="#Dicts">Dicts</a><a id="Dicts-1"></a><a class="docs-heading-anchor-permalink" href="#Dicts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.dictElements" href="#CamiXon.dictElements"><code>CamiXon.dictElements</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">dictElements</code></pre><p>Source:  Standard atomic weights of the elements 2021 (IUPAC Technical Report)</p><p><strong>Example:</strong></p><pre><code class="language-none">dictElements
  Dict{Int64, Tuple{String, String, Any}} with 102 entries:
    5  =&gt; (&quot;boron&quot;, &quot;B&quot;, 10.81)
    56 =&gt; (&quot;barium&quot;, &quot;Ba&quot;, 137.33)
    35 =&gt; (&quot;bromine&quot;, &quot;Br&quot;, 79.904)
    55 =&gt; (&quot;caesium&quot;, &quot;Cs&quot;, 132.91)
    60 =&gt; (&quot;neodymium&quot;, &quot;Nd&quot;, 144.24)
    30 =&gt; (&quot;zinc&quot;, &quot;Zn&quot;, 65.38)
    32 =&gt; (&quot;germanium&quot;, &quot;Ge&quot;, 72.63)
    6  =&gt; (&quot;carbon&quot;, &quot;C&quot;, 12.011)
    ⋮  =&gt; ⋮</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/dicts.jl#LL4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.dictIsotopes" href="#CamiXon.dictIsotopes"><code>CamiXon.dictIsotopes</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">dictIsotopes</code></pre><p>Sources: AME2020, LINDC(NDS)-0794 and INDC(NDS)-0794</p><p><strong>Example:</strong></p><pre><code class="language-none">dictIsotopes
  Dict{Tuple{Int64, Int64}, Tuple{String, Real, Real, Real, Int64, Real, Real, Any, Any, Vararg{Nothing}}} with 340 entries:
    (71, 175) =&gt; (&quot;Lu&quot;, 5.37, 1.74941e8, 3.5, 1, 1.0e100, 2.2257, 3.49, 97.401)
    (40, 92)  =&gt; (&quot;Zr&quot;, 4.3057, 9.1905e7, 0, 1, 1.0e100, 0, 0, 17.15)
    (48, 111) =&gt; (&quot;Cd&quot;, 4.5845, 1.10904e8, 0.5, 1, 1.0e100, -0.594, 0, 12.795)
    (72, 176) =&gt; (&quot;Hf&quot;, 5.3286, 1.75941e8, 0, 1, 1.0e100, 0, 0, 5.26)
    (30, 68)  =&gt; (&quot;Zn&quot;, 3.9658, 6.79248e7, 0, 1, 1.0e100, 0, 0, 18.45)
    (76, 184) =&gt; (&quot;Os&quot;, 5.3823, 1.83952e8, 0, 1, 5.6e13, 0, 0, 0.02)
    (54, 129) =&gt; (&quot;Xe&quot;, 4.7775, 1.28905e8, 0.5, 1, 1.0e100, -0.777961, 0, 26.401)
    ⋮         =&gt; ⋮</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/35c873fe7228f6a54d75c453a5eed728418c5862/src/dicts.jl#LL133-L150">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CamiXon.dictElements"><code>CamiXon.dictElements</code></a></li><li><a href="#CamiXon.dictIsotopes"><code>CamiXon.dictIsotopes</code></a></li><li><a href="#CamiXon.Adams"><code>CamiXon.Adams</code></a></li><li><a href="#CamiXon.Atom"><code>CamiXon.Atom</code></a></li><li><a href="#CamiXon.Codata"><code>CamiXon.Codata</code></a></li><li><a href="#CamiXon.Def"><code>CamiXon.Def</code></a></li><li><a href="#CamiXon.Element"><code>CamiXon.Element</code></a></li><li><a href="#CamiXon.FITS_HDU"><code>CamiXon.FITS_HDU</code></a></li><li><a href="#CamiXon.FITS_data"><code>CamiXon.FITS_data</code></a></li><li><a href="#CamiXon.FITS_header"><code>CamiXon.FITS_header</code></a></li><li><a href="#CamiXon.FITS_name"><code>CamiXon.FITS_name</code></a></li><li><a href="#CamiXon.FITS_table"><code>CamiXon.FITS_table</code></a></li><li><a href="#CamiXon.FORTRAN_format"><code>CamiXon.FORTRAN_format</code></a></li><li><a href="#CamiXon.Grid"><code>CamiXon.Grid</code></a></li><li><a href="#CamiXon.Isotope"><code>CamiXon.Isotope</code></a></li><li><a href="#CamiXon.NamedValue"><code>CamiXon.NamedValue</code></a></li><li><a href="#CamiXon.Orbit"><code>CamiXon.Orbit</code></a></li><li><a href="#CamiXon.Pos"><code>CamiXon.Pos</code></a></li><li><a href="#CamiXon.SpinOrbit"><code>CamiXon.SpinOrbit</code></a></li><li><a href="#CamiXon.Term"><code>CamiXon.Term</code></a></li><li><a href="#CamiXon.Value"><code>CamiXon.Value</code></a></li><li><a href="#CamiXon.VectorRational"><code>CamiXon.VectorRational</code></a></li><li><a href="#CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.INSCH</code></a></li><li><a href="#CamiXon.OUTSCH-Union{Tuple{T}, Tuple{Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T&lt;:Real"><code>CamiXon.OUTSCH</code></a></li><li><a href="#CamiXon.OUTSCH_WKB-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.OUTSCH_WKB</code></a></li><li><a href="#CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_inward</code></a></li><li><a href="#CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_normalized</code></a></li><li><a href="#CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_outward</code></a></li><li><a href="#CamiXon.autoGrid-Tuple{Atom, Orbit, Codata, Type}"><code>CamiXon.autoGrid</code></a></li><li><a href="#CamiXon.autoNtot-Tuple{Orbit}"><code>CamiXon.autoNtot</code></a></li><li><a href="#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real"><code>CamiXon.autoPrecision</code></a></li><li><a href="#CamiXon.autoRmax-Tuple{Atom, Orbit}"><code>CamiXon.autoRmax</code></a></li><li><a href="#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.autoSteps</code></a></li><li><a href="#CamiXon.bernoulli_numbers-Tuple{Int64}"><code>CamiXon.bernoulli_numbers</code></a></li><li><a href="#CamiXon.bohrformula-Tuple{Int64, Int64}"><code>CamiXon.bohrformula</code></a></li><li><a href="#CamiXon.calibrationReport-Tuple{Any, Any, Codata}"><code>CamiXon.calibrationReport</code></a></li><li><a href="#CamiXon.canonical_partitions"><code>CamiXon.canonical_partitions</code></a></li><li><a href="#CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.castAdams</code></a></li><li><a href="#CamiXon.castAtom-Tuple{}"><code>CamiXon.castAtom</code></a></li><li><a href="#CamiXon.castCodata-Tuple{Int64}"><code>CamiXon.castCodata</code></a></li><li><a href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit}} where T&lt;:Real"><code>CamiXon.castDef</code></a></li><li><a href="#CamiXon.castElement-Tuple{}"><code>CamiXon.castElement</code></a></li><li><a href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>CamiXon.castGrid</code></a></li><li><a href="#CamiXon.castIsotope-Tuple{}"><code>CamiXon.castIsotope</code></a></li><li><a href="#CamiXon.castNamedValue-Tuple{Value}"><code>CamiXon.castNamedValue</code></a></li><li><a href="#CamiXon.castOrbit-Tuple{}"><code>CamiXon.castOrbit</code></a></li><li><a href="#CamiXon.cast_FITS_name-Tuple{String}"><code>CamiXon.cast_FITS_name</code></a></li><li><a href="#CamiXon.cast_FORTRAN_datatype-Tuple{String}"><code>CamiXon.cast_FORTRAN_datatype</code></a></li><li><a href="#CamiXon.cast_FORTRAN_format-Tuple{String}"><code>CamiXon.cast_FORTRAN_format</code></a></li><li><a href="#CamiXon.convertUnit-Tuple{Any, Codata}"><code>CamiXon.convertUnit</code></a></li><li><a href="#CamiXon.createSpinOrbit-Tuple{Orbit}"><code>CamiXon.createSpinOrbit</code></a></li><li><a href="#CamiXon.createTerm-Tuple{Int64}"><code>CamiXon.createTerm</code></a></li><li><a href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>CamiXon.create_adams_moulton_weights</code></a></li><li><a href="#CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiXon.create_lagrange_differentiation_matrix</code></a></li><li><a href="#CamiXon.create_lagrange_differentiation_weights-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.create_lagrange_differentiation_weights</code></a></li><li><a href="#CamiXon.edges"><code>CamiXon.edges</code></a></li><li><a href="#CamiXon.faulhaber_polynom-Tuple{Int64}"><code>CamiXon.faulhaber_polynom</code></a></li><li><a href="#CamiXon.faulhaber_summation-Tuple{Int64, Int64}"><code>CamiXon.faulhaber_summation</code></a></li><li><a href="#CamiXon.fdiff_expansion_coeffs_adams_bashford-Tuple{Int64}"><code>CamiXon.fdiff_expansion_coeffs_adams_bashford</code></a></li><li><a href="#CamiXon.fdiff_expansion_coeffs_adams_moulton-Tuple{Int64}"><code>CamiXon.fdiff_expansion_coeffs_adams_moulton</code></a></li><li><a href="#CamiXon.fdiff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.fdiff_expansion_coeffs_differentiation</code></a></li><li><a href="#CamiXon.fdiff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.fdiff_expansion_coeffs_lagrange</code></a></li><li><a href="#CamiXon.fdiff_expansion_weights-Tuple{Any, Any}"><code>CamiXon.fdiff_expansion_weights</code></a></li><li><a href="#CamiXon.fdiff_function_sequences"><code>CamiXon.fdiff_function_sequences</code></a></li><li><a href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>CamiXon.fdiff_weight</code></a></li><li><a href="#CamiXon.fdiff_weights-Tuple{Int64}"><code>CamiXon.fdiff_weights</code></a></li><li><a href="#CamiXon.fdiff_weights_array-Tuple{Int64}"><code>CamiXon.fdiff_weights_array</code></a></li><li><a href="#CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_all</code></a></li><li><a href="#CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_first</code></a></li><li><a href="#CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_last</code></a></li><li><a href="#CamiXon.fits_add_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_add_key</code></a></li><li><a href="#CamiXon.fits_combine-Tuple{String, String}"><code>CamiXon.fits_combine</code></a></li><li><a href="#CamiXon.fits_copy"><code>CamiXon.fits_copy</code></a></li><li><a href="#CamiXon.fits_create"><code>CamiXon.fits_create</code></a></li><li><a href="#CamiXon.fits_delete_key-Tuple{String, Int64, String}"><code>CamiXon.fits_delete_key</code></a></li><li><a href="#CamiXon.fits_edit_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_edit_key</code></a></li><li><a href="#CamiXon.fits_extend"><code>CamiXon.fits_extend</code></a></li><li><a href="#CamiXon.fits_info-Tuple{FITS_HDU}"><code>CamiXon.fits_info</code></a></li><li><a href="#CamiXon.fits_read-Tuple{String}"><code>CamiXon.fits_read</code></a></li><li><a href="#CamiXon.fits_rename_key-Tuple{String, Int64, String, String}"><code>CamiXon.fits_rename_key</code></a></li><li><a href="#CamiXon.frac-Tuple{Rational{Int64}}"><code>CamiXon.frac</code></a></li><li><a href="#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Na</code></a></li><li><a href="#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nb</code></a></li><li><a href="#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nlctp</code></a></li><li><a href="#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.get_Nmin</code></a></li><li><a href="#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nuctp</code></a></li><li><a href="#CamiXon.get_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_nodes</code></a></li><li><a href="#CamiXon.grid_lagrange_derivative-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_lagrange_derivative</code></a></li><li><a href="#CamiXon.grid_trapezoidal_integral-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_trapezoidal_integral</code></a></li><li><a href="#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.gridfunction</code></a></li><li><a href="#CamiXon.gridname-Tuple{Int64}"><code>CamiXon.gridname</code></a></li><li><a href="#CamiXon.harmonic_number-Tuple{Int64}"><code>CamiXon.harmonic_number</code></a></li><li><a href="#CamiXon.harmonic_number-Tuple{Int64, Int64}"><code>CamiXon.harmonic_number</code></a></li><li><a href="#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.initE</code></a></li><li><a href="#CamiXon.integer_partitions"><code>CamiXon.integer_partitions</code></a></li><li><a href="#CamiXon.lagrange_differentiation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_differentiation</code></a></li><li><a href="#CamiXon.lagrange_extrapolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_extrapolation</code></a></li><li><a href="#CamiXon.lagrange_interpolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_interpolation</code></a></li><li><a href="#CamiXon.listCodata-Tuple{Codata}"><code>CamiXon.listCodata</code></a></li><li><a href="#CamiXon.log10_characteristic_power-Tuple{Any}"><code>CamiXon.log10_characteristic_power</code></a></li><li><a href="#CamiXon.log10_mantissa-Tuple{Any}"><code>CamiXon.log10_mantissa</code></a></li><li><a href="#CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matG</code></a></li><li><a href="#CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T&lt;:Real"><code>CamiXon.matMinv</code></a></li><li><a href="#CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matσ</code></a></li><li><a href="#CamiXon.normalize_VectorRational-Tuple{Vector{Rational{Int64}}}"><code>CamiXon.normalize_VectorRational</code></a></li><li><a href="#CamiXon.parse_FITS_TABLE-Tuple{FITS_HDU}"><code>CamiXon.parse_FITS_TABLE</code></a></li><li><a href="#CamiXon.pascal_next-Tuple{Vector{Int64}}"><code>CamiXon.pascal_next</code></a></li><li><a href="#CamiXon.pascal_triangle-Tuple{Int64}"><code>CamiXon.pascal_triangle</code></a></li><li><a href="#CamiXon.permutations_unique_count-Tuple{Vector{Vector{Int64}}, Int64}"><code>CamiXon.permutations_unique_count</code></a></li><li><a href="#CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>CamiXon.pochhammer</code></a></li><li><a href="#CamiXon.polynom_derivative-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivative</code></a></li><li><a href="#CamiXon.polynom_derivatives-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivatives</code></a></li><li><a href="#CamiXon.polynom_derivatives_all-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivatives_all</code></a></li><li><a href="#CamiXon.polynom_power-Tuple{Vector{&lt;:Number}, Int64}"><code>CamiXon.polynom_power</code></a></li><li><a href="#CamiXon.polynom_powers-Tuple{Vector{&lt;:Number}, Int64}"><code>CamiXon.polynom_powers</code></a></li><li><a href="#CamiXon.polynom_primitive-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_primitive</code></a></li><li><a href="#CamiXon.polynom_product-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>CamiXon.polynom_product</code></a></li><li><a href="#CamiXon.polynom_product_expansion-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:Number"><code>CamiXon.polynom_product_expansion</code></a></li><li><a href="#CamiXon.polynomial-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Number"><code>CamiXon.polynomial</code></a></li><li><a href="#CamiXon.select125-Tuple{Any}"><code>CamiXon.select125</code></a></li><li><a href="#CamiXon.solve_adams_moulton-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T&lt;:Real"><code>CamiXon.solve_adams_moulton</code></a></li><li><a href="#CamiXon.step125-Tuple{Real}"><code>CamiXon.step125</code></a></li><li><a href="#CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepcenters</code></a></li><li><a href="#CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepedges</code></a></li><li><a href="#CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.steps</code></a></li><li><a href="#CamiXon.strValue-Tuple{Value}"><code>CamiXon.strValue</code></a></li><li><a href="#CamiXon.sub-Tuple{T} where T&lt;:Real"><code>CamiXon.sub</code></a></li><li><a href="#CamiXon.summation_range-NTuple{4, Int64}"><code>CamiXon.summation_range</code></a></li><li><a href="#CamiXon.sup-Tuple{T} where T&lt;:Real"><code>CamiXon.sup</code></a></li><li><a href="#CamiXon.texp-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Real"><code>CamiXon.texp</code></a></li><li><a href="#CamiXon.trapezoidal_integration-Tuple{Any, Any, Any}"><code>CamiXon.trapezoidal_integration</code></a></li><li><a href="#CamiXon.trapezoidal_weights-Tuple{Int64}"><code>CamiXon.trapezoidal_weights</code></a></li><li><a href="#CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.updateAdams!</code></a></li><li><a href="#CamiXon.Δ-Tuple{Int64}"><code>CamiXon.Δ</code></a></li><li><a href="#CamiXon.∇-Tuple{Int64}"><code>CamiXon.∇</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 21 May 2022 19:38">Saturday 21 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
