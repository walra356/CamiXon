<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CamiXon.jl</title><link rel="canonical" href="https://walra356.github.io/CamiXon.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CamiXon.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Table-of-contents"><span>Table of contents</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Codata"><span>Codata</span></a></li><li><a class="tocitem" href="#Atomic-properties"><span>Atomic properties</span></a></li><li><a class="tocitem" href="#Angular-momentum"><span>Angular momentum</span></a></li><li><a class="tocitem" href="#Grid"><span>Grid</span></a></li><li><a class="tocitem" href="#Adams-Moulton-integration"><span>Adams-Moulton integration</span></a></li><li><a class="tocitem" href="#Coulomb-integrals"><span>Coulomb integrals</span></a></li><li><a class="tocitem" href="#FITS"><span>FITS</span></a></li><li><a class="tocitem" href="#FORTRAN"><span>FORTRAN</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Search-and-conversion-tools"><span>Search and conversion tools</span></a></li><li><a class="tocitem" href="#Mathematics"><span>Mathematics</span></a></li><li><a class="tocitem" href="#Finite-difference-methods"><span>Finite-difference methods</span></a></li><li><a class="tocitem" href="#Strings"><span>Strings</span></a></li><li><a class="tocitem" href="#Dicts"><span>Dicts</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/walra356/CamiXon.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CamiXon.jl"><a class="docs-heading-anchor" href="#CamiXon.jl">CamiXon.jl</a><a id="CamiXon.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CamiXon.jl" title="Permalink"></a></h1><p>A package for image analysis of backscattered light</p><hr/><h2 id="Table-of-contents"><a class="docs-heading-anchor" href="#Table-of-contents">Table of contents</a><a id="Table-of-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-contents" title="Permalink"></a></h2><ul><li><a href="#CamiXon.jl">CamiXon.jl</a></li><ul><li><a href="#Table-of-contents">Table of contents</a></li><li><a href="#Introduction">Introduction</a></li><li><a href="#Codata">Codata</a></li><li><a href="#Atomic-properties">Atomic properties</a></li><li><a href="#Angular-momentum">Angular momentum</a></li><li><a href="#Grid">Grid</a></li><li><a href="#Adams-Moulton-integration">Adams-Moulton integration</a></li><li><a href="#Coulomb-integrals">Coulomb integrals</a></li><li><a href="#FITS">FITS</a></li><li><a href="#FORTRAN">FORTRAN</a></li><li><a href="#Plotting">Plotting</a></li><li><a href="#Search-and-conversion-tools">Search and conversion tools</a></li><li><a href="#Mathematics">Mathematics</a></li><li><a href="#Finite-difference-methods">Finite-difference methods</a></li><li><a href="#Strings">Strings</a></li><li><a href="#Dicts">Dicts</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>CamiXon is a package for the numerical solution of the radial Schrödinger equation allowing for screening.</p><p>In this package the solution is obtained for a single electron, acting as a <em>spectator</em> in the central field of the atomic nucleus screened by &#39;the other&#39; electrons (the <em>screening</em> electrons).</p><p>The starting point is the 1D Schrödinger equation,</p><p class="math-container">\[\tilde{χ}_{l}^{′′}+2[Z_{\mathrm{eff}}(ρ)/ρ-l(l+1)/2ρ^{2}+ε_{l}]\tilde{χ}_{l}=0,\]</p><p>where <span>$\tilde{\chi}_{l}(\rho)=\rho\tilde{R}_{l}(\rho)$</span> is the reduced radial wavefunction and <span>$ε_{l}=-κ _{l}^{2}$</span> is the corresponding binding energy in Hartree atomic units (a.u.). As compared to the hydrogenic case, the atomic number <span>$Z$</span> has been replaced by <span>$Z_{\mathrm{eff}}(ρ)$</span>, the <em>effective nuclear charge</em> at radial distance <span>$ρ$</span> from the atomic center (in a.u.). In other words, the energy of the electron in the Coulomb field of the nucleus is replaced by an effective, central field potential of the form</p><p class="math-container">\[U_{\mathrm{CF}}(ρ)=-Z_{\mathrm{eff}}(ρ)/ρ=-Z/ρ+U_{\mathrm{scr}}(ρ),\]</p><p>consisting of the bare Coulomb contribution, <span>$-Z/ρ$</span>, and the screening field <span>$U_{\mathrm{scr}}(ρ)$</span>, subject to the boundary conditions <span>$U_{\mathrm{scr}}(0)=Z$</span> and <span>$\mathrm{lim}_{ρ→\infty}U_{\mathrm{scr}}(ρ)=Z_{c}/ρ$</span>. Here <span>$Z_{c}$</span> is the Rydberg charge; i.e. the effective nuclear charge for a spectator electron in the far field <span>$(ρ→\infty)$</span>. Within these assumptions we can optimize <span>$U_{\mathrm{scr}}(ρ)$</span>, while preserving the bare Coulomb field close to the nucleus as well as the Rydberg potential in the far field. The price we pay is that the radial Schrödinger equation has to be solved numerically by radial integration. Our strategy is to use both <em>inward</em> and <em>outward</em> integration and match the two branches by <em>equating the two solutions</em> for the <em>wavefunction</em>, <span>$χ(ρ)$</span>, and its <em>derivative</em>, <span>$χ^′(ρ)$</span>, at a point near the classical turning point of the radial motion of the electron. The basics of the solution can be found in the book <em>Atomic Structure Theory</em> by Walter R. Johnson.</p><h4 id="Illustration:-the-hydrogen-3d-orbital"><a class="docs-heading-anchor" href="#Illustration:-the-hydrogen-3d-orbital">Illustration: the hydrogen 3d orbital</a><a id="Illustration:-the-hydrogen-3d-orbital-1"></a><a class="docs-heading-anchor-permalink" href="#Illustration:-the-hydrogen-3d-orbital" title="Permalink"></a></h4><p>Shown below are the reduced radial wavefunction <span>$(χ)$</span> and its derivative <span>$(χ^′)$</span> in the near field (left), the far field (right), and in the region near the classical turning point (center).</p><p><img src="assets/H1_3d.png" alt="Image"/></p><h2 id="Codata"><a class="docs-heading-anchor" href="#Codata">Codata</a><a id="Codata-1"></a><a class="docs-heading-anchor-permalink" href="#Codata" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Codata" href="#CamiXon.Codata"><code>CamiXon.Codata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Codata</code></pre><p>Object to hold the natural constants from CODATA. It is best created with the function <a href="#CamiXon.castCodata-Tuple{Int64}"><code>castCodata</code></a></p><p>The fields are:</p><ul><li><code>.∆νCs</code>: Cs hyperfine transition frequency (<code>::Value</code>)</li><li><code>.c</code>: speed of light in vacuum (<code>::Value</code>)</li><li><code>.h</code>: Planck constant (<code>::Value</code>)</li><li><code>.ħ</code>: Planck constant - reduced (<code>::Value</code>)</li><li><code>.e</code>: elementary charge (<code>::Value</code>)</li><li><code>.kB</code>: Boltzmann constant (<code>::Value</code>)</li><li><code>.NA</code>: Avogadro constant (<code>::Value</code>)</li><li><code>.Kcd</code>: Luminous efficacy (<code>::Value</code>)</li><li><code>.me</code>: electron rest mass (<code>::Value</code>)</li><li><code>.R∞</code>: Rydberg constant (<code>::Value</code>)</li><li><code>.Ry</code>: Rydberg frequency (<code>::Value</code>)</li><li><code>.Eh</code>: Hartree a.u. (<code>::Value</code>)</li><li><code>.α</code>: fine-structure constant (<code>::Value</code>)</li><li><code>.μ0</code>: magnetic permitivity of vacuum (<code>::Value</code>)</li><li><code>.ε0</code>: electric permitivity of vacuum (<code>::Value</code>)</li><li><code>.KJ</code>: Josephson constant (<code>::Value</code>)</li><li><code>.RK</code>: Von Klitzing constant (<code>::Value</code>)</li><li><code>.R</code>: Molar gas constant (<code>::Value</code>)</li><li><code>.matE</code>: unit conversion matrix (Matrix{Float64})</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
codata.μ0
  Value(1.2566370621250601e-6, &quot;N A⁻²&quot;)

codata.μ0.val
  1.2566370621250601e-6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/codata.jl#LL107-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Value" href="#CamiXon.Value"><code>CamiXon.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Value(val::Real, unit::String)</code></pre><p>Object to hold a real numerical value together with a unit specifier.</p><p>The fields are:</p><ul><li><code>.val</code>: numerical value (<code>::Real</code>)</li><li><code>.unit</code>: unit specifier (<code>::String</code>)</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">f = Value(1,&quot;Hz&quot;)
  Value(1, &quot;Hz&quot;)

f.val
  1

f.unit
  &quot;Hz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/codata.jl#LL3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.strValue-Tuple{Value}" href="#CamiXon.strValue-Tuple{Value}"><code>CamiXon.strValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">strValue(f::Value)</code></pre><p>String expression for a <a href="#CamiXon.Value"><code>Value</code></a> object in <code>:compact =&gt; true</code> representation</p><p><strong>Example:</strong></p><pre><code class="language-none">f = Value(1,&quot;Hz&quot;)
strValue(f)
  &quot;1 Hz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/codata.jl#LL32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.NamedValue" href="#CamiXon.NamedValue"><code>CamiXon.NamedValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NamedValue(val::Value, name::String, comment::String)</code></pre><p>Object to hold a <a href="#CamiXon.Value"><code>Value</code></a> together with its <code>symbolic name</code> and a <code>short</code> description</p><p>The fields are:</p><ul><li><code>.val</code>: Value  (<code>::Value</code>)</li><li><code>.name</code>: symbolic name (<code>::String</code>)</li><li><code>.comment</code>: description (<code>::String</code>)</li></ul><p>Named Value object The object <code>NamedValue</code> is best created using <a href="#CamiXon.castNamedValue-Tuple{Value}"><code>castNamedValue</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = Value(1,&quot;Hz&quot;)
  Value(1, &quot;Hz&quot;, &quot;frequency&quot;)

f.name
  &quot;frequency&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/codata.jl#LL55-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castNamedValue-Tuple{Value}" href="#CamiXon.castNamedValue-Tuple{Value}"><code>CamiXon.castNamedValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castNamedValue(val::Value; name=&quot; &quot;, comment=&quot; &quot;)</code></pre><p>Method to create a <a href="#CamiXon.NamedValue"><code>NamedValue</code></a> object</p><p><strong>Example</strong></p><pre><code class="language-none">v = Value(1.602176634e-19, &quot;C&quot;)
nv = castNamedValue(v; name=&quot;e&quot;)
nv.name * &quot; = &quot; * strValue2(nv.val)
  &quot;e = 1.60218e-19 C&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/codata.jl#LL87-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castCodata-Tuple{Int64}" href="#CamiXon.castCodata-Tuple{Int64}"><code>CamiXon.castCodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castCodata(year::Int)</code></pre><p>Method to create the <a href="#CamiXon.Codata"><code>Codata</code></a> object</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
strValue.([codata.∆νCs,codata.c,codata.h])
 3-element Vector{String}:
  &quot;9192631770 Hz&quot;
  &quot;299792458 m s⁻¹&quot;
  &quot;6.62607e-34 J Hz⁻¹&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/codata.jl#LL170-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.listCodata-Tuple{Codata}" href="#CamiXon.listCodata-Tuple{Codata}"><code>CamiXon.listCodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">listCodata(codata::Codata)</code></pre><p>Method to list the fields of <a href="#CamiXon.Codata"><code>Codata</code></a> by their symbolic name</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
listCodata(codata::Codata)
  ∆νCs = 9192631770 Hz
  c = 299792458 m s⁻¹
  h = 6.62607e-34 J Hz⁻¹
  ħ = 1.05457e-34 J s
  e = 1.60218e-19 C
  kB = 1.38065e-23 J K⁻¹
  NA = 6.02214e23 mol⁻¹
  Kcd = 683 lm W⁻¹
  mₑ = 9.10938e-31 Kg
  R∞ = 1.09737e7 m⁻¹
  Ry = 3.28984e15 Hz
  Eₕ = 4.35974e-18 Hartree a.u.
  α = 0.00729735
  μ₀ = 1.25664e-6 N A⁻²
  ε₀ = 8.85419e-12 F m⁻¹
  KJ = 4.83598e14 Hz V⁻¹
  RK = 25812.8 Ω
  R = 8.31446 J mol⁻¹K⁻¹</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/codata.jl#LL241-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.convertUnit-Tuple{Any, Any}" href="#CamiXon.convertUnit-Tuple{Any, Any}"><code>CamiXon.convertUnit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convertUnit(val, codata; unitIn=&quot;Hartree&quot;, unitOut=&quot;xHz&quot;)</code></pre><p>Unit conversion between μHz,⋯ EHz, Hartree, Rydberg, Joule, and eV</p><p>default input: Hartree</p><p>default output: xHz ∈ {μHz, mHz, Hz, kHz, MHz, GHz, THz, PHz, EHz}</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
convertUnit(1, codata; unitIn=&quot;Hz&quot;, unitOut=&quot;Joule&quot;)
  6.62607015e-34

convertUnit(1, codata; unitIn=&quot;Hartree&quot;, unitOut=&quot;Hz&quot;)
  Value(6.57968392050182e15, &quot;Hz&quot;)

f = convertUnit(1, codata) # default input (Hartree) and output (xHz)
strf = strValue(f)
  &quot;6.57968 PHz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/codata.jl#LL303-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.calibrationReport-Tuple{Any, Any, Codata}" href="#CamiXon.calibrationReport-Tuple{Any, Any, Codata}"><code>CamiXon.calibrationReport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calibrationReport(E, Ecal, codata::Codata; unitIn=&quot;Hartree&quot;)</code></pre><p>Comparison of energy E with calibration value Ecal</p><p>default input: Hartree</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
calibrationReport(1.1, 1.0, codata; unitIn=&quot;Hartree&quot;)
  calibration report (Float64):
  Ecal = 1.0 Hartree
  E = 1.1 Hartree
  absolute accuracy: ΔE = 0.1 Hartree (657.968 THz)
  relative accuracy: ΔE/E = 0.0909091</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/codata.jl#LL366-L382">source</a></section></article><h2 id="Atomic-properties"><a class="docs-heading-anchor" href="#Atomic-properties">Atomic properties</a><a id="Atomic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Element" href="#CamiXon.Element"><code>CamiXon.Element</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Element(name, symbol, weight)</code></pre><p>Type with fields:</p><ul><li><code>.name</code>:  name of element (<code>::String</code>)</li><li><code>.symbol</code>:  symbol of element  (<code>::String</code>)</li><li><code>.weight</code>:  relative atomic mass - atomic weight (<code>::Float64</code>)</li></ul><p>The type <code>Element</code> is best created with the function <a href="#CamiXon.castElement-Tuple{}"><code>castElement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/element.jl#LL3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Isotope" href="#CamiXon.Isotope"><code>CamiXon.Isotope</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Isotope(symbol, name, Z, A, N, R, M, I, π, T½, mdm, eqm, ra)</code></pre><p>Type with fields:</p><ul><li><code>.symbol</code>: symbol (<code>::String</code>)</li><li><code>.name</code>: name (<code>::String</code>)</li><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.N</code>:  neutron number (<code>::Int</code>)</li><li><code>.R</code>:  rms charge radius in Fermi (<code>::Float64</code>)</li><li><code>.M</code>:  <em>atomic</em> mass in amu (<code>::Float64</code>)</li><li><code>.I</code>:  nuclear spin in units of ħ  (<code>::Rational{Int}</code>)</li><li><code>.π</code>:  parity of nuclear state (<code>::Int</code>)</li><li><code>.T½</code>:  lifetime in years (<code>::Float64</code>)</li><li><code>.mdm</code>: nuclear magnetic dipole moment (<code>::Float64</code>)</li><li><code>.eqm</code>: nuclear electric quadrupole moment (<code>::Float64</code>)</li><li><code>.ra</code>:  relative abundance in % (<code>::Float64</code>)</li></ul><p>The type <code>Isotope</code> is best created with the function <a href="#CamiXon.castIsotope-Tuple{}"><code>castIsotope</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/isotope.jl#LL3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Atom" href="#CamiXon.Atom"><code>CamiXon.Atom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Atom(Z, A, Q, Zc, element, isotope)</code></pre><p>Type with fields:</p><ul><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.Q</code>:  ionic charge in a.u. (<code>::Int</code>)</li><li><code>.Zc</code>:  Rydberg charge in a.u. (<code>::Int</code>)</li><li><code>.element</code>:  (<code>::Element</code>)</li><li><code>.isotope</code>:  (<code>::Isotope</code>)</li></ul><p>The type <code>Atom</code> is best created with the function <a href="#CamiXon.castAtom-Tuple{}"><code>castAtom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Orbit" href="#CamiXon.Orbit"><code>CamiXon.Orbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Orbit(name, n, n′, ℓ)</code></pre><p>Type for specification of <em>atomic orbitals</em> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li></ul><p>The type <code>Orbit</code> is best created with the function <code>castOrbit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL226-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.SpinOrbit" href="#CamiXon.SpinOrbit"><code>CamiXon.SpinOrbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpinOrbit</code></pre><p>Type for specification of <em>atomic spinorbitals</em> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.ms</code>:  spin magnetic quantum number</li></ul><p>The type <code>SpinOrbit</code> is best created with the function <code>createSpinOrbit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL292-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Term" href="#CamiXon.Term"><code>CamiXon.Term</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Term(name::String, n::Int, ℓ::Int, S::Real, L::Int, J::Real)</code></pre><p>Type for specification of atomic <em>fine-structure Terms</em> with fields:</p><ul><li><code>name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.S</code>:  total electron spin in units of ħ</li><li><code>.L</code>:  total orbital angular momentum in units of ħ</li><li><code>.J</code>:  total electronic angular momentum in units of ħ</li></ul><p>The type <code>Term</code> is best created with the function <code>createTerm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL345-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.listElement-Tuple{Int64}" href="#CamiXon.listElement-Tuple{Int64}"><code>CamiXon.listElement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">listElement(Z::Int[; fmt=Object])
listElement(elt::String[; fmt=Object])</code></pre><p>Properties of element with atomic number <code>Z</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Info</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">listElement(&quot;H&quot;) == listElement(1)
  true

listElement(1; fmt=Info)
  Element: hydrogen
    symbol: H
    atomic number: Z = 1
    atomic weight (relative atomic mass): 1.008</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/element.jl#LL60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.listElements-Tuple{Int64, Int64}" href="#CamiXon.listElements-Tuple{Int64, Int64}"><code>CamiXon.listElements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">listElements(Z1::Int, Z2::Int[; fmt=Object])</code></pre><p>Properties of elements with atomic number in the range <code>Z1:Z2</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Info</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">listElements(1,3) == listElements(1:3)
  true

listElements(1:3; fmt=Info)
  Element: hydrogen
    symbol: H
    atomic number: Z = 1
    atomic weight (relative atomic mass): 1.008
  Element: helium
    symbol: He
    atomic number: Z = 2
    atomic weight (relative atomic mass): 4.0026
  Element: lithium
    symbol: Li
    atomic number: Z = 3
    atomic weight (relative atomic mass): 6.94</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/element.jl#LL101-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castElement-Tuple{}" href="#CamiXon.castElement-Tuple{}"><code>CamiXon.castElement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castElement(;Z=1, msg=true)
castElement(elt::String; msg=true)</code></pre><p>Create Atom with fields</p><ul><li><code>.name</code>:  name of element</li><li><code>.symbol</code>:  symbol of element</li><li><code>.weight</code>:  relative atomic mass (atomic weight)</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">castElement(&quot;Rb&quot;; msg=false) == castElement(Z=37, msg=false)
  true

element = castElement(;Z=1, msg=true)
element
  Element created: H, hydrogen, Z=1, weight=1.008

  Element(&quot;hydrogen&quot;, &quot;H&quot;, 1.008)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/element.jl#LL146-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.listIsotope-Tuple{Int64, Int64}" href="#CamiXon.listIsotope-Tuple{Int64, Int64}"><code>CamiXon.listIsotope</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">listIsotope(Z::Int, A::Int; fmt=Object)</code></pre><p>Properties of isotopes with atomic number <code>Z</code> and atomic mass number <code>A</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Latex</code>, <code>Info</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">listIsotope(1,3; fmt=Info)
  Isotope: tritium-3
    symbol: ³T
    element: tritium
    atomic number: Z = 1
    atomic mass number: A = 3
    neutron number: N = 2
    rms nuclear charge radius: R = 1.7591 fm
    atomic mass: M = 3.016049281 amu
    nuclear spin: I = 1/2 ħ
    parity of nuclear state: π = even
    nuclear magnetic dipole moment: μI = 2.97896246μN
    nuclear electric quadrupole moment: Q = 0.0barn
    relative abundance: RA = trace
    lifetime: 12.33 years</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/isotope.jl#LL133-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.listIsotopes-Tuple{Int64, Int64}" href="#CamiXon.listIsotopes-Tuple{Int64, Int64}"><code>CamiXon.listIsotopes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">listIsotopes(Z1::Int, Z2::Int; fmt=Object)</code></pre><p>All isotopes with atomic number from <code>Z1</code> to <code>Z2</code>.</p><p>Output options: <code>Object</code> (default), <code>String</code>, <code>Latex</code>, <code>Info</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">listIsotopes(1,3) == listIsotopes(1:3)
 true

listIsotopes(1:1; fmt=Info)
 3-element Vector{Any}:
  Isotope(&quot;¹H&quot;, &quot;hydrogen&quot;, 1, 1, 0, 0.8783, 1.007825032, 1//2, 1, 1.0e100, 2.792847351, 0.0, 99.9855)
  Isotope(&quot;²D&quot;, &quot;deuterium&quot;, 1, 2, 1, 2.1421, 2.014101778, 1, 1, 1.0e100, 0.857438231, 0.0028578, 0.0145)
  Isotope(&quot;³T&quot;, &quot;tritium&quot;, 1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/isotope.jl#LL169-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.latexIsotopeTable-Tuple{Int64, Int64}" href="#CamiXon.latexIsotopeTable-Tuple{Int64, Int64}"><code>CamiXon.latexIsotopeTable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">latexIsotopeTable(Z1::Int, Z2::Int; continuation=false)</code></pre><p>Isotope table for all isotopes with atomic number from <code>Z1</code> to <code>Z2</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">latexIsotopeTable(1:3)
  \setlength{\tabcolsep}{3pt}
  \renewcommand{\arraystretch}{1.2}
  \begin{table}[H]
    \centering
    \caption{\label{table:Isotopes-a-1}Properties of selected atomic isotopes. The Table is based on three databases: (a) AME2020 (atomic mass evaluation); (b) IAEA-INDC(NDS)-794 (magnetic dipole moments); (c) IAEA-INDC(NDS)-833 (electric quadrupole moments).}
    \begin{tabular}{r|lr|rrrr|r|r|r|r}
      \multicolumn{12}{r}\vspace{-18pt}\\
      \hline
      \hline
      $Z$ &amp; element &amp; symbol &amp; $A$ &amp; $N$ &amp; radius &amp; atomic mass &amp; $I\,^\pi$ &amp; $\mu_I $ &amp; $Q$ &amp; $RA$\\&amp;  &amp;  &amp;  &amp;  &amp; (fm) &amp; $(m_u)$ &amp; $(\hbar)\ \ $ &amp; $(\mu_N)$ &amp; (barn) &amp; (\%)\\\hline
      1 &amp; hydrogen &amp; $^{1}$H &amp; 1\, &amp; 0 &amp; 0.8783 &amp; 1.007825032 &amp; 1/2$^+$ &amp; 2.792847351 &amp; 0.0 &amp; 99.9855 \\
        &amp;  &amp; $^{2}$H &amp; 2\, &amp; 1 &amp; 2.1421 &amp; 2.014101778 &amp; 1//1$^+$ &amp; 0.857438231 &amp; 0.0028578 &amp; 0.0145 \\
        &amp;  &amp; $^{3}$H &amp; 3$*\!\!$ &amp; 2 &amp; 1.7591 &amp; 3.016049281 &amp; 1/2$^+$ &amp; 2.97896246 &amp; 0.0 &amp; trace \\
      \hline
      2 &amp; helium &amp; $^{3}$He &amp; 3\, &amp; 1 &amp; 1.9661 &amp; 3.016029322 &amp; 1/2$^+$ &amp; -2.12762531 &amp; 0.0 &amp; 0.0002 \\
        &amp;  &amp; $^{4}$He &amp; 4\, &amp; 2 &amp; 1.6755 &amp; 4.002603254 &amp; 0//1$^+$ &amp; 0.0 &amp; 0.0 &amp; 99.9998\% \\
      \hline
      3 &amp; lithium &amp; $^{6}$Li &amp; 6\, &amp; 3 &amp; 2.589 &amp; 6.015122887 &amp; 1//1$^+$ &amp; 0.822043 &amp; -0.000806 &amp; 4.85 \\
        &amp;  &amp; $^{7}$Li &amp; 7\, &amp; 4 &amp; 2.444 &amp; 7.016003434 &amp; 3/2$^-$ &amp; 3.256407 &amp; -0.04 &amp; 95.15 \\
      \hline
      \multicolumn{12}{l}{*radioactive }\\
    \end{tabular}
  \end{table}</code></pre><p>The typeset result is shown in the figule below.</p><p><img src="assets/latexIsotopeTable.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/latex.jl#LL72-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castIsotope-Tuple{}" href="#CamiXon.castIsotope-Tuple{}"><code>CamiXon.castIsotope</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castIsotope(;Z=1, A=1, msg=true)
castIsotope(elt::String; A=1, msg=true)</code></pre><p>Create Isotope with fields</p><ul><li><code>.symbol</code>: symbol (<code>::String</code>)</li><li><code>.name</code>: symbol (<code>::String</code>)</li><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.N</code>:  neutron number (<code>::Int</code>)</li><li><code>.R</code>:  rms charge radius in Fermi (<code>::Float64</code>)</li><li><code>.M</code>:  atomic mass in amu (<code>::Float64</code>)</li><li><code>.I</code>:  nuclear spin in units of ħ (<code>::Rational{Int}</code>)</li><li><code>.π</code>:  parity of nuclear state (<code>::Int</code>)</li><li><code>.ra</code>:  relative abundance in % (<code>::Float64</code>)</li><li><code>.mdm</code>: nuclear magnetic dipole moment (<code>::Float64</code>)</li><li><code>.eqm</code>: nuclear electric quadrupole moment (<code>::Float64</code>)</li><li><code>.T½</code>:  lifetime in years (<code>::Float64</code>)</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">castIsotope(&quot;Rb&quot;; A=87, msg=false) == castIsotope(Z=37, A=87, msg=false)
  true

isotope = castIsotope(Z=1, A=3, msg=false)
  Isotope(&quot;³T&quot;, &quot;tritium&quot;, 1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0, nothing)

isotope.T½
  12.33

castIsotope(Z=1,A=3);
  Isotope created: tritium-3
      symbol: ³T
      element: tritium
      atomic number: Z = 1
      atomic mass number: A = 3
      neutron number: N = 2
      rms nuclear charge radius: R = 1.7591 fm
      atomic mass: M = 3.016049281 amu
      nuclear spin: I = 1/2 ħ
      parity of nuclear state: π = ⁺
      nuclear magnetic dipole moment: μI = 2.97896246μN
      nuclear electric quadrupole moment: Q = 0.0barn
      relative abundance: RA = trace
      lifetime: 12.33 years</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/isotope.jl#LL221-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.listAtom-Tuple{Int64, Int64, Int64}" href="#CamiXon.listAtom-Tuple{Int64, Int64, Int64}"><code>CamiXon.listAtom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">listAtom(Z::Int, A::Int, Q::Int[; fmt=Object])</code></pre><p>Properties of atom with atomic number <code>Z</code>, atomic mass number <code>A</code>, ionic charge <code>Q</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Info</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">listAtom(&quot;H&quot;, 3, 0) == listAtom(1, 3, 0)
  true

listAtom(1, 3, 0; fmt=Info)
Element: hydrogen
    symbol: H
    element: tritium
    atomic number: Z = 1
    atomic weight (relative atomic mass): 1.008</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL76-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.listAtoms-Tuple{Int64, Int64, Int64}" href="#CamiXon.listAtoms-Tuple{Int64, Int64, Int64}"><code>CamiXon.listAtoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">listAtoms(Z1::Int, Z2::Int, Q::Int[; fmt=Object])</code></pre><p>Properties of atoms with atomic number in the range <code>Z1:Z3</code> and ionic charge <code>Q</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Info</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">listAtoms(1,3,0) == listAtoms(1:3,0)
  true

listAtoms(1:1, 0; fmt=Info);
  Atom: hydrogen, neutral atom
    symbol: ¹H
    atomic charge: Z = 1
    Rydberg charge: Zc = 1
  Atom: deuterium, neutral atom
    symbol: ²D
    atomic charge: Z = 1
    Rydberg charge: Zc = 1
  Atom: tritium, neutral atom
    symbol: ³T
    atomic charge: Z = 1
    Rydberg charge: Zc = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL118-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castAtom-Tuple{}" href="#CamiXon.castAtom-Tuple{}"><code>CamiXon.castAtom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castAtom(;Z=1, A=1, Q=0, msg=true)
castAtom(elt::String; A=1, Q=0, msg=true)</code></pre><p>Create Atom with fields:</p><ul><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.Q</code>:  ionic charge in a.u. (<code>::Int</code>)</li><li><code>.Zc</code>:  Rydberg charge in a.u. (<code>::Int</code>)</li><li><code>.element</code>:  (<code>::Element</code>)</li><li><code>.isotope</code>:  (<code>::Isotope</code>)</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">castAtom(&quot;Rb&quot;; A=87, Q=0, msg=false) == castAtom(Z=37, A=87, Q=0, msg=false)
  true

castAtom(Z=1, A=3, Q=0, msg=false)
  Atom(1, 3, 0, 1, Element(&quot;hydrogen&quot;, &quot;H&quot;, 1.008), Isotope(&quot;³T&quot;, &quot;tritium&quot;,
  1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing))

atom = castAtom(Z=1, A=3, Q=0, msg=true);
  Element created: H, hydrogen, Z=1, weight=1.008
  Isotope created: ³T, tritium, Z=1, A=3, N=2, R=1.7591, M=3.016049281, I=1/2⁺, μI=2.97896246, Q=0.0, RA=trace, (radioactive)
  Atom created: tritium, neutral atom, ³T, Z=1, A=3, Q=0, Zc=1

atom
  Atom(1, 3, 0, 1, Element(&quot;hydrogen&quot;, &quot;H&quot;, 1.008), Isotope(&quot;³T&quot;, &quot;tritium&quot;,
  1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing))

atom.isotope.T½
  12.33</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL166-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castOrbit-Tuple{}" href="#CamiXon.castOrbit-Tuple{}"><code>CamiXon.castOrbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castOrbit(;n=1, ℓ=0, msg=true)</code></pre><p>Create <code>Orbit</code> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">castOrbit(n=1, ℓ=0)
 Orbit created: 1s (n = 1, n′ = 0, ℓ = 0)
 Orbit(&quot;1s&quot;, 1, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL259-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.createSpinOrbit-Tuple{Orbit}" href="#CamiXon.createSpinOrbit-Tuple{Orbit}"><code>CamiXon.createSpinOrbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">createSpinOrbital(o::Orbit; up=true, msg=true)</code></pre><p>Specify <code>SpinOrbit</code> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>: principal quantum number</li><li><code>.n′</code>: radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>: orbital angular momentum valence electron</li><li><code>.ms</code>: spin magnetic quantum number</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">s1s = castOrbit(1,0)
createSpinOrbit(s1s; up=true)
  SpinOrbit created: 1s↑ (n = 1, n′ = 0, ℓ = 0, ms = 1//2)
  SpinOrbit(&quot;1s↑&quot;, 1, 0, 0, 1//2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL315-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.createTerm-Tuple{Int64}" href="#CamiXon.createTerm-Tuple{Int64}"><code>CamiXon.createTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)</code></pre><p>Specify Term in the <em>Term notatation</em> with fields:</p><ul><li><code>.n</code>: principal quantum number</li><li><code>.n′</code>: radial quantum number (number of nodes - autogenerated)</li><li><code>.ℓ</code>: orbital angular momentum valence electron</li><li><code>.S</code>: total electron spin</li><li><code>.L</code>: total orbital angular momentum</li><li><code>.J</code>: total electronic angular momentum</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">term_H1I = createTerm(1; ℓ=0, S=1//2, L=0, J=1//2)
 Term created: 1s ²S₁⸝₂, n = 1, n′ = 0, ℓ = 0, S = 1//2, L = 0, J = 1//2
 Term(&quot;1s ²S₁⸝₂&quot;, 1, 0, 0, 1//2, 0, 1//2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/atom.jl#LL371-L387">source</a></section></article><h3 id="Hydrogen"><a class="docs-heading-anchor" href="#Hydrogen">Hydrogen</a><a id="Hydrogen-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogen" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.bohrformula-Tuple{Int64, Int64}" href="#CamiXon.bohrformula-Tuple{Int64, Int64}"><code>CamiXon.bohrformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bohrformula(Z::Int, n::Int)</code></pre><p>Hydrogenic energy (in Hartree a.u.) for <em>atom</em> with <em>atomic number</em> <code>Z</code> and <em>principal quantum number</em> <code>n</code>.</p><p class="math-container">\[    E_n = - \frac{Z^2}{2n^2}\]</p><p><strong>Example:</strong></p><pre><code class="language-none">Z = 2
n = 4
bohrformula(Z,n)
 -0.125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/hydrogen.jl#LL95-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.hydrogenic_reduced_wavefunction-Tuple{Atom, Orbit, Grid, Def}" href="#CamiXon.hydrogenic_reduced_wavefunction-Tuple{Atom, Orbit, Grid, Def}"><code>CamiXon.hydrogenic_reduced_wavefunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hydrogenic_reduced_wavefunction(atom::Atom, orbit::Orbit, grid::Grid, def::Def)</code></pre><p>Analytic expression for the hydrogenic wavefunction written in the format <span>$Z = \tilde{χ} + i \tilde{χ}^′$</span>, where <span>$\tilde{χ}_{nℓ}(ρ)$</span> is the <em>reduced</em> radial wavefunction and <span>$\tilde{χ}^′_{nℓ}(ρ)$</span> its derivative, with <span>$ρ$</span> the radial distance to the nucleus in a.u.. The expression is evaluated for a given <a href="#CamiXon.Atom"><code>Atom</code></a> in a given <a href="#CamiXon.Orbit"><code>Orbit</code></a> on a given <a href="#CamiXon.Grid"><code>Grid</code></a>. The argument <a href="#CamiXon.Def"><code>Def</code></a> completes the definition of the problem.</p><p class="math-container">\[    \tilde{\chi}_{nl}(\rho)
    =\mathcal{N}_{nl}^{-1/2}(2Z/n)^{l+3/2}\rho^{l+1}e^{-Zρ/n}
    L_{n-l-1}^{2l+1}(2Z\rho/n)\]</p><p>where <span>$L_{n-l-1}^{2l+1}(2Z\rho/n)$</span> is the generalized Laguerre polynomial <a href="#CamiXon.generalized_laguerreL-Union{Tuple{T}, Tuple{U}, Tuple{Int64, U, T}} where {U&lt;:Real, T&lt;:Real}"><code>generalized_laguerreL</code></a> and</p><p class="math-container">\[    \mathcal{N}_{nl}
    = {\displaystyle \int\nolimits _{0}^{\infty}}x^{2l+2}e^{-x}
    \left[L_{n-l-1}^{2l+1}(x)\right]^{2}dx
    = \frac{2n\Gamma(n+l+1)}{\Gamma(n-l)}\]</p><p>is the norm of the wavefunction.</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(Z=1, A=1, Q=0)
orbit = castOrbit(n=25, ℓ=10)
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=true)
def = castDef(grid, atom, orbit, codata)
Z = hydrogenic_reduced_wavefunction(atom, orbit, grid, def);
    Element created: H, hydrogen, Z=1, weight=1.008
    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)
    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1
    Orbital: 25n
    principal quantum number: n = 25
    radial quantum number: n′ = 14 (number of nodes in radial wavefunction)
    orbital angular momentum of valence electron: ℓ = 10
    Grid created: exponential, Float64, Rmax = 1935.0 a.u., Ntot = 1300, h = 0.00769231, r0 = 0.0878529
    Def created for hydrogen 25n on exponential grid of 1300 points

plot_wavefunction(Z, 1:grid.N, grid, def)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/H1_25n.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/hydrogen.jl#LL21-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.reduce_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.reduce_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.reduce_wavefunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduce_wavefunction(Z::Vector{Complex{T}}, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Conversion from the <em>ordinary</em> radial wavefunction <span>$\tilde{R}_{nl}(ρ)$</span> to the <em>reduced</em> radial wavefuntion</p><p class="math-container">\[    \tilde{\chi}_{nl}(ρ) = ρ \tilde{R}_{nl}(ρ).\]</p><p>where <span>$ρ$</span> is the radial distance to the nucleus in a.u..</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(Z=1, A=1, Q=0; msg=false);
orbit = castOrbit(n=1, ℓ=0; msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);
def = castDef(grid, atom, orbit, codata);

RH1s_example = [RH1s(atom.Z, grid.r[n]) for n=1:grid.N];
XH1s_generic = hydrogenic_reduced_wavefunction(atom, orbit, grid, def);

XH1s_example = reduce_wavefunction(RH1s_example);
RH1s_generic = restore_wavefunction(XH1s_generic);

XH1s_example ≈ XH1s_generic
    true

RH1s_example ≈ RH1s_generic
    true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/hydrogen.jl#LL205-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.restore_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.restore_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.restore_wavefunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">restore_wavefunction(Z::Vector{Complex{T}}, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Conversion from the <em>reduced</em> radial wavefunction <span>$\tilde{\chi}_{nl}(ρ)$</span> to the <em>ordinary</em> radial wavefuntion <span>$\tilde{R}_{nl}(ρ)$</span>,</p><p class="math-container">\[    \tilde{R}_{nl}(ρ)=\tilde{\chi}_{nl}(ρ)/ρ,\]</p><p>where <span>$ρ$</span> is the radial distance to the nucleus in a.u..</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(Z=1, A=1, Q=0; msg=false);
orbit = castOrbit(n=1, ℓ=0; msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);
def = castDef(grid, atom, orbit, codata);

RH1s_example = [RH1s(atom.Z, grid.r[n]) for n=1:grid.N];
XH1s_generic = hydrogenic_reduced_wavefunction(atom, orbit, grid, def);

XH1s_example = reduce_wavefunction(RH1s_example);
RH1s_generic = restore_wavefunction(XH1s_generic);

RH1s_example ≈ RH1s_generic
    true

XH1s_example ≈ XH1s_generic
    true

f1 = real(XH1s_example)
f2 = real(XH1s_generic)

compare_functions(f1, f2, 1:grid.N, grid)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>compare_functions</code> is not included in the <code>CamiXon</code> package. <img src="assets/compareXH1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/hydrogen.jl#LL150-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.demo_hydrogen-Tuple{}" href="#CamiXon.demo_hydrogen-Tuple{}"><code>CamiXon.demo_hydrogen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">demo_hydrogen(; n=3, ℓ=2, codata=castCodata(2018))</code></pre><p>Solves Schrödinger equation for hydrogen atom with principal quantum number <code>n</code> and rotational quantum number <code>ℓ</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);
    Def created for hydrogen 1s on exponential grid of 100 points

E = 1.5Ecal
E, def, adams, Z = adams_moulton_master(E, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=true);

plot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. Note the discontinuity in the derivative. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/hydrogen-1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/hydrogen.jl#LL115-L134">source</a></section></article><h4 id="Some-special-cases"><a class="docs-heading-anchor" href="#Some-special-cases">Some special cases</a><a id="Some-special-cases-1"></a><a class="docs-heading-anchor-permalink" href="#Some-special-cases" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CamiXon.RH1s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}" href="#CamiXon.RH1s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH1s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RH1s(Z::U, r::T) where {U &lt;: Real, T &lt;:Real}</code></pre><p>Analytic expression for the <em>hydrogenic</em> 1s radial wavefunction and its derivative in the format <span>$Z = \tilde{R} + i \tilde{R}^′$</span>, where</p><p class="math-container">\[    \tilde{R}_{1s}(ρ) = Z^{3/2} 2 e^{-Zρ}\]</p><p>is the radial wavefunction and</p><p class="math-container">\[    \tilde{R}^′_{1s}(ρ) = -Z^{5/2} 2 e^{-Zρ}\]</p><p>its derivative, with <span>$ρ$</span> the radial distance to the nucleus in a.u..</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(Z=1, A=1, Q=0; msg=false);
orbit = castOrbit(n=1, ℓ=0; msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);
def = castDef(grid, atom, orbit, codata);

RH1s_example = [RH1s(atom.Z, grid.r[n]) for n=1:grid.N];

plot_wavefunction(RH1s_example, 1:grid.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_function</code> is not included in the <code>CamiXon</code> package. <img src="assets/RH1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/hydrogen.jl#LL249-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.RH2p-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}" href="#CamiXon.RH2p-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH2p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RH2p(Z::U, r::T) where {U &lt;: Real, T &lt;:Real}</code></pre><p>Analytic expression for the <em>hydrogenic</em> 1s reduced radial wavefunction and its derivative in the format <span>$Z = \tilde{R} + i \tilde{R}^′$</span>, where</p><p class="math-container">\[    \tilde{R}_{2p}(ρ)=\left(Z/2\right)^{3/2}\sqrt{1/3}(Zρ/2)2e^{-Zρ/2}\]</p><p>is the radial wavefunction and</p><p class="math-container">\[    \tilde{R}_{2p}(ρ)=\left(Z/2\right)^{3/2}\sqrt{1/3}(1-Zρ/2)2e^{-Zρ/2}\]</p><p>its derivative, with <span>$ρ$</span> the radial distance to the nucleus in a.u..</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(Z=1, A=1, Q=0; msg=false);
orbit = castOrbit(n=2, ℓ=1; msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);
def = castDef(grid, atom, orbit, codata);

RH2p_example = [RH2p(atom.Z, grid.r[n]) for n=1:grid.N];

plot_wavefunction(RH2p_example, 1:grid.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/RH2p.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/hydrogen.jl#LL289-L315">source</a></section></article><h2 id="Angular-momentum"><a class="docs-heading-anchor" href="#Angular-momentum">Angular momentum</a><a id="Angular-momentum-1"></a><a class="docs-heading-anchor-permalink" href="#Angular-momentum" title="Permalink"></a></h2><h3 id="Vector-coupling-coefficients"><a class="docs-heading-anchor" href="#Vector-coupling-coefficients">Vector-coupling coefficients</a><a id="Vector-coupling-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-coupling-coefficients" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.threeJsymbol-NTuple{6, Real}" href="#CamiXon.threeJsymbol-NTuple{6, Real}"><code>CamiXon.threeJsymbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">threeJsymbol(j1::Real, m1::Real, j2::Real, m2::Real, j3::Real, m3::Real; msg=false)</code></pre><p>Wigner 3j symbol. This is a vector coupling coefficient with optimized symmetry properties. The 3j symbols are zero unless <span>$Δ(j_{1},j_{2},j_{3})&gt;0$</span> (triangle inequality holds) and <span>$m_{1}+m_{2}+m_{3}=0$</span>. The implementation is based on the Racah formula:</p><p class="math-container">\[\left(\begin{array}{ccc}
j_{1} &amp; j_{2} &amp; j_{3}\\
m_{1} &amp; m_{2} &amp; m_{3}
\end{array}\right)=
(-1)^{j_{1}-j_{2}-m_{3}}\sqrt{\Delta(j_{1}j_{2}J)}\\\times
\sqrt{\left(j_{1}+m_{1}\right)!
\left(j_{1}-m_{1}\right)!
\left(j_{2}+m_{2}\right)!
\left(j_{2}-m_{2}\right)!
\left(j_{3}+m_{3}\right)!
\left(j_{3}-m_{3}\right)!}
\\\times\sum_{t}\frac{(-)^{t}}{t!(j_{3}-j_{2}+t+m_{1})!
(j_{3}-j_{1}+t-m_{2})!
(j_{1}+j_{2}-j_{3}-t)!(j_{1}-t-m_{1})!(j_{2}-t+m_{2})!}\]</p><p><strong>Example:</strong></p><pre><code class="language-none">o = threeJsymbol(3, 0, 4, -1, 5, 1; msg=true); println(&quot; = $o&quot;)
    -√(361/30030) = -0.10964174397241236

threeJsymbol(3, 0, 4, -1, 5, 1)
    -0.10964174397241236

threeJsymbol(0, 0, 0, 0, 0, 0)
    1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/angular_momentum.jl#LL57-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.CGC-NTuple{6, Real}" href="#CamiXon.CGC-NTuple{6, Real}"><code>CamiXon.CGC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CGC(j1::Real, m1::Real, j2::Real, m2::Real, J::Real, M::Real; msg=false)</code></pre><p>Clebsch-Gordan coefficient (CGC). This is a vector-coupling coefficient in Dirac notation. The CGCs are zero unless <span>$Δ(j_{1},j_{2},j_{3})&gt;0$</span> (triangle inequality holds) and <span>$M=m_{1}+m_{2}$</span>. The relation to the Wigner 3j symbols is given by:</p><p class="math-container">\[\langle j_{1}m_{1};j_{2}m_{2}|JM\rangle\equiv
(-1)^{j_{1}-j_{2}+M}\sqrt{2J+1}\left(\begin{array}{ccc}
j_{1} &amp; j_{2} &amp; J\\
m_{1} &amp; m_{2} &amp; -M
\end{array}\right)\]</p><p><strong>Example:</strong></p><pre><code class="language-none">j1=3; m1=0
j2=4; m2=-1
J=5; M=-1
o = CGC(j1, m1, j2, m2, J, M; msg=true); println(&quot; = $o&quot;)
o = CGC(j1, m1, j2, m2, J, M); println(o)
o = (-1)^(j1-j2+M) * sqrt(2J+1) * threeJsymbol(j1, m1, j2, m2, J, -M); println(o)
    -√(361/2730) = -0.36364052611670256
    -0.36364052611670256
    -0.36364052611670256</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/angular_momentum.jl#LL117-L144">source</a></section></article><h2 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h2><p>The <code>Grid</code> object is the backbone for the numerical procedure on a non-uniform grid. Its principal fields are <code>grid.r</code> and <code>grid.r′</code>, which are discrete functions of <code>N</code> elements representing the grid function and its derivative.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Grid" href="#CamiXon.Grid"><code>CamiXon.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Grid(ID, name, T, N, r, r′, h, r0, epn, epw, k)</code></pre><p>Type with fields:</p><ul><li><code>.ID</code>:   grid identifer name (<code>::Int</code>)</li><li><code>.name</code>: grid identifer name (<code>::String</code>)</li><li><code>.T</code>:    gridType (<code>::Type</code>)</li><li><code>.N</code>:    number of grid points (<code>::Int</code>)</li><li><code>.r</code>:   tabulated grid function (<code>::Vector{T}</code>)</li><li><code>.r′</code>:   tabulated derivative of grid function (<code>::Vector{T}</code>)</li><li><code>.h</code> :   grid step multiplyer (<code>::T</code>)</li><li><code>.r0</code>:   grid scale factor (<code>::T</code>)</li><li><code>.epn</code>:  number of endpoints used for trapezoidal endpoint correction (must be odd) (<code>::Int</code>)</li><li><code>.epw</code>:  trapezoidal endpoint weights for n=1:epn (<code>::Vector{Vector{T}}</code>)</li><li><code>.k</code>:    Adams-Moulton order (<code>::Int</code>)</li></ul><p>The object <code>Grid</code> is best created with the function <a href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>castGrid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid.jl#LL3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.gridname-Tuple{Int64}" href="#CamiXon.gridname-Tuple{Int64}"><code>CamiXon.gridname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gridname(ID::Int)</code></pre><p>Name corresponding to the grid ID.</p><p><strong>Example:</strong></p><pre><code class="language-none">n = gridname(2); println(&quot;The grid type with ID = 2 is called &#39;$n&#39;.&quot;)
  The grid type with ID = 2 is called &#39;quasi-exponential&#39;.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid_autoset.jl#LL48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.gridfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T &lt;: Real</code></pre><ul><li><code>ID = 1</code>: exponential grid function,</li></ul><p class="math-container">\[    f[n] = \text{exp}(h(n-1)) - 1.0\]</p><ul><li><code>ID = 2</code>: quasi-exponential grid function degree <code>p</code> (linear grid for <code>p = 1</code>),</li></ul><p class="math-container">\[    f[n] = h(n-1) + \frac{1}{2}(h(n-1))^2 + ⋯ + \frac{1}{p!}(h(n-1))^p\]</p><ul><li><code>ID = 3</code>: linear grid function,</li></ul><p class="math-container">\[    f[n] = h(n-1)\]</p><ul><li><code>ID = 4</code>: polynomial grid function of degree <code>p = length(c)</code> based on <code>polynom</code> <span>$c = [c_1,c_2,⋯\ c_p]$</span>,</li></ul><p class="math-container">\[    f[n] = c_1h(n-1) + c_2(h(n-1))^2 + ⋯ + c_p(h(n-1))^p\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">h = 0.1
r = [gridfunction(1, n-1, h) for n=1:5]                            # exponential
 [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032, 0.49182469764127035]

r = [gridfunction(2, n-1, h; p = 4) for n=1:5]  # quasi exponential (degree p=4)
 [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375, 0.49173333333333336]

r = [gridfunction(3, n-1, h) for n=1:5]              # linear
  [0.0, 0.1, 0.2, 0.3, 0.4]

r′= [gridfunction(3, n-1, h; deriv=1) for n=1:5]     # linear (first derivative)
   [0.1, 0.1, 0.1, 0.1, 0.1]

  r = [gridfunction(4, n-1, h; coords = [0,1,1/2,1/6,1/24]) for n=1:5]  # polynomial of degree 4)
   [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001, 0.49173333333333336]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid_autoset.jl#LL226-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castGrid-Tuple{Int64, Int64, Type}" href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>CamiXon.castGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castGrid(ID::Int, N::Int, T::Type; h=1, r0=1,  p=5, coords=[0,1], epn=5, k=7, msg=true)</code></pre><p>Method to create the Grid object</p><p><code>ID = 1</code>: exponential grid, <code>ID = 2</code>: quasi-exponential grid, <code>ID = 3</code>: linear grid <code>ID = 4</code>: polynomial grid</p><p><strong>Examples:</strong></p><pre><code class="language-none">h = 0.1
r0 = 1.0
grid = castGrid(1, 4, Float64; h, r0)
grid.r
  create exponential Grid: Float64, Rmax = 0.491825 a.u., Ntot = 4, h = 0.1, r0 = 1.0
  [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]

grid = castGrid(2, 4, Float64; p = 4, h, r0)
grid.r
  create quasi-exponential Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, p = 4, h = 0.1, r0 = 1.0
  [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375]

grid = castGrid(3, 4, Float64; coords=[0, 1, 1/2, 1/6, 1/24], h, r0)
grid.r
  create polynomial Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, coords = [0.0, 1.0, 0.5, 0.166666, 0.0416666], h = 0.1, r0 = 1.0
  [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001]

grid = castGrid(4, 4, Float64; h, r0)
grid.r
  create linear Grid: Float64, Rmax = 0.4 a.u., Ntot = 4, p = 1, h = 0.1, r0 = 1.0
  [0.0, 0.1, 0.2, 0.3]

grid.r′
  [0.1, 0.1, 0.1, 0.1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid.jl#LL36-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T&lt;:Number" href="#CamiXon.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T&lt;:Number"><code>CamiXon.findIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findIndex(rval::T, grid::Grid{T}) where T&lt;:Number</code></pre><p>The grid index corresponding to the position <code>rval</code> on the <code>grid</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">h = 0.1
r0 = 1.0
grid = castGrid(1, 4, Float64; h, r0)
r = grid.r; println(&quot;r[3] = $(r[3])&quot;)
  Grid created: exponential, Float64, Rmax = 0.491825 a.u., Ntot = 4, h = 0.1, r0 = 1.0
  r[3] = 0.22140275816016985

findIndex(0.222, grid)
  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid.jl#LL94-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoRmax-Tuple{Atom, Orbit}" href="#CamiXon.autoRmax-Tuple{Atom, Orbit}"><code>CamiXon.autoRmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoRmax(atom::Atom, orbit::Orbit)</code></pre><p>Largest relevant radial distance in a.u. (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
atom = castAtom(Z=1, A=1, Q=0)
orbit = castOrbit(n=1, ℓ=0)
rmax = autoRmax(atom::Atom, orbit::Orbit); println(&quot;rmax = $(rmax) a.u.&quot;)
    Element created: H, hydrogen, Z=1, weight=1.008
    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)
    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    rmax = 63.0 a.u.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid_autoset.jl#LL99-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoNtot-Tuple{Orbit}" href="#CamiXon.autoNtot-Tuple{Orbit}"><code>CamiXon.autoNtot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoNtot(orbit::Orbit, Nboost=1)</code></pre><p>Total number of gridpoints (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="language-none">orbit = castOrbit(n=1, ℓ=0)
autoNtot(orbit)
 Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)

 100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid_autoset.jl#LL135-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real" href="#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real"><code>CamiXon.autoPrecision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoPrecision(Rmax::T, orbit::Orbit) where T&lt;:Real</code></pre><p>Floating point precision (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(Z=1)
orbit = castOrbit(n=1,ℓ=0)
Rmax = autoRmax(atom, orbit)
o = autoPrecision(Rmax, orbit); println(&quot;precision = $o&quot;)
    Element created: H, hydrogen, Z=1, weight=1.008
    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)
    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    precision = Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid_autoset.jl#LL163-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.autoSteps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoSteps(ID::Int, Ntot::Int, Rmax::T; p=5) where T&lt;:Real
autoSteps(ID::Int, Ntot::Int, Rmax::T; coords=[0,1]) where T&lt;:Real</code></pre><p>Step size parameter (h) and range parameter (r0) (rule of thumb values).</p><p><strong>Example:</strong></p><pre><code class="language-none">(h, r0) = autoSteps(1, 100, 100)
    (0.1, 0.004540199100968777)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid_autoset.jl#LL200-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoGrid-Tuple{Atom, Orbit, Type}" href="#CamiXon.autoGrid-Tuple{Atom, Orbit, Type}"><code>CamiXon.autoGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoGrid(atom, orbit,  T; Nboost=1, epn=5, k=7, msg=true, p=0)
autoGrid(atom, orbits, T; Nboost=1, epn=5, k=7, msg=true, p=0)
autoGrid(atom, orbit,  T; Nboost=1, epn=5, k=7, msg=true, coords=[])
autoGrid(atom, orbits, T; Nboost=1, epn=5, k=7, msg=true, coords=[])</code></pre><p>Automatic setting of grid parameters for a given orbit <a href="#CamiXon.Orbit"><code>Orbit</code></a> or an array of orbits - <code>orbits = [orbit1, orbit2, ⋯]</code>. Important cases:</p><ul><li><code>p == 0</code> (exponential radial grid)</li><li><code>p == 1</code> (linear radial grid)</li><li><code>p &gt; 1</code> (quasi-exponential radial grid)</li><li><code>coords=[]</code> (free polynomial grid based on the <code>coords</code>)</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
atom = castAtom(;Z=1, A=1, Q=0, msg=false)
orbit = castOrbit(n=75, ℓ=0, msg=false)
grid = autoGrid(atom, orbit, Float64);
    Grid created: exponential, Float64, Rmax = 16935.0 a.u., Ntot = 3800, h = 0.00263158, r0 = 0.768883

plot_gridfunction(grid, 1:grid.N; title=&quot;&quot;)</code></pre><p>The plot is made using CairomMakie. NB.: <code>plot_gridfunction</code> is not part of the <code>CamiXon</code> package. <img src="assets/exponential_grid.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid_autoset.jl#LL277-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real" href="#CamiXon.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_differentiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_differentiation(f::Vector{T}, grid::Grid{T}; k=3) where T&lt;:Real</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the analytic function <span>$f$</span>, tabulated in forward order on a <a href="#CamiXon.Grid"><code>Grid</code></a> of <span>$n$</span> points, <span>$f[1:n]$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">ID = 4 # linear grid
f = [0.0, 1.0, 4.0, 9.0, 16.0, 25.0]
grid = castGrid(ID, length(f), Float64; r0=1.0, h=1.0, k=3)  # linear grid
f′= grid_differentiation(f, grid; k=3); println(&quot;f′= $(f′)&quot;)
  Grid created: linear, Float64, Rmax = 6.0 a.u., Ntot = 6, p = 1, h = 1.0, r0 = 1.0
  f′= [0.0, 2.0, 4.0, 6.0, 7.999999999999998, 9.999999999999993]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid.jl#LL131-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.grid_integration-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{V}}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.grid_integration-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.grid_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_integration(f::Vector{T}, n1::Int, n2::Int, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Integral of the function <span>$f=[f_0,⋯\ f_n]$</span> tabulated on a <a href="#CamiXon.Grid"><code>Grid</code></a> using the trapezoidal rule optimized with endpoint correction by the weightsvector <code>grid.epw</code>,</p><p class="math-container">\[    ∫_{0}^{r_n} f(r) dr = ∫_{0}^{n} f(x) r^{\prime}(x) dx,\]</p><p>where the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see <a href="#CamiXon.trapezoidal_integration-NTuple{4, Any}"><code>trapezoidal_integration</code></a>). The rule is exact for polynonials of degree <span>$d=0,\ 1,⋯\ k-1$</span>, where <span>$k=$</span> <code>grid.epn</code>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Example:</strong></p><pre><code class="language-none">f1s(r) = 2.0*r*exp(-r);  # hydrogen 1s wavefunction (reduced and unit normalized)
N = 1000;
grid = castGrid(1, N, Float64; h=0.01, r0=0.005)
    create exponential Grid: Float64, Rmax = 110.127 (a.u.), Ntot = 1000, h = 0.01, r0 = 0.005

r = grid.r;
f2 = [f1s(r[n])^2 for n=1:N];
grid_integration(f2, 1:N, grid) == grid_integration(f2, 1, N, grid)
    true

norm = grid_integration(f2, 1:N, grid)

    1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/grid.jl#LL159-L188">source</a></section></article><h2 id="Adams-Moulton-integration"><a class="docs-heading-anchor" href="#Adams-Moulton-integration">Adams-Moulton integration</a><a id="Adams-Moulton-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-integration" title="Permalink"></a></h2><p>The Adams-Moulton method is used for numerical integration of the reduces radial wave equation. In the present implementation it is constructed on top the objects <a href="#CamiXon.Atom"><code>Atom</code></a>, <a href="#CamiXon.Orbit"><code>Orbit</code></a>, <a href="#CamiXon.Grid"><code>Grid</code></a>, <a href="#CamiXon.Def"><code>Def</code></a> and <a href="#CamiXon.Adams"><code>Adams</code></a> using 5 globally defined instances called <code>atom</code>, <code>orbit</code>, <code>grid</code>, <code>def</code> and <code>adams</code>.</p><h3 id="Def"><a class="docs-heading-anchor" href="#Def">Def</a><a id="Def-1"></a><a class="docs-heading-anchor-permalink" href="#Def" title="Permalink"></a></h3><p>The <code>Def</code> object serves to define the problem to be solved and to contain in the field <code>def.Z</code> the solution as a discrete function of <code>N</code> elements.</p><h4 id="Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index"><a class="docs-heading-anchor" href="#Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index">Illustration: central field potential <span>$U_{\mathrm{CF}}$</span> versus grid index</a><a id="Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index-1"></a><a class="docs-heading-anchor-permalink" href="#Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index" title="Permalink"></a></h4><pre><code class="language-none">codata = castCodata(2018)
atom = castAtom(Z=1, A=1, Q=0)
orbit = castOrbit(n=7, ℓ=2)
grid = autoGrid(atom, orbit, Float64)
def = castDef(grid, atom, orbit, codata)
E = convert(grid.T,bohrformula(atom.Z, orbit.n))
adams = castAdams(E, grid, def)
@printf &quot;E = %.15g %s \n&quot; E &quot;Hartree&quot;
    Element created: H, hydrogen, Z=1, weight=1.008
    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)
    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1
    Orbital: 7d
        principal quantum number: n = 7
        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 2
    Grid created: exponential, Float64, Rmax = 207.0 a.u., Ntot = 400, h = 0.025, r0 = 0.00939821
    Def created for hydrogen 7d on exponential grid of 400 points
    E = -0.0102040816326531 Hartree

plot_potentials(E, grid, def)
    Nlctp = 234, Nmin = 259, Nuctp = 369 (Ructp = 93.0059202490 a.u.)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_potentials</code> is not included in the <code>CamiXon</code> package. <img src="assets/potential.png" alt="Image"/></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Def" href="#CamiXon.Def"><code>CamiXon.Def</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Def(T, atom, orbit, pot, scr, o1, o2, o3, pos, epn, k, am, matLD)</code></pre><p>Type with fields:</p><ul><li><code>.T</code>: gridType (<code>::Type</code>)</li><li><code>.atom</code>: atom object (<code>::Atom</code>)</li><li><code>.orbit</code>: orbit object (<code>::Orbit</code>)</li><li><code>.codata</code>: codata object (<code>::Codata</code>)</li><li><code>.pot</code>: tabulated potential function (<code>::Vector{T}</code>)</li><li><code>.scr</code>: tabulated screening function (<code>::Vector{T}</code>)</li><li><code>.o1</code>: vector of zero-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.o2</code>: vector of zero-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.o3</code>: vector of unit-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.pos</code>: object containing Na, Nlctp, Nmin, Nuctp, Nb, N and nodes (<code>::Pos</code>)</li><li><code>.epn</code>: number of endpoints trapezoidal correction - must be odd (<code>::Int</code>)</li><li><code>.k</code>: Adams-Moulton order (<code>::Int</code>)</li><li><code>.am</code>: Adams-Moulton weight coefficients (<code>::Vector{T}</code>)</li><li><code>.matLD</code>: Lagrangian differentiation matrix (<code>::Matrix{T}</code>)</li></ul><p>The object <code>Def</code> is best created with the function <a href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T&lt;:Real"><code>castDef</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL41-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T&lt;:Real" href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T&lt;:Real"><code>CamiXon.castDef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castDef(grid::Grid{T}, atom::Atom, orbit::Orbit, codata::Codata[; scr=nothing[, msg=true]]) where T &lt;: Real</code></pre><p>Create the <a href="#CamiXon.Def"><code>Def</code></a> object starting from the <a href="#CamiXon.Grid"><code>Grid</code></a> object and the atomic properties of the objects <a href="#CamiXon.Atom"><code>Atom</code></a> and <a href="#CamiXon.Orbit"><code>Orbit</code></a>. Optional: scr (supply screening array)</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
atom = castAtom(Z=1, A=1, Q=0)
orbit = castOrbit(n=7, ℓ=2)
grid = autoGrid(atom, orbit, Float64)
def = castDef(grid, atom, orbit, codata);
    Element created: H, hydrogen, Z=1, weight=1.008
    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)
    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1
    Orbital: 7d
        principal quantum number: n = 7
        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 2
    Grid created: exponential, Float64, Rmax = 207.0 a.u., Ntot = 400, h = 0.025, r0 = 0.00939821
    Def created for hydrogen 7d on exponential grid of 400 points</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL97-L120">source</a></section></article><h4 id="Pos-and-Pos-related-functions"><a class="docs-heading-anchor" href="#Pos-and-Pos-related-functions">Pos and Pos-related functions</a><a id="Pos-and-Pos-related-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Pos-and-Pos-related-functions" title="Permalink"></a></h4><p>The <code>Pos</code> object serves within <a href="#CamiXon.Def"><code>Def</code></a> object to contain the position indices <code>def.Na</code>, <code>def.Nb</code>, <code>def.Nlctp</code>, <code>def.Nmin</code>, <code>def.Nuctp</code> used in Adams-Moulton integration. These positions are contained in the fields <code>def.pos.Na</code>, <code>def.pos.Nb</code>, <code>def.pos.Nlctp</code>, <code>def.pos.Nmin</code>, <code>def.pos.Nuctp</code>. Alternatively, they can be determined with the functions <a href="#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>get_Na</code></a>, <a href="#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>get_Nb</code></a>, <a href="#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>get_Nlctp</code></a>, <a href="#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>get_Nmin</code></a>, <a href="#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>get_Nuctp</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Pos" href="#CamiXon.Pos"><code>CamiXon.Pos</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pos(Na::Int, Nlctp::Int, Nmin::Int, Nuctp::Int, Nb::Int, N::Int, nodes::Int, cWKB::Float64)</code></pre><p>Type with fields:</p><ul><li><code>.Na</code>: grid index of last leading point (<code>::Int</code>)</li><li><code>.Nlctp</code>: grid index of lower classical turning point (<code>::Int</code>)</li><li><code>.Nmin</code>: grid index of (screened) potential minimum (<code>::Int</code>)</li><li><code>.Nuctp</code>: grid index of upper classical turning point (<code>::Int</code>)</li><li><code>.Nb</code>: grid index first trailing point (<code>::Int</code>)</li><li><code>.N</code>: grid index last point (<code>::Int</code>)</li><li><code>.nodes</code>: number of nodes  (<code>::Int</code>)</li><li><code>.cWKB</code>: WKB threshold level determining Na and Nb (<code>::Float64</code>)</li></ul><p>Mutable struct to hold special grid indices as well as the number of nodes; <code>Pos</code> is one of the fields of the <a href="#CamiXon.Def"><code>Def</code></a> object</p><p><strong>Examples:</strong></p><pre><code class="language-none">pos = Pos(1, 2, 3, 4, 5, 6, 7, 8)
pos.Nuctp
    4

pos.Nuctp = 8
pos
    Pos(1, 2, 3, 9, 5, 6, 7, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL2-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Na</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Na(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the starting point for outward numerical integration. This is <code>k+1</code> or the point marking the end of the quasiclassical region below the lower classical turning point (<code>lctp</code>) as marked by the WKB threshold value (<code>def.pos.cWKB</code>).</p><p><strong>Example:</strong></p><pre><code class="language-none">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)
E, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=false);
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033
    Def created for hydrogen 1s on exponential grid

Na = get_Na(Z, def)
println(&quot;k + 1 = $(grid.k+1); Na = $Na&quot;)
    k + 1 = 8; Na = 8

Na == def.pos.Na
    true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL191-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Nb(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the stopping for outward numerical integration. This is <code>N-k-1</code> or the point marking the start of the quasiclassical region above the upper classical turning point (<code>Nuctp</code>) as marked by the WKB threshold value (<code>def.pos.cWKB</code>).</p><p><strong>Example:</strong></p><pre><code class="language-none">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)
E, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=false);
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033
    Def created for hydrogen 1s on exponential grid

Nb = get_Nb(Z, def)
println(&quot;N - k - 1 = $(grid.N-grid.k-1); Nb = $Nb&quot;)
    N - k - 1 = 92; Nb = 92

Nb == def.pos.Nb
    true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL233-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nlctp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Nlctp(E::T, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the *lower classical turning point * of the screened potential curve. By definition <code>get_Nlctp(E, def) = 2</code> for zero orbital angular momentum (<code>ℓ=0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL302-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.get_Nmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Nmin(def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the minimum of the screened potential curve. By definition <code>get_Nmin(def) = 1</code> for zero orbital angular momentum (<code>ℓ=0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL276-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nuctp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Nuctp(E::T, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the <em>upper classical turning point</em> of the screened potential curve. By definition <code>get_Nuctp(E, def) = N-1</code> for zero orbital angular momentum (<span>$ℓ=0$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL338-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.count_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real" href="#CamiXon.count_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.count_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">count_nodes(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</code></pre><p>Number of nodes (excluding the origin) of the reduced radial wavefunction χ(r) = real(Z).</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(Z=1, A=1, Q=0, msg=false);
orbit = castOrbit(n=3, ℓ=2, msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, epn=5, k=7, msg=false);
def = castDef(grid.T, atom, orbit, codata);
    Def created for hydrogen 3d on exponential grid of 200 points

E = convert(setT, bohrformula(atom.Z, orbit.n));
adams = castAdams(E, grid, def);
E, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=false);

o = count_nodes(Z, def); println(&quot;node count: $o nodes&quot;)
    node count: 0 nodes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL372-L393">source</a></section></article><h3 id="Adams"><a class="docs-heading-anchor" href="#Adams">Adams</a><a id="Adams-1"></a><a class="docs-heading-anchor-permalink" href="#Adams" title="Permalink"></a></h3><p>The <code>Adams</code> object serves to hold the Adams-Moulton integration matrices <code>matG</code>, <code>matσ</code>, <code>matMinv</code> as well as the <em>actual</em> normalized solution <code>Z</code> in the form of a tabulated function of <code>N</code> elements.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Adams" href="#CamiXon.Adams"><code>CamiXon.Adams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Adams{T}</code></pre><ul><li>G: (<code>:Vector{Matrix{T}}</code>)</li><li>σ: (<code>:Vector{Matrix{T}}</code>)</li><li>Minv: (<code>:Vector{Matrix{T}}</code>)</li><li>Z: (<code>:Vector{Complex{T}}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams.jl#LL3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.castAdams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castAdams(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams.jl#LL20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.updateAdams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams.jl#LL44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.initE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initE(def::Def{T}) where T&lt;:Real</code></pre><p>Autogenerated seed value for the energy</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
atom = castAtom(Z=1, A=1, Q=0; msg=false)
orbit = castOrbit(n=1, ℓ=0; msg=false)
grid = autoGrid(atom, orbit, Float64; msg=false)
def = castDef(grid, atom, orbit, codata);
    Def created for hydrogen 1s on exponential grid of 100 points

E = initE(def); println(&quot;E = $E&quot;)
    E = -0.03508495857961283</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/def.jl#LL155-L171">source</a></section></article><h4 id="Adams-related-functions"><a class="docs-heading-anchor" href="#Adams-related-functions">Adams related functions</a><a id="Adams-related-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-related-functions" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matG(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matσ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matσ(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL26-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T&lt;:Real" href="#CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T&lt;:Real"><code>CamiXon.matMinv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matMinv(E::T, grid::Grid{T}, def::Def{T}, amEnd::T) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL59-L62">source</a></section></article><h4 id="Adams-Moulton-numerical-solution-of-the-radial-wave-equation"><a class="docs-heading-anchor" href="#Adams-Moulton-numerical-solution-of-the-radial-wave-equation">Adams-Moulton numerical solution of the radial wave equation</a><a id="Adams-Moulton-numerical-solution-of-the-radial-wave-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-numerical-solution-of-the-radial-wave-equation" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_solve-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T&lt;:Real" href="#CamiXon.adams_moulton_solve-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T&lt;:Real"><code>CamiXon.adams_moulton_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_solve(E::T, grid::Grid{T}, def::Def{T}, adams::Adams) where T&lt;:Real</code></pre><p>Numerical solution of the 1D Schrödinger equation for the radial motion of a <em>valence</em> electron of energy <code>E</code>. Output: the improved <code>Adams</code> object, the energy convergence <code>ΔE</code>, and <code>Z</code>, where <code>P = real(Z)</code> is the <em>reduced</em> radial wavefunction and <code>Q = imag(Z)</code> its derivative.</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(Z=1, A=1, Q=0, msg=true)
orbit = castOrbit(n=1, ℓ=0)
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=true)
def = castDef(grid, atom, orbit, codata)
E = Ecal = convert(grid.T, bohrformula(atom.Z, orbit.n))
adams = castAdams(E, grid, def);

adams, ΔE, Z = adams_moulton_solve(E, grid, def, adams)
plot_wavefunction(Z, 1:grid.N, grid, def; reduced=true)</code></pre><p>The plot is made using CairomMakie. NB.: <code>plot_wavefunction</code> is not part of the <code>CamiXon</code> package. <img src="assets/hydrogen-1s-prepared.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL261-L283">source</a></section></article><h4 id="Radial-integration-outward"><a class="docs-heading-anchor" href="#Radial-integration-outward">Radial integration - outward</a><a id="Radial-integration-outward-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-integration-outward" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CamiXon.OUTSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T&lt;:Real" href="#CamiXon.OUTSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T&lt;:Real"><code>CamiXon.OUTSCH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OUTSCH(E::T, grid::Grid{T}, def::Def{T}, σ::Vector{Matrix{T}}})) where T&lt;:Real</code></pre><p>Solution of the Schrödinger for the first <span>$k$</span> points on the <code>grid</code>, where <span>$k$</span> is the Adams-Moulton order. The WKB solution for energy <code>E</code> is used when the WKB approximation is valid (for nonzero angular momentum at distances below the inner classical turning point - ictp)</p><p><strong>Example:</strong></p><pre><code class="language-none">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)
Z = OUTSCH(Ecal, grid, def, adams.σ)
println(&quot;\nZ: standard Ansatz for wavefunction (n &lt; Na=$(def.pos.Na)))&quot;)
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033
    Def created for hydrogen 1s on exponential grid

    Z: standard Ansatz for wavefunction (n &lt; Na=8))

Ecal, grid, def, adams = demo_hydrogen(n=10, ℓ=5)
Z = OUTSCH(Ecal, grid, def, adams.σ);
println(&quot;\nZ: WKB Ansatz for wavefunction (n &lt; Na=$(def.pos.Na)))&quot;)
    Orbital: 10h
        principal quantum number: n = 10
        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 5
    Grid created: exponential, Float64, Rmax = 360.0 a.u., Ntot = 550, h = 0.0181818, r0 = 0.0163447
    Def created for hydrogen 10h on exponential grid

    Z: WKB Ansatz for wavefunction (n &lt; Na=70))

plot_wavefunction(Z, 1:def.pos.Na, grid, def; reduced=true)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/OUTSCH_H1_10h.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/outsch.jl#LL44-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_outward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_outward(def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL93-L96">source</a></section></article><h4 id="Radial-integration-inward"><a class="docs-heading-anchor" href="#Radial-integration-inward">Radial integration - inward</a><a id="Radial-integration-inward-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-integration-inward" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.INSCH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">INSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/insch.jl#LL59-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_inward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_inward(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL143-L146">source</a></section></article><h4 id="Radial-integration-boundary-condition-applied-and-convergence-test"><a class="docs-heading-anchor" href="#Radial-integration-boundary-condition-applied-and-convergence-test">Radial integration - boundary condition applied and convergence test</a><a id="Radial-integration-boundary-condition-applied-and-convergence-test-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-integration-boundary-condition-applied-and-convergence-test" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_normalized(Z::Vector{Complex{T}}, ΔQ::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL208-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_patch-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_patch-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_patch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_patch(Z::Vector{Complex{T}}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre><p>Correct first 2k points of Z.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL233-L237">source</a></section></article><h4 id="Adams-Moulton-Master-procedures"><a class="docs-heading-anchor" href="#Adams-Moulton-Master-procedures">Adams-Moulton Master procedures</a><a id="Adams-Moulton-Master-procedures-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-Master-procedures" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_prepare-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_prepare-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_prepare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_prepare(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre><p>Solves the Schrödinger equation for an atom defined by <code>def</code> for energy <code>E</code> on grid the <code>grid</code> with the Adams-Moulton method defined by <code>adams</code>. <code>E</code> is adjusted until the wavefunction has the correct number of <code>n′</code> nodes.</p><p><strong>Example:</strong></p><pre><code class="language-none">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);
    Def created for hydrogen 1s on exponential grid of 100 points

E = 1.5Ecal
msg, adams, init, Z = adams_moulton_prepare(E, grid, def, adams);
    Ecal = -0.5; E = -0.75; 0 nodes

plot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. Note the discontinuity in the derivative. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package.</p><p><img src="assets/hydrogen-1s-prepared.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL379-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_iterate-Union{Tuple{T}, Tuple{NTuple{4, T}, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_iterate-Union{Tuple{T}, Tuple{NTuple{4, T}, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_iterate(init::NTuple{4,T}, grid::Grid{T}, def::Def{T}, adams::Adams{T}; imax=25, Δν=Value(1,&quot;kHz&quot;)) where T&lt;:Real</code></pre><p>Solves the Schrödinger equation for an atom defined by <code>def</code> for energy <code>E</code> on grid the <code>grid</code> with the Adams-Moulton method defined by <code>adams</code>; <code>E</code> is adjusted in an iteration procedure until convergence is reached within the convergence goal <code>Δν</code> is reached (limited to a maximum of <code>imax</code> iterations).</p><p><strong>Example:</strong></p><pre><code class="language-none">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);
    Def created for hydrogen 1s on exponential grid of 100 points

E = 1.5Ecal;
msg1, adams, init, Z = adams_moulton_prepare(E, grid, def, adams);
println(&quot;Ecal = $Ecal; E = $(init[2]); $(def.pos.nodes) nodes&quot;)
    Ecal = -0.5; E = -0.75; 0 nodes

msg2, adams, init, Z = adams_moulton_iterate(init, grid, def, adams; Δν=Value(1,&quot;MHz&quot;), imax=25)
println(&quot;Ecal = $Ecal; E = $(init[2]); $(def.pos.nodes) nodes&quot;)
    Ecal = -0.5; E = -0.49999997841850014; 0 nodes

plot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/hydrogen-1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL432-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.adams_moulton_master-NTuple{4, Any}" href="#CamiXon.adams_moulton_master-NTuple{4, Any}"><code>CamiXon.adams_moulton_master</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adams_moulton_master(E, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=true)</code></pre><p>Solves the Schrödinger equation for an atom defined by <code>def</code> for energy <code>E</code> on grid the <code>grid</code> with the Adams-Moulton method defined by <code>adams</code>.</p><p><code>Δν</code>: convergence goal</p><p><code>imax</code>: maximum number of iterations</p><p><strong>Example:</strong></p><pre><code class="language-none">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);
    Def created for hydrogen 1s on exponential grid of 100 points

E = 1.5Ecal;
E, def, adams, Z = adams_moulton_master(E, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=true);
plot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/hydrogen-1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/adams-moulton.jl#LL503-L525">source</a></section></article><h2 id="Coulomb-integrals"><a class="docs-heading-anchor" href="#Coulomb-integrals">Coulomb integrals</a><a id="Coulomb-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Coulomb-integrals" title="Permalink"></a></h2><h3 id="Angular-integrals"><a class="docs-heading-anchor" href="#Angular-integrals">Angular integrals</a><a id="Angular-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Angular-integrals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.a_coeff-NTuple{5, Int64}" href="#CamiXon.a_coeff-NTuple{5, Int64}"><code>CamiXon.a_coeff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a_coeff(k::Int, l::Int, ml::Int, l′::Int, ml′::Int)</code></pre><p>Angular coefficient for the <em>direct</em> Coulomb integral:</p><p class="math-container">\[a^{k}(lm_{l};l^{\prime}m_{l^{\prime}})=(-)^{m_{l}+m_{l^{\prime}}}
(2l+1)(2l^{\prime}+1)\left(\begin{array}{ccc}
l &amp; k &amp; l\\
0 &amp; 0 &amp; 0
\end{array}\right)\left(\begin{array}{ccc}
l &amp; k &amp; l\\
-m_{l} &amp; 0 &amp; m_{l}
\end{array}\right)\left(\begin{array}{ccc}
l^{\prime} &amp; k &amp; l^{\prime}\\
0 &amp; 0 &amp; 0
\end{array}\right)\left(\begin{array}{ccc}
l^{\prime} &amp; k &amp; l^{\prime}\\
-m_{l^{\prime}} &amp; 0 &amp; m_{l^{\prime}}
\end{array}\right)\]</p><p><strong>Example:</strong></p><pre><code class="language-none">a(2,1,1,2,2)
    2//35

a(6,3,2,3,-1)
    -250//20449</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/Coulomb_Integrals.jl#LL1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.b_coeff-NTuple{5, Int64}" href="#CamiXon.b_coeff-NTuple{5, Int64}"><code>CamiXon.b_coeff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">b_coeff(k::Int, l::Int, ml::Int, l′::Int, ml′::Int)</code></pre><p>Angular coefficient for the <em>exchange</em> Coulomb integral:</p><p class="math-container">\[b^{k}(lm_{l};l^{\prime}m_{l^{\prime}})=(2l+1)(2l^{\prime}+1)
\left(\begin{array}{ccc}
l &amp; k &amp; l^{\prime}\\
0 &amp; 0 &amp; 0
\end{array}\right)^{2}\left(\begin{array}{ccc}
l &amp; k &amp; l^{\prime}\\
-m_{l} &amp; (m_{l}-m_{l^{\prime}}) &amp; m_{l^{\prime}}
\end{array}\right)^{2}\]</p><p><strong>Example:</strong></p><pre><code class="language-none">b(1,1,1,2,2)
    2//5

b(6,3,2,3,-1)
    1050//20449</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/Coulomb_Integrals.jl#LL53-L76">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>UF(k::Int, Z::Vector{Complex{T}}, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>UG(k::Int, Z1::Vector{Complex{T}}, Z2::Vector{Complex{T}}, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="FITS"><a class="docs-heading-anchor" href="#FITS">FITS</a><a id="FITS-1"></a><a class="docs-heading-anchor-permalink" href="#FITS" title="Permalink"></a></h2><p>FITS stands for &#39;Flexible Image Transport System&#39;. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.</p><p>Within CamiXon only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.</p><p>A FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.</p><p>By the command <code>f = fits_read(filnam)</code> we asign a collection of <code>FITS_HDU</code> objects from the file <code>filnam</code> to the variable <code>f</code>.</p><h3 id="FITS-Types"><a class="docs-heading-anchor" href="#FITS-Types">FITS - Types</a><a id="FITS-Types-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_HDU" href="#CamiXon.FITS_HDU"><code>CamiXon.FITS_HDU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_HDU{T,V}</code></pre><p>Object to hold a single &quot;Header-Data Unit&quot; (HDU).</p><p>The fields are</p><ul><li><code>.filename</code>:  name of the corresponding FITS file (<code>::String</code>)</li><li><code>.hduindex:</code>:  identifier (a file may contain more than one HDU) (<code>:Int</code>)</li><li><code>.header</code>:  the header object where T=FITS_header (<code>::T</code>)</li><li><code>.dataobject</code>:  the data object where V=FITS_data (<code>::V</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_objects.jl#LL3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_header" href="#CamiXon.FITS_header"><code>CamiXon.FITS_header</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_header</code></pre><p>Object to hold the header information of a <a href="#CamiXon.FITS_HDU"><code>FITS_HDU</code></a>.</p><p>The fields are:</p><ul><li><code>.hduindex</code>:  identifier (a file may contain more than one HDU) (<code>::Int</code>)</li><li><code>.records</code>:  the header formated as an array of strings of 80 ASCII characters (<code>::Array{String,1}</code>)</li><li><code>.keys</code>:  <code>keys[i]</code> - key corresponding to <code>records[i]</code> (record of index <code>i</code>)  (<code>::Array{String,1}</code>)</li><li><code>.values</code>:  <code>value[i]</code> - corresponding to <code>records[i]</code>  (<code>::Array{Any,1}</code>)</li><li><code>.comments</code>:  <code>comments[i]</code> - comment corresponding to <code>records[i]</code> (<code>::String</code>)</li><li><code>.dict</code>:  Dictionary <code>key[i] =&gt; value[i]</code> (<code>::Dict{String,Any}</code>)</li><li><code>.maps</code>:  Dictionary <code>key[i] =&gt; i</code> (<code>::Dict{String,Int}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_objects.jl#LL47-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_data" href="#CamiXon.FITS_data"><code>CamiXon.FITS_data</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_data</code></pre><p>Object to hold the data of the <a href="#CamiXon.FITS_HDU"><code>FITS_HDU</code></a> of given <code>hduindex</code> and <code>hdutype</code>.</p><p>The fields are:</p><ul><li><code>.hduindex</code>:  identifier (a file may contain more than one HDU) (<code>::Int</code>)</li><li><code>.hdutype</code>:  accepted types are &#39;PRIMARY&#39;, &#39;IMAGE&#39; and &#39;TABLE&#39; (<code>::String</code>)</li><li><code>.data</code>:  in the from appropriate for the <code>hdutype</code> (::Any)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_objects.jl#LL75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_table" href="#CamiXon.FITS_table"><code>CamiXon.FITS_table</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_table</code></pre><p>Object to hold the data of a <code>TABLE HDU</code> (a <a href="#CamiXon.FITS_HDU"><code>FITS_HDU</code></a> for ASCII tables). It contains the data in the form of records (rows) of ASCII strings.</p><p>The fields are:</p><ul><li><code>.hduindex</code>:  identifier (a file may contain more than one HDU) (<code>::Int</code>)</li><li><code>.rows</code>:  the table formated as an array of rows of ASCII strings (<code>::Array{String,1}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_objects.jl#LL96-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_name" href="#CamiXon.FITS_name"><code>CamiXon.FITS_name</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_name</code></pre><p>FITS object to hold the decomposed name of a .fits file.</p><p>The fields are:</p><ul><li><code>.name</code>:  for &#39;p#.fits&#39; this is &#39;p#.fits&#39; (<code>::String</code>)</li><li><code>.prefix</code>:  for &#39;p#.fits&#39; this is &#39;p&#39; (<code>::String</code>)</li><li><code>.numerator</code>:  for &#39;p#.fits&#39; this is &#39;#&#39;, a serial number (e.g., &#39;3&#39;) or a range (e.g., &#39;3-7&#39;) (<code>::String</code>)</li><li><code>.extension</code>:  for &#39;p#.fits&#39; this is &#39;.fits&#39; (<code>::String</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_objects.jl#LL25-L35">source</a></section></article><h3 id="FITS-HDU-Methods"><a class="docs-heading-anchor" href="#FITS-HDU-Methods">FITS - HDU Methods</a><a id="FITS-HDU-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-HDU-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_info-Tuple{FITS_HDU}" href="#CamiXon.fits_info-Tuple{FITS_HDU}"><code>CamiXon.fits_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_info(hdu)</code></pre><p>Print metafinformation and data of given <code>FITS_HDU</code></p><p><strong>Example:</strong></p><pre><code class="language-none">strExample = &quot;remove.fits&quot;
data = [11,21,31,12,22,23,13,23,33]
data = reshape(data,(3,3,1))
fits_create(strExample, data; protect=false)

f = fits_read(strExample)
fits_info(f[1])

  File: remove.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Int64
  Datasize: (3, 3, 1)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  BITPIX  =                   64 / number of bits per data pixel
  NAXIS   =                    3 / number of data axes
  NAXIS1  =                    3 / length of data axis 1
  NAXIS2  =                    3 / length of data axis 2
  NAXIS3  =                    1 / length of data axis 3
  BZERO   =                  0.0 / offset data range to that of unsigned integer
  BSCALE  =                  1.0 / default scaling factor
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  END

  3×3×1 Array{Int64, 3}:
  [:, :, 1] =
   11  12  13
   21  22  23
   31  23  33
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL208-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.parse_FITS_TABLE-Tuple{FITS_HDU}" href="#CamiXon.parse_FITS_TABLE-Tuple{FITS_HDU}"><code>CamiXon.parse_FITS_TABLE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_FITS_TABLE(hdu)</code></pre><p>Parse <code>FITS_TABLE</code> (ASCII table) into a Vector of its columns for further processing by the user. Default formatting in ISO 2004 FORTRAN data format specified by keys &quot;TFORMS1&quot; - &quot;TFORMSn&quot;). Display formatting in ISO 2004 FORTRAN data format (&quot;TDISP1&quot; - &quot;TDISPn&quot;) prepared for user editing.</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample = &quot;example.fits&quot;
data = [10, 20, 30]
fits_create(strExample, data; protect=false)

t1 = Float16[1.01E-6,2.0E-6,3.0E-6,4.0E-6,5.0E-6]
t2 = [0x0000043e, 0x0000040c, 0x0000041f, 0x0000042e, 0x0000042f]
t3 = [1.23,2.12,3.,4.,5.]
t4 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]
t5 = [&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;,&quot;dddd&quot;,&quot;ABCeeaeeEEEEEEEEEEEE&quot;]
data = [t1,t2,t3,t4,t5]
fits_extend(strExample, data, &quot;TABLE&quot;)

f = fits_read(strExample)
d = f[2].header.dict
d = [get(d,&quot;TFORM$i&quot;,0) for i=1:5]; println(strip.(d))
  SubString{String}[&quot;&#39;E6.1    &#39;&quot;, &quot;&#39;I4      &#39;&quot;, &quot;&#39;F4.2    &#39;&quot;, &quot;&#39;A1      &#39;&quot;, &quot;&#39;A20     &#39;&quot;]

f[2].dataobject.data                            # this is the table hdu
  5-element Vector{String}:
   &quot;1.0e-6 1086 1.23 a a                    &quot;
   &quot;2.0e-6 1036 2.12 b bb                   &quot;
   &quot;3.0e-6 1055 3.0  c ccc                  &quot;
   &quot;4.0e-6 1070 4.0  d dddd                 &quot;
   &quot;5.0e-6 1071 5.0  e ABCeeaeeEEEEEEEEEEEE &quot;

parse_FITS_TABLE(f[2])
  5-element Vector{Vector{T} where T}:
   [1.0e-6, 2.0e-6, 3.0e-6, 4.0e-6, 5.0e-6]
   [1086, 1036, 1055, 1070, 1071]
   [1.23, 2.12, 3.0, 4.0, 5.0]
   [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
   [&quot;a                   &quot;, &quot;bb                  &quot;, &quot;ccc                 &quot;, &quot;dddd                &quot;, &quot;ABCeeaeeEEEEEEEEEEEE&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL743-L785">source</a></section></article><h3 id="FITS-File-Methods"><a class="docs-heading-anchor" href="#FITS-File-Methods">FITS - File Methods</a><a id="FITS-File-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-File-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.cast_FITS_name-Tuple{String}" href="#CamiXon.cast_FITS_name-Tuple{String}"><code>CamiXon.cast_FITS_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cast_FITS_name(filename::String)</code></pre><p>Decompose the FITS filename &#39;filnam.fits&#39; into its name, prefix, numerator and extension.</p><p><strong>Examples:</strong></p><pre><code class="language-none">strExample = &quot;T23.01.fits&quot;
f = cast_FITS_name(strExample)
FITS_name(&quot;T23.01&quot;, &quot;T23.&quot;, &quot;01&quot;, &quot;.fits&quot;)

f.name, f.prefix, f.numerator, f.extension
(&quot;T23.01&quot;, &quot;T23.&quot;, &quot;01&quot;, &quot;.fits&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_private_sector.jl#LL7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_combine-Tuple{String, String}" href="#CamiXon.fits_combine-Tuple{String, String}"><code>CamiXon.fits_combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_combine(strFirst, strLast [; protect=true])</code></pre><p>Copy &quot;filenameFirst&quot; to &quot;filenameLast&quot; (with mandatory &quot;.fits&quot; extension)</p><p>Key:</p><ul><li><code>protect::Bool</code>: overwrite protection</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">fits_combine(&quot;T01.fits&quot;, &quot;T22.fits&quot;)
  &#39;T01-T22.fits&#39;: file created</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_copy" href="#CamiXon.fits_copy"><code>CamiXon.fits_copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fits_copy(filenameA [, filenameB=&quot;&quot; [; protect=true]])</code></pre><p>Copy &quot;filenameA&quot; to &quot;filenameB&quot; (with mandatory &quot;.fits&quot; extension) Key:</p><ul><li><code>protect::Bool</code>: overwrite protection</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">fits_copy(&quot;T01.fits&quot;)
  &#39;T01.fits&#39; was saved as &#39;T01 - Copy.fits&#39;

fits_copy(&quot;T01.fits&quot;, &quot;T01a.fits&quot;)
  FitsError: &#39;T01a.fits&#39; in use (set &#39;;protect=false&#39; to lift overwrite protection)

fits_copy(&quot;T01.fits&quot;, &quot;T01a.fits&quot;; protect=false)
  &#39;T01.fits&#39; was saved as &#39;T01a.fits&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_create" href="#CamiXon.fits_create"><code>CamiXon.fits_create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fits_create(filename [, data [; protect=true]])</code></pre><p>Create FITS file of given filename [, optional data block [, default overwrite protection]] and return Array of HDUs. Key:</p><ul><li><code>protect::Bool</code>: overwrite protection</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">strExample = &quot;minimal.fits&quot;
fits_create(strExample;protect=false)

f = fits_read(strExample)
a = f[1].dataobject.data
b = f[1].header.keys
println(a);println(b)
  Any[]
  [&quot;SIMPLE&quot;, &quot;NAXIS&quot;, &quot;EXTEND&quot;, &quot;COMMENT&quot;, &quot;END&quot;]

strExample = &quot;remove.fits&quot;
data = [11,21,31,12,22,23,13,23,33]
data = reshape(data,(3,3,1))
fits_create(strExample, data; protect=false)

f = fits_read(strExample)
fits_info(f[1])

  File: remove.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Int64
  Datasize: (3, 3, 1)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  BITPIX  =                   64 / number of bits per data pixel
  NAXIS   =                    3 / number of data axes
  NAXIS1  =                    3 / length of data axis 1
  NAXIS2  =                    3 / length of data axis 2
  NAXIS3  =                    1 / length of data axis 3
  BZERO   =                  0.0 / offset data range to that of unsigned integer
  BSCALE  =                  1.0 / default scaling factor
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  END

  3×3×1 Array{Int64, 3}:
  [:, :, 1] =
   11  12  13
   21  22  23
   31  23  33</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL115-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_extend" href="#CamiXon.fits_extend"><code>CamiXon.fits_extend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fits_extend(filename, data_extend, hdutype=&quot;IMAGE&quot;)</code></pre><p>Extend the FITS file of given filename with the data of <code>hdutype</code> from <code>data_extend</code>  and return Array of HDUs.</p><p><strong>Examples:</strong></p><pre><code class="language-none">strExample = &quot;test_example.fits&quot;
data = [0x0000043e, 0x0000040c, 0x0000041f]
fits_create(strExample, data, protect=false)

f = fits_read(strExample)
a = Float16[1.01E-6,2.0E-6,3.0E-6,4.0E-6,5.0E-6]
b = [0x0000043e, 0x0000040c, 0x0000041f, 0x0000042e, 0x0000042f]
c = [1.23,2.12,3.,4.,5.]
d = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]
e = [&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;,&quot;dddd&quot;,&quot;ABCeeaeeEEEEEEEEEEEE&quot;]
data = [a,b,c,d,e]
fits_extend(strExample, data, &quot;TABLE&quot;)

f = fits_read(strExample)
f[2].dataobject.data
  5-element Vector{String}:
   &quot;1.0e-6 1086 1.23 a a                    &quot;
   &quot;2.0e-6 1036 2.12 b bb                   &quot;
   &quot;3.0e-6 1055 3.0  c ccc                  &quot;
   &quot;4.0e-6 1070 4.0  d dddd                 &quot;
   &quot;5.0e-6 1071 5.0  e ABCeeaeeEEEEEEEEEEEE &quot;

rm(strExample); f = data = a = b = c = d = e = nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL324-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_read-Tuple{String}" href="#CamiXon.fits_read-Tuple{String}"><code>CamiXon.fits_read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_read(filename)</code></pre><p>Read FITS file and return Array of <code>FITS_HDU</code>s</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample = &quot;minimal.fits&quot;
fits_create(strExample;protect=false)

f = fits_read(strExample)
f[1].dataobject.data
  Any[]

rm(strExample); f = nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL273-L288">source</a></section></article><h3 id="FITS-Key-Methods"><a class="docs-heading-anchor" href="#FITS-Key-Methods">FITS - Key Methods</a><a id="FITS-Key-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-Key-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_add_key-Tuple{String, Int64, String, Real, String}" href="#CamiXon.fits_add_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_add_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_add_key(filename, hduindex, key, value, comment)</code></pre><p>Add a header record of given &#39;key, value and comment&#39; to &#39;HDU[hduindex]&#39; of file with name &#39;filename&#39;</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;FITS dataset may contain extension&quot;)

f = fits_read(strExample)
fits_info(f[1])

  File: minimal.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Any
  Datasize: (0,)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  NAXIS   =                    0 / number of data axes
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  KEYNEW1 =                    T / FITS dataset may contain extension
  END

  Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL413-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_delete_key-Tuple{String, Int64, String}" href="#CamiXon.fits_delete_key-Tuple{String, Int64, String}"><code>CamiXon.fits_delete_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_delete_key(filename, hduindex, key)</code></pre><p>Delete a header record of given <code>key</code>, <code>value</code> and <code>comment</code> to <code>FITS_HDU[hduindex]</code> of file with name  &#39;filename&#39;</p><p><strong>Examples:</strong></p><pre><code class="language-none">strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;this is record 5&quot;)

f = fits_read(strExample)
get(f[1].header.maps,&quot;KEYNEW1&quot;,0)
  5

fits_delete_key(strExample, 1, &quot;KEYNEW1&quot;)

f = fits_read(strExample)
get(f[1].header.maps,&quot;KEYNEW1&quot;,0)
  0

fits_delete_key(filnam, 1, &quot;NAXIS&quot;)
 &#39;NAXIS&#39;: cannot be deleted (key protected under FITS standard)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL573-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_edit_key-Tuple{String, Int64, String, Real, String}" href="#CamiXon.fits_edit_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_edit_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_edit_key(filename, hduindex, key, value, comment)</code></pre><p>Edit a header record of given &#39;key, value and comment&#39; to &#39;HDU[hduindex]&#39; of file with name &#39;filename&#39;</p><p><strong>Example:</strong></p><pre><code class="language-none">data = DateTime(&quot;2020-01-01T00:00:00.000&quot;)
strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;this is record 5&quot;)
fits_edit_key(strExample, 1, &quot;KEYNEW1&quot;, data, &quot;record 5 changed to a DateTime type&quot;)

f = fits_read(strExample)
fits_info(f[1])

  File: minimal.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Any
  Datasize: (0,)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  NAXIS   =                    0 / number of data axes
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  KEYNEW1 = &#39;2020-01-01T00:00:00&#39; / record 5 changed to a DateTime type
  END

  Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL489-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_rename_key-Tuple{String, Int64, String, String}" href="#CamiXon.fits_rename_key-Tuple{String, Int64, String, String}"><code>CamiXon.fits_rename_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_rename_key(filename, hduindex, keyold, kewnew)</code></pre><p>Rename the key of a header record of file with name &#39;filename&#39;</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;this is record 5&quot;)
fits_rename_key(strExample, 1, &quot;KEYNEW1&quot;,  &quot;KEYNEW2&quot;)

f = fits_read(strExample)
fits_info(f[1])

  File: minimal.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Any
  Datasize: (0,)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  NAXIS   =                    0 / number of data axes
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  KEYNEW2 =                    T / this is record 5
  END

  Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/fits_public_sector.jl#LL654-L684">source</a></section></article><h2 id="FORTRAN"><a class="docs-heading-anchor" href="#FORTRAN">FORTRAN</a><a id="FORTRAN-1"></a><a class="docs-heading-anchor-permalink" href="#FORTRAN" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FORTRAN_format" href="#CamiXon.FORTRAN_format"><code>CamiXon.FORTRAN_format</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FORTRAN_format</code></pre><p>Object to hold a FORTRAN format specifier decomposed in its fields.</p><p>Accepted <em>datatype specifiers</em> are:  <code>Aw</code>,  <code>Iw</code>,  <code>Fw.d</code>,  <code>Ew.d</code>,  <code>Dw.d</code></p><p>Accepted <em>output formating specifiers</em> are: <code>Aw</code>,  <code>Iw.m</code>,  <code>Bw.m</code>,  <code>Ow.m</code>, <code>Zw.m</code>,  <code>Fw.d</code>,  <code>Ew.dEe</code>,  <code>ENw.d</code>,  <code>ESw.d</code>,  <code>Gw.dEe</code>,  <code>Dw.dEe</code>. Notation: <code>w</code> - width, <code>m</code> (optional) - minimum number of digits, <code>d</code> - number of digits to right of decimal, <code>e</code> - number of digits in exponent <code>N</code>/<code>S</code> (optional) indicates engineering/scientific formating of the <code>E</code> type.</p><p>The fields are:</p><ul><li><code>.Type</code>: primary FORTRAN datatype (<code>::String</code>)</li><li><code>.TypeChar</code>: primary FORTRAN datatype character (<code>::Char</code>)</li><li><code>.EngSci</code>: secundary datatype character - N for engineering/ S for scientific (<code>::Union{Char,Nothing}</code>)</li><li><code>.width</code>: width of numeric field (<code>::Int</code>)</li><li><code>.nmin</code>: minimum number of digits displayed (<code>::Int</code>)</li><li><code>.ndec</code>: number of digits to right of decimal (<code>::Int</code>)</li><li><code>.nexp</code>: number of digits in exponent (<code>::Int</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/FORTRAN.jl#LL3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.cast_FORTRAN_format-Tuple{String}" href="#CamiXon.cast_FORTRAN_format-Tuple{String}"><code>CamiXon.cast_FORTRAN_format</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cast_FORTRAN_format(format::String)</code></pre><p>Decompose the format specifier <code>format</code> into its fields and cast this into the <a href="#CamiXon.FORTRAN_format"><code>FORTRAN_format</code></a> object. Allowed format specifiers are of the types: <code>Aw</code>, <code>Iw.m</code>, <code>Bw.m</code>, <code>Ow.m</code>, <code>Zw.m</code>, <code>Fw.d</code>, <code>Ew.dEe</code>, <code>ENw.d</code>, <code>ESw.d</code>, <code>Gw.dEe</code>, <code>Dw.dEe</code>, with: <code>w</code> - width, <code>m</code>(optional) - minimum number of digits, <code>d</code> - number of digits to right of decimal, <code>e</code> - number of digits in exponent; <code>N</code>/<code>S</code> (optional) indicates engineering/scientific formating of the <code>E</code> type.</p><p><strong>Examples:</strong></p><pre><code class="language-none">f = cast_FORTRAN_format(&quot;I10&quot;)
  FORTRAN_format(&quot;Iw&quot;, &#39;I&#39;, nothing, 10, 0, 0, 0)

f = cast_FORTRAN_format(&quot;I10.12&quot;)
  FORTRAN_format(&quot;Iw.m&quot;, &#39;I&#39;, nothing, 10, 12, 0, 0)

f = cast_FORTRAN_format(&quot;E10.5E3&quot;)
  FORTRAN_format(&quot;Ew.dEe&quot;, &#39;E&#39;, nothing, 10, 0, 5, 3)

f.Type, f.TypeChar, f.EngSci, f.width, f.nmin, f.ndec, f.nexp
  (&quot;Ew.dEe&quot;, &#39;E&#39;, nothing, 10, 0, 5, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/FORTRAN.jl#LL39-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.cast_FORTRAN_datatype-Tuple{String}" href="#CamiXon.cast_FORTRAN_datatype-Tuple{String}"><code>CamiXon.cast_FORTRAN_datatype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cast_FORTRAN_datatype(format::String)</code></pre><p>Decompose the format specifier <code>format</code> into its fields and cast this into the <a href="#CamiXon.FORTRAN_format"><code>FORTRAN_format</code></a> object. Allowed format specifiers are of the types: <code>Aw</code>, <code>Iw</code>, <code>Fw.d</code>, <code>Ew.d</code>, <code>Dw.d</code>, where: <code>w</code> - width, <code>d</code> - number of digits to right of decimal point.</p><p><strong>Examples:</strong></p><pre><code class="language-none">f = cast_FORTRAN_datatype(&quot;I10&quot;)
  FORTRAN_format(&quot;Iw&quot;, &#39;I&#39;, nothing, 10, 0, 0, 0)

f = cast_FORTRAN_datatypet(&quot;F10.4&quot;)
  FORTRAN_format(&quot;Fw.d&quot;, &#39;F&#39;, nothing, 10, 0, 4, 0)

f = cast_FORTRAN_datatype(&quot;E10.5&quot;)
  FORTRAN_format(&quot;Ew.d&quot;, &#39;E&#39;, nothing, 10, 0, 5, 0)

f.Type, f.TypeChar, f.EngSci, f.width, f.nmin, f.ndec, f.nexp
  (&quot;Ew.d&quot;, &#39;E&#39;, nothing, 10, 0, 5, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/FORTRAN.jl#LL113-L134">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.step125-Tuple{Real}" href="#CamiXon.step125-Tuple{Real}"><code>CamiXon.step125</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step125(x)</code></pre><p>Step used for deviding the number x in steps according to 1-2-5 scheme</p><p><strong>Examples:</strong></p><pre><code class="language-none">step125.([5,10,21.3,50,100.1])
5-element Vector{Int64}:
  1
  2
  5
 10
 20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/plot_public_sector.jl#LL3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.select125-Tuple{Any}" href="#CamiXon.select125-Tuple{Any}"><code>CamiXon.select125</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">select125(x)</code></pre><p>Select elements of the collection x by index according to 1-2-5 scheme</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [1,2,4,6,8,10,13,16,18,20,40,60,80,100]
select125(x)
 [2, 6, 10, 16, 20, 60, 100]

x = string.(x)
select125(x)
 [&quot;2&quot;, &quot;6&quot;, &quot;10&quot;, &quot;16&quot;, &quot;20&quot;, &quot;60&quot;, &quot;100&quot;]

x = 1:100
select125(x)
 [20, 40, 60, 80, 100]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/plot_public_sector.jl#LL31-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.steps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">steps(x)</code></pre><p>Heatmap range transformation for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [4,2,6]
steps(x)
 [0, 4, 6, 12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/plot_public_sector.jl#LL78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepcenters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stepcenters(x)</code></pre><p>Stepcenter positions for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [4,2,6]
stepcenters(x)
 [2.0, 5.0, 9.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/plot_public_sector.jl#LL99-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepedges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stepedges(x)</code></pre><p>Stepedges for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [4,2,6]
stepedges(x)
 [0, 4, 6, 12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/plot_public_sector.jl#LL120-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.edges" href="#CamiXon.edges"><code>CamiXon.edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edges(px [, Δx[, x0]])</code></pre><p>Heatmap range transformation from pixel coordinates to physical coordinates, with pixelsize Δx and offset x0, both in physical units.</p><p><strong>Examples:</strong></p><pre><code class="language-">px = 1:5
Δx = 2.5
x0 = 2.5
edges(px)
 [0.5, 1.5, 2.5, 3.5, 4.5]

edges(px, Δx)
 [1.25, 3.75, 6.25, 8.75, 11.25]

edges(px, Δx, x0)
 [-1.25, 1.25, 3.75, 6.25, 8.75]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/plot_public_sector.jl#LL54-L73">source</a></section></article><h2 id="Search-and-conversion-tools"><a class="docs-heading-anchor" href="#Search-and-conversion-tools">Search and conversion tools</a><a id="Search-and-conversion-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Search-and-conversion-tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_all(A [,a...]; count=false)</code></pre><p>A: string/array of elements of the same type</p><p>default   : Array containing the index (indices) of selected elements of A (default: all elements)</p><p>count=true: The number of indices found for selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="language-none">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;
find_all(A) == find_all(B) == find_all(str)
true

find_all(A,:📌)
1-element Array{Array{Int64,1},1}:
 [2, 4]

find_all(str)
4-element Array{Array{Int64,1},1}:
 [1]
 [2, 4]
 [3]
 [5]

find_all(A; count=true)
4-element Array{Int64,1}:
 1
 2
 1
 1

str = &quot;📑📌📢📌📞&quot;
find_all(str,&#39;📌&#39;)
1-element Array{Array{Int64,1},1}:
 [2, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/search_algorithms.jl#LL1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_first(A [,a...]; dict=false)</code></pre><p>The first index of selected Array element</p><p>A: string/array of elements of the same type</p><p>default  : Array containing the first index (indices) of selected elements of A (default: all elements)</p><p>dict=true: Dict for the first index (indices) of selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="language-none">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;

find_first(A) == find_first(B) == find_first(str)
true

find_first(A,:📌)
1-element Array{Array{Int64,1},1}:
 2

find_last(A,:📌; dict=true)
1-element Array{Pair{Symbol,Int64},1}:
 :📌 =&gt; 2

find_last(A; dict=true)
4-element Array{Pair{Symbol,Int64},1}:
 :📑 =&gt; 1
 :📌 =&gt; 2
 :📢 =&gt; 3
 :📞 =&gt; 5

find_first(str)
4-element Array{Int64,1}:
 1
 2
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/search_algorithms.jl#LL53-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_last(A [,a...]; dict=false)</code></pre><p>The last index of selected Array element</p><p>A: string/array of elements of the same type</p><p>default  : Array containing the lasst index (indices) of selected elements of A (default: all elements)</p><p>dict=true: Dict for the lasst index (indices) of selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="language-none">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;
find_last(A) == find_first(B) == find_first(str)
true

find_last(A,:📌)
1-element Array{Array{Int64,1},1}:
 4

find_last(A,:📌; dict=true)
1-element Array{Pair{Symbol,Int64},1}:
 :📌 =&gt; 4

find_last(A; dict=true)
4-element Array{Pair{Symbol,Int64},1}:
 :📑 =&gt; 1
 :📌 =&gt; 4
 :📢 =&gt; 3
 :📞 =&gt; 5

find_last(str)
4-element Array{Int64,1}:
 1
 4
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/search_algorithms.jl#LL106-L146">source</a></section></article><h2 id="Mathematics"><a class="docs-heading-anchor" href="#Mathematics">Mathematics</a><a id="Mathematics-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.bernoulli_numbers-Tuple{Int64}" href="#CamiXon.bernoulli_numbers-Tuple{Int64}"><code>CamiXon.bernoulli_numbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bernoulli_numbers(nmax [, T=Int])</code></pre><p>Bernoulli numbers <span>$B_0,⋯\ B_{nmax}$</span> calculated by repetative use of the recurrence relation</p><p class="math-container">\[    B_n = - \frac{1}{n+1}\sum_{k=0}^{n-1}\frac{(n+1)!}{k!(n+1-k)}B_k.\]</p><p>Special numbers: <span>$B_0=1,\ B_1=-1/2,\ B_{2n+1}=0\ (\rm{for}\ n&gt;1)$</span>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">bernoulli_numbers(10)
11-element Vector{Rational{Int64}}:
  1//1
 -1//2
  1//6
  0//1
 -1//30
  0//1
  1//42
  0//1
 -1//30
  0//1
  5//66</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL46-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.canonical_partitions" href="#CamiXon.canonical_partitions"><code>CamiXon.canonical_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">canonical_partitions(n; header=false, reverse=true)</code></pre><p>The canonical partition in integers of the integer n</p><p>header=true : unit patition included in output</p><p><strong>Examples:</strong></p><pre><code class="language-none">canonical_partitions(6; header=true, reverse=false)
6-element Array{Array{Int64,1},1}:
 [6]
 [5, 1]
 [4, 2]
 [3, 3]
 [2, 2, 2]
 [1, 1, 1, 1, 1, 1]

canonical_partitions(6; header=true)
6-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1]
 [2, 2, 2]
 [3, 3]
 [4, 2]
 [5, 1]
 [6]

canonical_partitions(6)
5-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1]
 [2, 2, 2]
 [3, 3]
 [4, 2]
 [5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL402-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.factorialbig-Tuple{Int64}" href="#CamiXon.factorialbig-Tuple{Int64}"><code>CamiXon.factorialbig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factorialbig(n::Int)</code></pre><p>The product of all <em>positive</em> integers less than or equal to <code>n</code>,</p><p class="math-container">\[!(n)=n(n-1)(n-2)⋯1.\]</p><p>By definition</p><p class="math-container">\[!(0)=1\]</p><p>For <em>negative</em> integers the factorial is zero.</p><p><strong>Examples:</strong></p><pre><code class="language-none">factorialbig(20)==factorial(20)
    true

factorialbig(21)
    51090942171709440000

factorial(21)
    OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL114-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.faulhaber_polynom-Tuple{Int64}" href="#CamiXon.faulhaber_polynom-Tuple{Int64}"><code>CamiXon.faulhaber_polynom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">faulhaber_polynom(p [, T=Int])</code></pre><p>Vector representation of the Faulhaber polynomial of degree <span>$p$</span>,</p><p class="math-container">\[    F(n,p)=\frac{1}{p}\sum_{j=1}^{p}{\binom {p}{p-j}}B_{p-j}n^{j}.\]</p><p><span>$F(n,p)=$</span> <code>polynomial(c,n)</code>, where <span>$c=[c_0,⋯\ c_p]$</span> is the coefficient vector, with</p><p class="math-container">\[    c_0=0,\ c_j=\frac{1}{p}{\binom {p}{p-j}}B_{p-j},\]</p><p>with <span>$j∈\{ 1,⋯\ p\}$</span>. The <span>$B_0,⋯\ B_{p-1}$</span> are Bernoulli numbers (but with <span>$B_1=+\frac{1}{2}$</span> rather than <span>$-\frac{1}{2}$</span>).</p><p><strong>Example:</strong></p><pre><code class="language-none">faulhaber_polynom(6)
7-element Vector{Rational{Int64}}:
  0//1
  0//1
 -1//12
  0//1
  5//12
  1//2
  1//6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL148-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.faulhaber_summation-Tuple{Int64, Int64}" href="#CamiXon.faulhaber_summation-Tuple{Int64, Int64}"><code>CamiXon.faulhaber_summation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">faulhaber_summation(n, p [, T=Int])</code></pre><p>Sum of powers of natural numbers <span>$1,⋯\ n$</span>,</p><p class="math-container">\[    FS(n,p)=\sum_{k=1}^{n}k^{p}=F(n,p+1).\]</p><p>where <span>$F(n,p)$</span> is the Faulhamer polynomial of degree <span>$p$</span>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">faulhaber_summation(5,1)
 15

faulhaber_summation(3,60; T=BigInt)
  42391158276369125018901280178</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL207-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.harmonic_number-Tuple{Int64, Int64}" href="#CamiXon.harmonic_number-Tuple{Int64, Int64}"><code>CamiXon.harmonic_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">harmonic_number(n, p [, T=Int])</code></pre><p>Sum of the <span>$p_{th}$</span> power of reciprocals of the first <span>$n$</span> numbers</p><p class="math-container">\[    H_{n,p}=\sum_{k=1}^{n}\frac{1}{k^p}.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">harmonic_number(12, 3)
 25535765062457//21300003648000

harmonic_number(12, 5; T=BigInt)
 16971114472329088045481//16366888723117363200000

harmonic_number(12, -3) == faulhaber_summation(12, 3)
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL311-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.harmonic_number-Tuple{Int64}" href="#CamiXon.harmonic_number-Tuple{Int64}"><code>CamiXon.harmonic_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">harmonic_number(n [, T=Int])</code></pre><p>Sum of the reciprocals of the first <span>$n$</span> natural numbers</p><p class="math-container">\[    H_n=\sum_{k=1}^{n}\frac{1}{k}.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">o = [harmonic_number(i) for i=1:10]; println(o)
 [1//1, 3//2, 11//6, 25//12, 137//60, 49//20, 363//140, 761//280, 7129//2520, 7381//2520]

harmonic_number(60; T=BigInt)
 15117092380124150817026911//3230237388259077233637600

harmonic_number(12) == harmonic_number(12, 1)
 true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL263-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.integer_partitions" href="#CamiXon.integer_partitions"><code>CamiXon.integer_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">integer_partitions(n [,m]; transpose=false, count=false)</code></pre><p>default              : The integer partitions of n</p><p>count=true           : The number of integer partitions of n</p><p>transpose=false/true : for m&gt;0 restricted to partitions with maximum part/length m</p><p>definitions:</p><p>The integer partition of the positive integer n is a nonincreasing sequence of positive integers p1, p2,... pk whose sum is n.</p><p>The elements of the sequence are called the parts of the partition.</p><p><strong>Examples:</strong></p><pre><code class="language-none">integer_partitions(7)
15-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1, 1]
 [2, 2, 2, 1]
 [3, 3, 1]
 [4, 3]
 [5, 2]
 [6, 1]
 [7]
 [2, 2, 1, 1, 1]
 [3, 2, 2]
 [4, 2, 1]
 [5, 1, 1]
 [2, 1, 1, 1, 1, 1]
 [3, 2, 1, 1]
 [4, 1, 1, 1]
 [3, 1, 1, 1, 1]

integer_partitions(7; count=true)
15

integer_partitions(7,4; count=true)
3

integer_partitions(7,4)
3-element Array{Array{Int64,1},1}:
 [4, 3]
 [4, 2, 1]
 [4, 1, 1, 1]

integer_partitions(7,4; transpose=true)
3-element Array{Array{Int64,1},1}:
 [2, 2, 2, 1]
 [3, 2, 1, 1]
 [4, 1, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL490-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.log10_characteristic_power-Tuple{Any}" href="#CamiXon.log10_characteristic_power-Tuple{Any}"><code>CamiXon.log10_characteristic_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log10_characteristic_power(x)</code></pre><p>characteristic power-of-10 of the number x</p><p><strong>Examples:</strong></p><pre><code class="language-none">log10_characteristic_power.([3,30,300])
3-element Vector{Int64}:
 0
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL578-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.log10_mantissa-Tuple{Any}" href="#CamiXon.log10_mantissa-Tuple{Any}"><code>CamiXon.log10_mantissa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log10_mantissa(x)</code></pre><p>log10 mantissa of the number x</p><p><strong>Examples:</strong></p><pre><code class="language-none">log10_mantissa.([3,30,300])
3-element Vector{Float64}:
 0.47712125471966244
 0.4771212547196624
 0.4771212547196626</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL594-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.permutations_unique_count-Tuple{Vector{Vector{Int64}}, Int64}" href="#CamiXon.permutations_unique_count-Tuple{Vector{Vector{Int64}}, Int64}"><code>CamiXon.permutations_unique_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permutations_unique_count(p::Array{Array{Int64,1},1}, i::Int)</code></pre><p>Number of unique permutations of the subarray <span>$p[i]$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">p = [[1,2,3],[2,3,1,4,3]]
permutations_unique_count(p,2)
 60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL689-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.pascal_triangle-Tuple{Int64}" href="#CamiXon.pascal_triangle-Tuple{Int64}"><code>CamiXon.pascal_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pascal_triangle(nmax [, T=Int])</code></pre><p>Pascal triangle of binomial coefficients <span>$\binom{n}{k}$</span> for <span>$n=0,\ 1,⋯\ nmax$</span></p><p><strong>Example:</strong></p><pre><code class="language-none">pascal_triangle(5)
6-element Vector{Vector{Int64}}:
 [1]
 [1, 1]
 [1, 2, 1]
 [1, 3, 3, 1]
 [1, 4, 6, 4, 1]
 [1, 5, 10, 10, 5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL611-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.pascal_next-Tuple{Vector{Int64}}" href="#CamiXon.pascal_next-Tuple{Vector{Int64}}"><code>CamiXon.pascal_next</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pascal_next(nmax)</code></pre><p>Next row of Pascal triangle</p><p><strong>Example:</strong></p><pre><code class="language-none">a = [1, 4, 6, 4, 1]
pascal_next(a)
 [1, 5, 10, 10, 5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL662-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real" href="#CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>CamiXon.pochhammer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pochhammer(x::T, p::Int) where T&lt;:Real</code></pre><p>Pochhammer symbol <span>$(x)_{p}$</span> for integral <span>$p$</span>,</p><p class="math-container">\[(x)_{p}=\begin{cases}
1 &amp; p=0\\
x(x+1)(x+2)⋯(x+p-1) &amp; p&gt;0
\end{cases}\]</p><p>Note that <span>$(x)_{p}=0$</span> for <span>$x=0,-1,⋯\ -(p-1)$</span></p><p><strong>Examples:</strong></p><pre><code class="language-none">x = [-4,-3,-2,-1, 0, 1, 2 , 3, 4]
pochhammer.(x,5) == [0, 0, 0, 0, 0, 120, 720, 2520, 6720]
  true

pochhammer.(x,0) == [1, 1, 1, 1, 1, 1, 1, 1, 1]
  true

o = [pochhammer.([x for x=0:-1:-p],p) for p=0:5]
println(&quot;non-positive integer x = 0,⋯\ -p:&quot;)
for p=0:5
    println(&quot;p = $p: $(o[p+1])&quot;)
end
  non-positive integer x = 0,⋯\ -p:
  p = 0: [1]
  p = 1: [0, -1]
  p = 2: [0, 0, 2]
  p = 3: [0, 0, 0, -6]
  p = 4: [0, 0, 0, 0, 24]
  p = 5: [0, 0, 0, 0, 0, -120]

 o = [pochhammer.([x for x=0:p],p) for p=0:5]
 println(&quot;non-negative integer x = 0,⋯\  p:&quot;)
 for p=0:5
     println(&quot;p = $p: $(o[p+1])&quot;)
 end
   non-negative integer x = 0,⋯\  p:
   p = 0: [1]
   p = 1: [0, 1]
   p = 2: [0, 2, 6]
   p = 3: [0, 6, 24, 60]
   p = 4: [0, 24, 120, 360, 840]
   p = 5: [0, 120, 720, 2520, 6720, 15120]

x = -1//50
pochhammer(x,20)
  OverflowError: -1491212300990613201 * 449 overflowed for type Int64

x = convert(Rational{BigInt}, -1//50)
pochhammer(x,20)
  -21605762356630090481082546653745369902321614221999//9536743164062500000000000000000000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL715-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.triangle_coefficient-Tuple{Real, Real, Real}" href="#CamiXon.triangle_coefficient-Tuple{Real, Real, Real}"><code>CamiXon.triangle_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">triangle_coefficient(a::Real, b::Real, c::Real)</code></pre><p>Triangle coefficient for a triangle of sides <code>a</code>, <code>b</code> and <code>c</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">triangle_coefficient(3, 4, 5)
    1//180180

triangle_coefficient(1//2, 1, 1.5)
    1//12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL786-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.istriangle-Tuple{Real, Real, Real}" href="#CamiXon.istriangle-Tuple{Real, Real, Real}"><code>CamiXon.istriangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">istriangle(a::Real, b::Real, c::Real)</code></pre><p>Triangle condition for a triangle of sides <code>a</code>, <code>b</code> and <code>c</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">istriangle(3, 4, 5)
    true

istriangle(1//2, 1, 1.5)
    true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL823-L836">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.texp-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Real" href="#CamiXon.texp-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Real"><code>CamiXon.texp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">texp(x::T, a::T, p::Int) where T &lt;: Real</code></pre><p>Taylor expansion of exp(x) about <span>$x = a$</span> up to order p.</p><p class="math-container">\[    \mathsf{texp}(x,a,p) = 1 + (x-a) + \frac{1}{2}(x-a)^2 + ⋯ + \frac{1}{p!}(x-a)^p.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">p = 5
texp(1.0, 0.0, 5)
 2.7166666666666663

texp(1, 0, 5)
 163//60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL879-L895">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.VectorRational" href="#CamiXon.VectorRational"><code>CamiXon.VectorRational</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorRational{T}</code></pre><p>Object to decompose a vector of rational numbers</p><p>The fields are:</p><ul><li><code>.num::Vector{Int}</code>`: vector of normalized numerators</li><li><code>.den::Int</code>: common denominator</li><li><code>.val::Vector{Rational}</code>: vector of rational numbers (simplified = not normalized)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castVectorRational-Tuple{Vector{Rational{Int64}}}" href="#CamiXon.castVectorRational-Tuple{Vector{Rational{Int64}}}"><code>CamiXon.castVectorRational</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castVectorRational(vec::Vector{Rational{T}}) where T&lt;:Union{Int,BigInt}</code></pre><p>Decompose vector of rational numbers.</p><p><strong>Example:</strong></p><pre><code class="language-none">v = [2//3,4//5]
castVectorRational(v)
    VectorRational([10, 12], 15, Rational{Int64}[2//3, 4//5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/mathematics.jl#LL23-L33">source</a></section></article><h3 id="Polynomials"><a class="docs-heading-anchor" href="#Polynomials">Polynomials</a><a id="Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomials" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynomial-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.polynomial-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynomial(coords::Vector{T}, x::T[; deriv=0]) where T&lt;:Number</code></pre><p>Method to evaluate the function <span>$f(x)=\text{polynomial}(c,x)$</span>, where <span>$c=[c_0,⋯\ c_d]$</span> is the vector representation of a polynomial of degree <span>$d$</span>.</p><p class="math-container">\[    \text{polynomial}(c,x)=c_0 + c_1 x + ⋯ + c_d x^d.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords = ones(Int,6)                     # for polynomial of degree 5 with unit coefficients
f0(x) = polynomial(coords,x)             # default
fd(x) = polynomial(coords,x; deriv=1)    # first derivative
fp(x) = polynomial(coords,x; deriv=-1)   # primitive (with zero integration constant)
f0(1)
 6

fd(1)
 15

fp(1)
 49//20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/polynom.jl#LL3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_derivative-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.polynom_derivative-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.polynom_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_derivative(coords)</code></pre><p>Vector representation of the first derivative of the polynomial <code>coords</code>,</p><p class="math-container">\[    p&#39;(c,x)=c_1 + 2 c_2 x + ⋯ + d c_d x^{d-1},\]</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]                 # vector representation of polynomial of degree d=4
polynom_derivative(coords)         # (first) derivative of polynomial `coords`
4-element Vector{Int64}:
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/polynom.jl#LL46-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_derivatives-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.polynom_derivatives-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.polynom_derivatives</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_derivatives(coords::Vector{T}; deriv=0) where T&lt;:Real</code></pre><p>Vector representation of derivatives of the polynomial <code>coords</code>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><code>deriv</code>: derivative of choice; <code>default</code>: <code>coords</code> remains unchanged.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]               # vector representation of a polynomial of degree d=4
polynom_derivatives(coords)      # default no (zero) derivative of polynomial `coords`
5-element Vector{Vector{Int64}}:
 1
 1
 1
 1
 1

polynom_derivatives(coords; deriv=2)        # second derivative of polynomial `coords`
3-element Vector{Int64}:
  2
  6
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/polynom.jl#LL78-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_derivatives_all-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.polynom_derivatives_all-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.polynom_derivatives_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_derivatives_all(coords::Vector{&lt;:Number})</code></pre><p>Vector representation of all nontrivial derivatives of the polynomial <code>coords</code>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]               # vector representation of a polynomial of degree d=4
polynom_derivatives_all(coords)      # `all&#39; (nontrivial) derivatives of polynomial `coords`
5-element Vector{Vector{Int64}}:
 [1, 2, 3, 4]
 [2, 6, 12]
 [6, 24]
 [24]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/polynom.jl#LL121-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_power-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Real" href="#CamiXon.polynom_power-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Real"><code>CamiXon.polynom_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_power(coords, p)</code></pre><p>Vector representation of the polynomial <code>coords</code> raised to the power <code>p</code> which results in a polynomial in a vector space of dimension <span>$p d + 1$</span>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1]             # vector representation of polynomial of degree ``d=2``
polynom_power(coords,2)
5-element Vector{Int64}:
 1
 2
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/polynom.jl#LL159-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_powers-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Real" href="#CamiXon.polynom_powers-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Real"><code>CamiXon.polynom_powers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_powers(coords::Vector{T}, pmax::Int) where T&lt;:Real</code></pre><p>The polynomial <code>coords</code> raised to the powers 1,...,pmax  which results in a collection of polynomials in vector spaces of dimension <span>$d+1$</span> tot <span>$p d + 1$</span>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1]                   # vector representation of polynomial of degree d=2
polynom_powers(coords,3)
3-element Vector{Vector{Int64}}:
 [1, 1, 1]
 [1, 2, 3, 2, 1]
 [1, 3, 6, 7, 6, 3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/polynom.jl#LL199-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_primitive-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.polynom_primitive-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.polynom_primitive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_primitive(coords::Vector{T}) where T&lt;:Real</code></pre><p>Vector representation of the primitive of the polynomial <code>coords</code> which is a polynomial in a vector space of dimension <span>$p d + 1$</span>.</p><p class="math-container">\[    P(c,x)=c_{int} +c_0 x + \frac{1}{2} c_1 x^2 + \frac{1}{3} c_2 x^3 + ⋯ + \frac{1}{d+1} c_d x^{d+1},\]</p><p>The constant of integration is set to zero, <span>$c_{int} = 0$</span>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]         # vector representation of polynomial of degree ``d=4``
polynom_primitive(coords)
6-element Vector{Rational{Int64}}:
 0//1
 1//1
 1//2
 1//3
 1//4
 1//5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/polynom.jl#LL234-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_product-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Vector{V}}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.polynom_product-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Vector{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.polynom_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_product(a::Vector{T}, b::Vector{V}) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Vector representation of the product of two polynomials, <span>$a$</span> and <span>$b$</span> which is a polynomial in a vector space of dimension <span>$d=m+n$</span>,</p><p class="math-container">\[    p(c,x)=a_0b_0 + (a_0b_1 + b_0a_1)x + ⋯ + a_n b_m x^{n+m}.\]</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span> The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,⋯\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong></strong></p><pre><code class="language-none">[polynom_product1([1.0,1],[1,-1,2])]
 [1.0, 0.0, 1.0, 2.0]

[polynom_product1([1//1,1],[1,-1,2])]
 [1//1, 0//1, 1//1, 2//1]

[polynom_product([1,1],[1,- 1,2])]
 [1, 0, 1, 2]

[polynom_product([1,- 1,2],[1,1])]
 [1, 0, 1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/polynom.jl#LL272-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_product_expansion-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:Real" href="#CamiXon.polynom_product_expansion-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:Real"><code>CamiXon.polynom_product_expansion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_product_expansion(a::Vector{T}, b::Vector{T}, p::Int) where T&lt;:Real</code></pre><p>Vector representation of the product of two polynomials, <span>$a$</span> (of degree <span>$n$</span>) and <span>$b$</span> (of degree <span>$m$</span>), with <span>$m≤n$</span> truncated at the order <span>$p$</span> is a polynomial in a vector space of dimension <span>$d=p+1$</span>. If <span>$ab$</span> is the <code>polynom_product</code>, the <code>polynom_product_expansion</code> is <span>$ab[1:p+1]$</span></p><p><strong></strong></p><pre><code class="language-none">a = [1,-1,1]
b = [1,1,-1,1,1,1]
o = polynom_product(a, b); println(o)
 [1, 0, -1, 3, -1, 1, 0, 1]

o = expand_product(a, b, 4); println(o)
 [1, 0, -1, 3, -1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/polynom.jl#LL321-L338">source</a></section></article><h4 id="Laguerre-polynomials"><a class="docs-heading-anchor" href="#Laguerre-polynomials">Laguerre polynomials</a><a id="Laguerre-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Laguerre-polynomials" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="CamiXon.laguerre_coords-Tuple{Int64}" href="#CamiXon.laguerre_coords-Tuple{Int64}"><code>CamiXon.laguerre_coords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">laguerre_coords(n::Int)</code></pre><p>The coefficients of the Laguerre polynomals of degree <code>n</code>.</p><p class="math-container">\[    c(n)[m] = \frac{\Gamma(n+1)}{\Gamma(m+1)}\frac{(-1)^{m}}{(n-m)!}\frac{1}{m!}\]</p><p><strong>Example:</strong></p><pre><code class="language-none">o = laguerre_coords(8); println(o)
    Rational{Int64}[1//1, -8//1, 14//1, -28//3, 35//12, -7//15, 7//180, -1//630, 1//40320]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/laguerre.jl#LL69-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.laguerreL-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real" href="#CamiXon.laguerreL-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.laguerreL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">laguerreL(n::Int, x::T; deriv=0) where T&lt;:Real</code></pre><p>Laguerre polynomal of degree <code>n</code>,</p><p class="math-container">\[    L_{n}(x)
    = \frac{1}{n!}e^{x}\frac{d^{n}}{dx^{n}}(e^{-x}x^{n})
    = \sum_{m=0}^{n}(-1)^{m}\binom{n}{n-m}\frac{x^{m}}{m!}
    = \sum_{m=0}^{n}c(n)[m]x^{m}\]</p><p>where <span>$c(n)[m]$</span> is the Laguerre coordinate from <a href="#CamiXon.laguerre_coords-Tuple{Int64}"><code>laguerre_coords</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-none">(xmin, Δx, xmax) = (0, 0.1, 11)
n = 8
L = [laguerreL(n, x) for x=xmin:Δx:xmax]
f = Float64.(L);

plot_function(f, xmin, Δx, xmax; title=&quot;Laguere polynomial (of degree $n)&quot;)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_function</code> is not included in the <code>CamiXon</code> package. <img src="assets/laguerreL8.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/laguerre.jl#LL132-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.generalized_laguerre_coords-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real" href="#CamiXon.generalized_laguerre_coords-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.generalized_laguerre_coords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generalized_laguerre_coords(n::Int, α::T) where T&lt;:Real</code></pre><p>The coefficients of the generalized Laguerre polynomals of degree <code>n</code> for parameter <code>α</code>.</p><p class="math-container">\[    c(n, α)[m] = \frac{\Gamma(α+n+1)}{\Gamma(α+m+1)}
    \frac{(-1)^{m}}{(n-m)!}\frac{1}{m!}\]</p><p><strong>Example:</strong></p><pre><code class="language-none">o = generalized_laguerre_coords(8,3); println(o)
    Rational{Int64}[165//1, -330//1, 231//1, -77//1, 55//4, -11//8, 11//144, -11//5040, 1//40320]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/laguerre.jl#LL44-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.generalized_laguerreL-Union{Tuple{T}, Tuple{U}, Tuple{Int64, U, T}} where {U&lt;:Real, T&lt;:Real}" href="#CamiXon.generalized_laguerreL-Union{Tuple{T}, Tuple{U}, Tuple{Int64, U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.generalized_laguerreL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generalized_laguerreL(n::Int, α::U, x::T; deriv=0) where {U&lt;:Real, T&lt;:Real}</code></pre><p>Generalized Laguerre polynomal of degree <code>n</code> for parameter <code>α</code>,</p><p class="math-container">\[    L_{n}^{α}(x)
    = \frac{1}{n!}e^{x}x^{-α}\frac{d^{n}}{dx^{n}}(e^{-x}x^{n+α})
    = \sum_{m=0}^{n}(-1)^{m}\binom{n+α}{n-m}\frac{x^{m}}{m!}
    = \sum_{m=0}^{n}c(n,α)[m]x^{m}\]</p><p>where <span>$c(n,α)[m]$</span> is the generalized Laguerre coordinate from <a href="#CamiXon.generalized_laguerre_coords-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>generalized_laguerre_coords</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-none">(xmin, Δx, xmax) = (0, 0.1, 11)
n = 8
α = -0.3
gL = [generalized_laguerreL(n, α, x) for x=xmin:Δx:xmax]
f = Float64.(gL);

plot_function(f, xmin, Δx, xmax; title=&quot;Laguere polynomial (of degree $n for α =$α)&quot;)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_function</code> is not included in the <code>CamiXon</code> package.</p><p><img src="assets/laguerreL8.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/laguerre.jl#LL92-L119">source</a></section></article><h2 id="Finite-difference-methods"><a class="docs-heading-anchor" href="#Finite-difference-methods">Finite-difference methods</a><a id="Finite-difference-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-methods" title="Permalink"></a></h2><h3 id="Finite-differences"><a class="docs-heading-anchor" href="#Finite-differences">Finite differences</a><a id="Finite-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-differences" title="Permalink"></a></h3><p>Consider the analytical function <span>$f$</span> tabulated in <em>forward order</em>   (growing index) at <span>$n$</span> positions on a <em>uniform grid</em>.</p><p><strong>Forward difference notation</strong></p><p>In <em>forward difference</em> notation, the <em>finite difference</em> of two adjacent values on the grid is defined as</p><p class="math-container">\[Δ f[n] = f[n+1]-f[n],\]</p><p>where <span>$Δ$</span> is the forward difference operator. By a formal inversion   procedure we find</p><p class="math-container">\[f[n-1]=(1+Δ)^{-1}f[n]=(1-Δ+Δ^2-Δ^3+⋯)f[n],\]</p><p>where <span>$Δ^k$</span> is the  <span>$k^{th}$</span>-<em>order forward difference</em> defined as a <em>weighted sum</em> over the function values <span>$f[n:n+k]$</span> (involving <span>$k+1$</span> points),</p><p class="math-container">\[Δ^k f[n] = c_{k}^kf[n] + c_{k-1}^kf[n+1] + ⋯  + f[n+k]
= \sum_{j=0}^{k} c_{k-j}^k f[n+j].\]</p><p>The <span>$k+1$</span> coefficients</p><p class="math-container">\[c_{k-j}^{k}=(-1)^{k-j}\binom{k}{j}\]</p><p>are the <em>summation weights</em> (short: <em>weights</em>) which define the summation.</p><p><strong>Backward difference notation</strong></p><p>In <em>backward difference</em> notation, the <em>finite difference</em> of two adjacent values on the grid is defined as</p><p class="math-container">\[∇ f[n] = f[n]-f[n-1],\]</p><p>where <span>$∇$</span> is the backward difference operator.  By a formal inversion   procedure we find</p><p class="math-container">\[f[n+1]=(1-∇)^{-1}f[n]=(1+∇+∇^2+∇^3+⋯)f[n],\]</p><p>where <span>$∇^k$</span> is the  <span>$k^{th}$</span>-<em>order backward difference</em> defined as a <em>weighted sum</em> over the function values tabulated in backward order, <span>$f[n:-1:n-k]$</span> (involving <span>$k+1$</span> points),</p><p class="math-container">\[∇^k f[n] = f[n] + c_1^kf[n-1] + ⋯ + c_k^kf[n-k]
= \sum_{j=0}^{k} c_j^kf[n-j],\]</p><p>where the <span>$k+1$</span> coefficients</p><p class="math-container">\[c_{j}^{k}=(-1)^{j}\binom{k}{j}\]</p><p>are the <em>summation weights</em> (short: <em>weights</em>) which define the summation. Note the special cases <span>$c_{0}^{k}≡1$</span>, <span>$c_{k}^{k}≡(-1)^{k}$</span> and the symmetry relation</p><p class="math-container">\[c_{k-j}^k=(-1)^k c_j^k.\]</p><p>Coefficients:  </p><p><a href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>fdiff_weight(k,j)</code></a> <span>$→ c_j^k=(-1)^j\binom{k}{j}$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.isforward-Tuple{Any}" href="#CamiXon.isforward-Tuple{Any}"><code>CamiXon.isforward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function isforward(val)</code></pre><p>Boolean status of <code>val</code>, with options: <code>fwd</code> (forward) and <code>bwd</code> (backward).</p><p><strong>Example:</strong></p><pre><code class="language-none">isforward(fwd)
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/singleton.jl#LL26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.isregular-Tuple{Any}" href="#CamiXon.isregular-Tuple{Any}"><code>CamiXon.isregular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function isregular(val)</code></pre><p>Boolean status of <code>val</code>, with options: <code>reg</code> (regular) and <code>rev</code> (reversed).</p><p><strong>Example:</strong></p><pre><code class="language-none">isregular(reg)
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/singleton.jl#LL48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_weight-Tuple{Int64, Int64}" href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>CamiXon.fdiff_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_weight(k::Int, j::Int)</code></pre><p>Finite difference weight coefficient,</p><p class="math-container">\[c_{j}^{k}=(-1)^{k+j}\binom{k}{j}.\]</p><p><strong>Example:</strong></p><pre><code class="language-none">c(k,j) = fdiff_weight(k,j)

[[c(k,j) for j=0:k] for k=0:3] == [[1], [1, -1], [1, -2, 1], [1, -3, 3, -1]]
  true

[[c(k,k-j) for j=0:k] for k=0:3] == [[1], [-1, 1], [1, -2, 1], [-1, 3, -3, 1]]
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL2-L20">source</a></section></article><h3 id="Finite-difference-expansions"><a class="docs-heading-anchor" href="#Finite-difference-expansions">Finite difference expansions</a><a id="Finite-difference-expansions-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-expansions" title="Permalink"></a></h3><p>Finite-difference calculus builds on the <em>finite-difference expansion</em>.</p><p><strong>Forward difference notation</strong></p><p>In terms of forward differences the expansion takes the form</p><p class="math-container">\[\sum_{p=0}^{\infty}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}Δ^{p}f[n]+⋯.\]</p><p>A finite-difference expansion truncated at order <span>$k$</span> is defined by <span>$k+1$</span> <em>finite-difference expansion coefficients</em>, represented by the vector <span>$α = [α_{0},⋯\ α_{k}]$</span>. It takes some bookkeeping to rewrite the expansion as a <em>weighted sum</em> over the <span>$k+1$</span> <em>function values in forward tabulated form</em> <span>$f[n:n+k]$</span>. Substituting the finite difference expression for <span>$Δ^k$</span>, we obtain</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}\sum_{j=0}^{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}α_{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j],\]</p><p>where the weighted summation is defined by the <em>weights</em></p><p class="math-container">\[F_{j}^{k}=\sum_{p=j}^{k}α_{p}c_{p-j}^{p}
=\sum_{p=j}^{k}(-1)^{p+j}\binom{p}{j}α_{p},\]</p><p>with <span>$j=0,⋯\ k$</span>. In inner product form the expansion becomes</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$F^k  ≡ [F_0^k,⋯\ F_k^k]$</span>.</p><p class="math-container">\[f[n:n+k] = \left[\begin{array}{c}
f[n]\\
\vdots\\
f[n+k]
\end{array}\right].\]</p><p>Coefficients:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(coeffs, fwd, reg)</code></a> <span>$→ F^k ≡ [F_0^k,⋯\ F_k^k]$</span>,</p><p>where the <code>coeffs</code> <span>$α ≡ [α_0,⋯\ α_k]$</span> are user supplied to define the expansion.</p><p><strong>Backward difference notation</strong></p><p>In terms of backward differences the expansion takes the form</p><p class="math-container">\[\sum_{p=0}^{\infty}β_{p}∇^{p}f[n]=\sum_{p=0}^{k}β_{p}∇^{p}f[n]+⋯.\]</p><p>In this case the <span>$k^{th}$</span>- order <em>finite-difference expansion</em> is defined by the vector <span>$β = [β_{0},⋯\ β_{k}]$</span>. The expansion can written as <em>weighted sum</em> over the <span>$k+1$</span> <em>function values in backward tabulated form</em> <span>$f[n:-1:n-k]$</span>. Substituting the finite difference expression for <span>$∇^k$</span>, we obtain</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{p=0}^{k}β_{p}\sum_{j=0}^{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}β_{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}B_{j}^{k}f[n-j],\]</p><p>where the <em>weights</em> are given by</p><p class="math-container">\[B_{j}^{k}=\sum_{p=j}^{k}β_{p}c_{j}^{p}
=\sum_{p=j}^{k}(-1)^{j}\binom{p}{j}β_{p},\]</p><p>with <span>$j=0,⋯\ k$</span>. In inner product form the expansion becomes</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^k B_j^k f[n-j]
=\bar{B}^k \cdot f[n-k:n],\]</p><p>where the <em>weights vector</em> <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> contains the weights in backward order.</p><p>In general there is <em>no simple symmetry relation</em> between <span>$B^k$</span> and <span>$F^k$</span>.</p><p>Coefficients:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(coeffs, bwd, rev)</code></a> <span>$→ \bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span>,</p><p>where the <code>coeffs</code>  <span>$β ≡ [β_0,⋯\ β_k]$</span> are user supplied to define the expansion.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_expansion_weights" href="#CamiXon.fdiff_expansion_weights"><code>CamiXon.fdiff_expansion_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fdiff_expansion_weights(coeffs[, notation=bwd[, ordering=rev]])</code></pre><p>Expansion weights corresponding to the expansion coefficients <code>coeffs</code> of a finite difference expansion.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p>Weight vector <span>$F^k ≡ [F_k^k,⋯\ F_0^k]$</span> corresponding to the expansion coefficients <span>$α ≡ [α_0^k,⋯\ α_k^k]$</span> of the <span>$k^{th}$</span>-order <em>forward-difference</em> expansion,</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$f[n:n+k]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order.</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(α, fwd, reg)</code></a> <span>$→ F^k ≡ [F_0^k,⋯\ F_k^k]$</span>,</p><p>where <span>$α ≡ [α_0,⋯\ α_k]$</span> has to be supplied in combination with <code>fwd</code> to indicate that the weights must be evaluated in forward-difference notation.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p>Weight vector <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> corresponding to the expansion coefficients <span>$β ≡ [β_0,⋯\ β_k]$</span> of the <span>$k^{th}$</span>-order <em>backward-difference</em> expansion,</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^{k}B_{j}^kf[n-j]
=\bar{B}^k \cdot f[n-k:n].\]</p><p>where <span>$f[n-k:n]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order.</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ \bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span>,</p><p>where <span>$β ≡ [β_0,⋯\ β_k]$</span> has to be supplied in combination with <code>bwd</code> to indicate that the weights must be evaluated in backward-difference notation.</p><p><strong>Example:</strong></p><p>Consider the expansions,</p><p class="math-container">\[f[n-1]=(1+Δ)^{-1}f[n]=(1-Δ+Δ^2-Δ^3+⋯)f[n].\]</p><p class="math-container">\[f[n+1]=(1-∇)^{-1}f[n]=(1+∇+∇^2+∇^3+⋯)f[n],\]</p><pre><code class="language-none">α = [1,-1,1,-1,1]
β = [1,1,1,1,1]
Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
  Fk = [5, -10, 10, -5, 1]

Bk = fdiff_expansion_weights(β, bwd, reg); println(&quot;Bk = $(Bk)&quot;)
  Bk = [5, -10, 10, -5, 1]

revFk = fdiff_expansion_weights(α, fwd, rev); println(&quot;revFk = $(revFk)&quot;)
  revFk = [1, -5, 10, -10, 5]

revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
  revBk = [1, -5, 10, -10, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL70-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_expansion" href="#CamiXon.fdiff_expansion"><code>CamiXon.fdiff_expansion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fdiff_expansion(coeffs, f[, notation=bwd])</code></pre><p>Finite difference expansion of the analytical function f(x) tabulated in <em>forward order</em> (growing index) at <span>$k+1$</span> positions on a uniform grid. The expansion coefficients are specified by the vector <code>coeffs</code>. By default <code>coeffs</code> are assumed to be in backward-difference notation (<code>bwd</code>). For <code>coeffs</code> in forward-difference notation the third argument must be <code>fwd</code>.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n] = F^{k} \cdot f[n:n+k],\]</p><p>where <span>$f[n:n+k]$</span> are elements of the analytical function <span>$f$</span> (tabulated in <em>forward</em> order) and <span>$α ≡ [α_0,⋯\ α_k]$</span> is the vector <code>coeffs</code>, which has to be supplied to define the forward-difference expansion. The corresponding weights vector <span>$F^{k}$</span> is internally generated.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n] = \bar{B}^k \cdot f[n-k:n].\]</p><p>where <span>$f[n-k:n]$</span> are elements of the analytical function <span>$f$</span> (tabulated in <em>forward</em> order) and <span>$β ≡ [β_0,⋯\ β_k]$</span> is the vector <code>coeffs</code>, which has to be supplied to define the backward-difference expansion. The corresponding weights vector <span>$\bar{B}^k$</span> is internally generated.</p><p><strong>Examples:</strong></p><p>Consider the function <span>$f(x)=x^2$</span> and the expansions,</p><p class="math-container">\[f(x-1)=(1+Δ)^{-1}=(1-Δ+Δ^2-Δ^3+⋯)f(x).\]</p><p class="math-container">\[f(x+1)=(1-∇)^{-1}=(1+∇+∇^2+∇^3+⋯)f(x),\]</p><p>To fourth order <code>(k=4)</code> the forward- and backward-difference coefficient vectors are <code>α=[1,-1,1,-1,1]</code> and <code>β=[1,1,1,1,1]</code>, respectively. We tabulate the function at <span>$k+1$</span> points, <code>f=[1,4,9,16,25]</code>.</p><pre><code class="language-none">α = [1,-1,1,-1,1]
Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
  Fk = [5, -10, 10, -5, 1]

β = [1,1,1,1,1]
revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
  revBk = [1, -5, 10, -10, 5]

f = [1,4,9,16,25]
o = fdiff_expansion(α, f, fwd); println(&quot;f[0] = $(o)&quot;)
  f[0] = 0

fdiff_expansion(α, f, fwd) == Fk ⋅ f == fdiff_interpolation(f, 0)
  true

o = fdiff_expansion(β, f, bwd); println(&quot;f[6] = $(o)&quot;)
  f[6] = 36

fdiff_expansion(β, f, bwd) == revBk ⋅ f == fdiff_interpolation(f, length(f)+1)
  true</code></pre><p>In these cases the results are exact because the function is quadratic and the expansion is third order (based on the polynomial of <span>$k^{th}$</span> degree running through the <span>$k+1$</span> points of the tabulated function). Note the relation with <a href="#CamiXon.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>fdiff_interpolation(f, v, k=3)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL162-L228">source</a></section></article><h3 id="Lagrange-polynomial-interpolation/extrapolation"><a class="docs-heading-anchor" href="#Lagrange-polynomial-interpolation/extrapolation">Lagrange-polynomial interpolation/extrapolation</a><a id="Lagrange-polynomial-interpolation/extrapolation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrange-polynomial-interpolation/extrapolation" title="Permalink"></a></h3><p>The Lagrange polynomial of degree k on a uniform grid is the polynomial running through k+1 subsequent points on the grid. We derive expressions for interpolation/extrapolation in both forward- and backward-difference notation. Beware that Lagrange interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree k.</p><p><strong>Forward difference notation</strong></p><p>Starting from the relation</p><p class="math-container">\[f[n]=(1+Δ)f[n+1],\]</p><p>we obtain by formal operator inversion</p><p class="math-container">\[f[n+1] = (1 + Δ)^{-1} f[n] \equiv \sum_{p=0}^{\infty}(-1)^p Δ^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 + Δ)^{-2} f[n] \equiv \sum_{p=0}^{\infty}(-1)^p pΔ^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>where <span>$k$</span> is called the order of the expansion and <span>$n$</span> is the reference index. For interpolation position <span>$n-σ$</span> (where σ may be <em>real</em> valued in index units) these expansions can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n-σ] = (1 + Δ)^{-σ} f[n] \equiv \sum_{p=0}^{\infty} α_p(σ) Δ^p f[n],\]</p><p>where</p><p class="math-container">\[α_p(σ) ≡ (-1)^p(σ)_p/p!\]</p><p>is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient</em> for lagrangian lagrangian interpolation over the interval <span>$-k ≤σ ≤0\ \ (n \le n-σ \le n+k)$</span>,</p><p class="math-container">\[(σ)_{p}=\begin{cases}
1 &amp; p=0\\
σ(σ+1)(σ+2)\cdots(σ+p-1) &amp; p&gt;0
\end{cases}\]</p><p>being the Pochhammer symbol (<a href="#CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>pochhammer</code></a>). For <span>$σ$</span> outside the interpolation interval the method corresponds to <em>extrapolation</em> along the Lagrange polynomial. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[f[n-σ] =\sum_{p=0}^{k}α_p(σ)Δ^pf[n]
=\sum_{j=0}^{k}F_j^k(σ)f[n+j]
=F^k(σ) \cdot f[n:n+k],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[F_j^k(σ)= \sum_{p=j}^{k} (-1)^k α_p(σ) c_j^p
=\sum_{p=j}^{k} (-1)^j \binom{p}{j}(σ)_p/p!\]</p><p>are the <em>lagrangian interpolation weights</em> corresponding to the point <span>$f[n-σ]$</span>.</p><p>Symmetry relation:</p><p class="math-container">\[\bar{F}^k(-k-σ) = F^k(σ)\]</p><p>Weight functions:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(coeffs, fwd, reg)</code></a> <span>$→ F^k(σ) ≡ [F^k_0(σ),⋯\ F^k_k]$</span>,</p><p>where the vector</p><p><code>coeffs =</code><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_coeffs(σ, k, fwd)</code></a> <span>$→ α(σ) ≡ [α_0(σ),⋯\ α_k(σ)]$</span>  contains the coefficients of the lagrangian-interpolation expansion.</p><p><strong>Backward difference notation</strong></p><p>Starting from the relation</p><p class="math-container">\[f[n]=(1-∇)f[n+1].\]</p><p>we obtain by formal operator inversion</p><p class="math-container">\[f[n+1] = (1 - ∇)^{-1} f[n] \equiv \sum_{p=0}^{\infty}∇^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 - ∇)^{-2} f[n] \equiv \sum_{p=0}^{\infty}p∇^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>where <span>$k$</span> is called the order of the expansion and <span>$n$</span> is the reference index. For interpolation position <span>$n-σ$</span> (where σ may be <em>real</em> valued in index units) these expansions can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n+σ] = (1 - ∇)^{-σ} f[n] \equiv \sum_{p=0}^{\infty} β_p(σ) ∇^p f[n],\]</p><p>where</p><p class="math-container">\[β_p(σ) ≡ (σ)_p/p! = (-1)^p α_p(σ)\]</p><p>is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient</em> for lagrangian interpolation over the interval <span>$-k ≤σ ≤0\ \ (n-k \le n+σ \le n)$</span>, with</p><p class="math-container">\[(σ)_{p}=\begin{cases}
1 &amp; p=0\\
σ(σ+1)(σ+2)\cdots(σ+p-1) &amp; p&gt;0
\end{cases}\]</p><p>being the Pochhammer symbol (<a href="#CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>pochhammer</code></a>). For <span>$σ$</span> outside the interpolation interval the method corresponds to <em>extrapolation</em> along the Lagrange polynomial. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[f[n+σ] =\sum_{p=0}^{k}β_p(σ)∇^pf[n]
= \sum_{j=0}^{k}B^k_j(σ)f[n-j]
= \bar{B}^k(σ) ⋅ f[n-k:n],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[B^k_j(σ)= \sum_{p=j}^{k} β_p(σ) c_j^p\]</p><p>are the corresponding <em>lagrangian interpolation weights</em>.  </p><p>Symmetry relations:</p><p class="math-container">\[B^k(σ) = F^k(σ) = \bar{B}^k(-k-σ)\]</p><p class="math-container">\[\bar{B}^k(σ) = B^k(-k-σ)\]</p><p>Weight function:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(coeffs, bwd, rev)</code></a> <span>$→ \bar{B}^k(σ) ≡ [B_k^k(σ),⋯\ B_0^k(σ)]$</span>,</p><p>where the vector</p><p><code>coeffs =</code><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_coeffs(σ, k=3, notation=bwd)</code></a> <span>$→ β(σ) ≡ [β_0(σ),⋯\ β_k(σ)]$</span> contains the coefficients of the lagrangian-interpolation expansion.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real" href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>CamiXon.fdiff_interpolation_expansion_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_interpolation_expansion_coeffs(ξ::T [, k=3 [, notation=bwd]]) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector defining the <span>$k^{th}$</span>-order (default <em>third</em> order) Lagrange-polynomial interpolation of a tabulated analytic function <span>$f[n]$</span> at offset <span>$ξ$</span> with respect to index position <span>$n$</span>, which is positive for increasing index and negative for decreasing index.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p>In this case we consider the tabulated interval <span>$f[n:n+k]$</span>. The interpolated value <span>$f[n+ξ]$</span> is given by the forward-difference expansion</p><p class="math-container">\[f[n+ξ] = \sum_{p=0}^k α_p(-ξ) Δ^p f[n] + ⋯,\]</p><p>where the expansion coefficients are given by</p><p><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_coeffs(ξ, k, fwd)</code></a> <span>$→ α(-ξ) ≡ [α_0(-ξ),⋯\ α_k(-ξ)]$</span>. In this notation the range <span>$0\leq ξ\leq k$</span> corresponds to interpolation and the ranges <span>$ξ&lt;0$</span> and <span>$ξ&gt;k$</span> to extrapolation.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p>In this case we consider the tabulated interval <span>$f[n-k:n]$</span>. The interpolated value <span>$f[n+ξ]$</span> is given by the backward-difference expansion</p><p class="math-container">\[f[n+ξ] = \sum_{p=0}^k β_p(ξ) ∇^p f[n] + ⋯,\]</p><p>where the expansion coefficients are given by</p><p><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_coeffs(ξ, k, bwd)</code></a> <span>$→ β(ξ) ≡ [β_0(ξ),⋯\ β_k(ξ)]$</span>. In this notation the range <span>$-k\leq ξ\leq0$</span> corresponds to interpolation and the ranges <span>$ξ&lt;-k$</span> and <span>$ξ&gt;0$</span> to extrapolation.</p><p><strong>Examples:</strong></p><pre><code class="language-none">k = 5
ξ = -1
α = fdiff_interpolation_expansion_coeffs(ξ, k, fwd); println(&quot;α = $α&quot;)
β = fdiff_interpolation_expansion_coeffs(ξ, k, bwd); println(&quot;β = $β&quot;)
  α = [1, 1, 0, 0, 0, 0]
  β = [1, 1, 1, 1, 1, 1]

ξ = 0
α = fdiff_interpolation_expansion_coeffs(ξ, k, fwd); println(&quot;α = $α&quot;)
β = fdiff_interpolation_expansion_coeffs(ξ, k, bwd); println(&quot;β = $β&quot;)
  α = [1, 0, 0, 0, 0, 0]
  β = [1, 0, 0, 0, 0, 0]

ξ = 1
α = fdiff_interpolation_expansion_coeffs(ξ, k, fwd); println(&quot;α = $α&quot;)
β = fdiff_interpolation_expansion_coeffs(ξ, k, bwd); println(&quot;β = $β&quot;)
  α = [1, -1, 1, -1, 1, -1]
  β = [1, -1, 0, 0, 0, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL261-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.fdiff_interpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_interpolation(f::Vector{T}, v::V; k=3) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Finite difference lagrangian interpolation (by default <em>third</em> order) at real position v (in index units) with respect to the elements of the uniformly tabulated analytic function <code>f[1:N]</code>. The interpolation points lie on a Lagrange polynomial of degree <span>$k$</span> (by default <em>third</em> degree) running through <span>$k+1$</span> subsequenct points of the tabulated function. Outside the tabulated range, the method represents extrapolation on the lagrangian polynomial defined by the first/last <span>$k+1$</span> tabulated points.</p><p>Beware that the interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree <span>$k$</span>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">f = [1,2,3,4,5,6,7]
[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]
  [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0]

f = [1,4,9,16,25,36,49]
[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]
 [1.0, 2.25, 4.0, 6.25, 9.0, 12.25, 16.0, 20.25, 25.0, 30.25, 36.0, 42.25, 49.0]

 f = [x^3 for x=-4:2]
 f1(v) = fdiff_interpolation(f, v; k=1)
 f2(v) = fdiff_interpolation(f, v; k=2)
 f3(v) = fdiff_interpolation(f, v; k=3)
 [[f1(v),f2(v),f3(v)] for v=1:0.5:9]
   [[-64.0, -64.0, -64.0], [-45.5, -43.25, -42.875], [-27.0, -27.0, -27.0],
   [-17.5, -16.0, -15.625], [-8.0, -8.0, -8.0], [-4.5, -3.75, -3.375],
   [-1.0, -1.0, -1.0], [-0.5, -0.5, -0.125], [0.0, 0.0, 0.0],
   [0.5, -0.25, 0.125], [1.0, 1.0, 1.0], [4.5, 3.75, 3.375], [8.0, 8.0, 8.0],
   [11.5, 13.75, 15.625], [15.0, 21.0, 27.0], [18.5, 29.75, 42.875],
   [22.0, 40.0, 64.0]]</code></pre><p>The result for f3(v) is exact because the function is cubic and the expansion is third order - see Figure below. The tabulated function is given by the black points. The interpolation and extrapolation points are red.</p><p><img src="assets/lagrangian_interpolation.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL375-L415">source</a></section></article><h3 id="Lagrangian-differentiation"><a class="docs-heading-anchor" href="#Lagrangian-differentiation">Lagrangian differentiation</a><a id="Lagrangian-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-differentiation" title="Permalink"></a></h3><p>To derive the <em>lagrangian differentiation</em> formulas we formally differentiate</p><p class="math-container">\[f[n+x] = (1 - ∇)^{-x} f[n]\]</p><p>with respect to <span>$x$</span>.</p><p class="math-container">\[\frac{df}{dx}[n+x]
=-ln(1-∇)\ (1-∇)^{-x}f[n]
=\sum_{q=1}^{k}\tfrac{1}{q}∇^{q}\sum_{p=0}^{k}l_{p}(x)∇^{p}f[n]+⋯.\]</p><p>Rewriting the r.h.s. as a single summation in powers of <span>$∇$</span> for given values of <span>$n$</span> and <span>$x$</span> we obtain an expression of the form</p><p class="math-container">\[\frac{df}{dx}[n+x]=\sum_{p=1}^{k}β_p(x)∇^{p}f[n]+⋯,\]</p><p>where <span>$β_p(x)$</span> represents the <em>finite-difference expansion coefficients</em> for <em>lagrangian differentiation</em> at position <span>$n+x$</span>. These coefficients are determined numerically by polynomial multiplication. As the expansion algorith requires the presentce of a <span>$β_0(x)$</span> coefficient we add a (vanishing) <span>$p=0$</span> term, <span>$β_0(x)\equiv 0$</span>. The corresponding coefficient vector is given by <a href="#CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_coeffs(k,x)</code></a>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[\frac{df}{dx}[n+x]
=\sum_{p=0}^{k}β_p(x)∇^pf[n]
=\sum_{j=0}^{k}B_j^k(x)f[n-j]
=B^k(x) ⋅ f[n:-1:n-k],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[ B_j^k(x)=\sum_{p=j}^{k}β_p(x)c_{j}^{p}\]</p><p>are the <span>$k^{th}$</span>-order lagrangian differentiation weights. After changing dummy index to reverse the summation the expansion becomes</p><p class="math-container">\[\frac{df}{dx}[n+x]
=\sum_{j=0}^{k}\bar{B}^k_j(x)f[n-k+j]
=\bar{B}^k(x) ⋅ f[n-k:n].\]</p><p>Functions:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, reg)</code></a> <span>$→ B^k(x) ≡ [B^k_0(x),⋯\ B^k_k(x)]$</span></p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ \bar{B}^k(x) ≡ [B^k_k(x),⋯\ B^k_0(x)]$</span></p><p>where</p><p><a href="#CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_coeffs(o, k)</code></a> <span>$→ β ≡ [β_0(x),⋯\ β_k(x)]$</span>.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real" href="#CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>CamiXon.fdiff_differentiation_expansion_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_differentiation_expansion_coeffs(ξ::T [, k=3 [, notation=bwd]]) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector defining <span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the tabulated analytic function <span>$f[n]$</span> at offset <span>$ξ$</span> (with respect to index position <span>$n$</span>), which is positive for increasing index and negative for decreasing index.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p class="math-container">\[\frac{df}{dξ}[n+ξ]=\sum_{p=0}^kα_p(ξ)Δ^{p}f[n]\]</p><p>Offset convention: <span>$ξ = -σ$</span> with respect to index <span>$n$</span> in tabulated interval <span>$f[n:n+k]$</span></p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p class="math-container">\[\frac{df}{dξ}[n+ξ]=\sum_{p=0}^kβ_p(ξ)∇^{p}f[n]\]</p><p>where <span>$β(ξ) ≡ [β_0(ξ),\ ⋯,\ β_p(ξ)]$</span></p><p>Offset convention: <span>$ξ = σ$</span> with respect to index <span>$n$</span> in tabulated interval <span>$f[n-k:n]$</span></p><p><strong>Example:</strong></p><pre><code class="language-none">k = 2; ξ = 0
o = fdiff_differentiation_expansion_coeffs(ξ, k); println(o)
 [0.0, 1.0, -1.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL485-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_differentiation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.fdiff_differentiation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.fdiff_differentiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_differentiation(f::Vector{T}, v::V; k=3) where {T&lt;:Real, V&lt;:Real}</code></pre><p><span>$k^{th}$</span>-order (default <em>third</em> order) lagrangian <em>differentiation</em> of the analytic function <span>$f$</span>, tabulated in forward order on a uniform grid.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = [x^3 for x=-5:5]; println(round.(Int,f))
l = length(f)
f′ = [fdiff_differentiation(f, v) for v=1:l]; println(round.(Int,f′))
  [-125, -64, -27, -8, -1, 0, 1, 8, 27, 64, 125]
  [75, 48, 27, 12, 3, 0, 3, 12, 27, 48, 75]

f′= fdiff_differentiation(f, 1) ; println(&quot;f′(1) = $(f′))
  f′(1) = 75//1

f′= fdiff_differentiation(f, 6.5) ; println(&quot;f′(6.5) = $(f′)&quot;)
    f′(6.5) = 0.75</code></pre><p>For a cubic function the third-order lagrangian differentiation is exact - see Figure below.</p><p><img src="assets/lagrangian_differentiation.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL528-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}" href="#CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiXon.create_lagrange_differentiation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_lagrange_differentiation_matrix(k::Int)</code></pre><p>Lagrange differentiation matrix, <span>$m[i,j]=s_{k-j}^k(i)$</span>, for <span>$k^{th}$</span>-order lagrangian differentiation,</p><p class="math-container">\[\frac{dy}{dx}[i]= \sum_{j=0}^{k}m[i,j]y[j],\]</p><p><strong>Example:</strong></p><pre><code class="language-none">k = 3
create_lagrange_differentiation_matrix(k)
 4×4 Matrix{Rational{Int64}}:
  -11//6   3//1  -3//2   1//3
   -1//3  -1//2   1//1  -1//6
    1//6  -1//1   1//2   1//3
   -1//3   3//2  -3//1  11//6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL569-L587">source</a></section></article><h3 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.trapezoidal_weights-Tuple{Int64}" href="#CamiXon.trapezoidal_weights-Tuple{Int64}"><code>CamiXon.trapezoidal_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trapezoidal_weights(k::Int [; rationalize=false [, devisor=false]])</code></pre><p>Weight coefficient vector <span>$a=[a_1,⋯\ a_k]$</span> of trapeziodal rule optimized for functions of polynomial form,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}),\]</p><p>where <span>$k$</span> is <em>odd</em>. The rule is exact for polynonials of degree <span>$d=0,\ 1, ⋯,\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="language-none">[trapezoidal_weights(k; rationalize=true, devisor=true) for k=1:2:9]
5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
  (1, 2, [1])
  (3, 24, [9, 28, 23])
  (5, 1440, [475, 1902, 1104, 1586, 1413])
  (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])
  (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922,
                                                     5095890, 7783754, 7200319])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL603-L627">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.trapezoidal_integration-NTuple{4, Any}" href="#CamiXon.trapezoidal_integration-NTuple{4, Any}"><code>CamiXon.trapezoidal_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trapezoidal_integration(f, x1, x2, weights)</code></pre><p>Integral of the tabulated function <span>$f=[f_0,⋯\ f_n]$</span> over the <code>domain</code> <span>$x1 ≤ x ≤ x2$</span> using the optimized trapezoidal rule with endpoint correction by the weights vector <code>weights</code>,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}).\]</p><p>The rule is exact for polynonials of degree <span>$d=0,\ 1,⋯\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Examples::</strong></p><pre><code class="language-none">p = 3
c = [1 for i=0:p]
pol = ImmutablePolynomial(c,:z)
Ipol = integrate(pol)
n = 10

x1=0.0
x2=5.0
x = collect(range(x1, x2, n))
f = pol.(x .-2.5)

w3 = trapezoidal_weights(3)
trapezoidal_integration(f, x1, x2, w3)
 15.416666666666673

Ipol(2.5)-Ipol(-2.5)
 15.41666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_differences.jl#LL667-L699">source</a></section></article><h3 id="Adams-Method"><a class="docs-heading-anchor" href="#Adams-Method">Adams Method</a><a id="Adams-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Method" title="Permalink"></a></h3><h4 id="Adams-Bashford-expansion"><a class="docs-heading-anchor" href="#Adams-Bashford-expansion">Adams-Bashford expansion</a><a id="Adams-Bashford-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Bashford-expansion" title="Permalink"></a></h4><p>The <em>Adams-Bashford integration step</em> is given by the expansion</p><p class="math-container">\[y[n+1]-y[n] = -\frac{h ∇}{(1-∇)ln(1-∇)}f[n+1]=h (\sum_{p=0}^{\infty}B_p∇^p)f[n+1].\]</p><p>A closed expression for the <em>Adams-Bashford expansion coefficients</em>, <span>$B_k$</span>, is not available. As we already have a finite-difference expansion for the operator <span>$(1-∇)^{-1}$</span>,</p><p class="math-container">\[\frac{1}{1-∇}\equiv\sum_{p=0}^{\infty}∇^p,\]</p><p>we ask for the expansion of</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}
=(1-\frac{1}{2}∇-\frac{1}{24}∇^2-\frac{1}{12}∇^3+⋯)f[n+1]
= (\sum_{p=0}^{\infty}b_p∇^p)f[n+1].\]</p><p>This is known as the <em>Adams-Moulton expansion</em>. Its coefficients are calculated numerically by the function <code>fdiff_expansion_adams_moulton_coeffs(k)</code>. The <em>Adams-Bashford expansion</em> is obtained as the polynomial product of the two expansions,</p><p class="math-container">\[(\sum_{p=0}^{\infty}B_p∇^p)f[n+1]
=(\sum_{p=0}^{\infty}∇^p)(\sum_{p=0}^{\infty}b_p∇^p)f[n+1]
=\ ( 1 + \frac{1}{2}∇ + \frac{5}{12}∇^2 + ⋯)f[n+1].\]</p><p>The coefficients <span>$B_p$</span> are calculated numerically with the function <code>fdiff_expansion_adams_bashford_coeffs(k)</code>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}B_p∇^pf[n]
=\sum_{p=0}^{k}B_p\sum_{j=0}^{p} c_j^if[n-j]
= \sum_{j=0}^{k}A_j^k(x)f[n-j]
= \sum_{j=0}^{k}A_{k-j}^k(x)f[n-k+j],\]</p><p>where the <span>$A_j^k(x)= \sum_{p=j}^{k} B_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Bashford integration weights</em>.</p><p>Function:</p><p><code>β</code> = <a href="#CamiXon.fdiff_adams_bashford_expansion_coeffs-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_coeffs(k)</code></a>  <span>$→ [B_k^k(x),⋯\ B_0^k(x)]$</span></p><p><code>adams_bashford_integration_weights</code> = <a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a>  <span>$→ [A_k^k(x),⋯\ A_0^k(x)]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_adams_bashford_expansion_coeffs-Tuple{Int64}" href="#CamiXon.fdiff_adams_bashford_expansion_coeffs-Tuple{Int64}"><code>CamiXon.fdiff_adams_bashford_expansion_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_adams_bashford_expansion_coeffs(k [; T=Int])</code></pre><p><span>$(k+1)$</span>-point Adams-Bashford expansion coefficients <span>$B_p$</span>.</p><p class="math-container">\[-\frac{∇}{(1-∇)ln(1-∇)}=\sum_{p=0}^{\infty}B_p∇^p=1+\ \frac{1}{2}∇+\ \frac{5}{12}∇^2+\ ⋯.\]</p><p>The weights are stored in <em>forward</em> order: <span>$[B_0^k,⋯\ B_k^k]$</span> - order of use in summation.</p><p><strong>Examples:</strong></p><pre><code class="language-none">k = 5
o = fdiff_adams_bashford_expansion_coeffs(k); println(o)
 Rational{Int64}[1//1, 1//2, 5//12, 3//8, 251//720, 95//288]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_difference_adams.jl#LL95-L111">source</a></section></article><h3 id="Adams-Moulton-expansion"><a class="docs-heading-anchor" href="#Adams-Moulton-expansion">Adams-Moulton expansion</a><a id="Adams-Moulton-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-expansion" title="Permalink"></a></h3><p>The <em>Adams-Moulton integration</em> step is given by the expansion</p><p class="math-container">\[y[n+1]-y[n]
= -\frac{∇}{ln(1-∇)}f[n+1]
= ( 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯)f[n+1].\]</p><p>For the evaluation of the integration step we limit the summation to <span>$k+1$</span> terms (order <span>$k$</span>),</p><p class="math-container">\[y[n+1]-y[n]= (\sum_{p=0}^{k}b_p∇^p)f[n+1]+⋯.\]</p><p>where <span>$b_0,⋯\ b_k$</span> are the <em>Adams-Moulton expansion coefficients</em>, rational numbers generated numerically by the function <a href="#CamiXon.fdiff_adams_moulton_expansion_coeffs-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_coeffs(k)</code></a>. Extracting the greatest common denominator, <span>$1/D$</span>, the step becomes</p><p class="math-container">\[y[n+1]-y[n]= \frac{1}{D}(\sum_{p=0}^{k}b_p^{\prime}∇^p)f[n+1]+⋯,\]</p><p>where <span>$b_0^{\prime},⋯\ b_k^{\prime}$</span> are integers and <span>$b_p=b_p^{\prime}/D$</span>. In practice the expansion is restricted to <span>$k&lt;18$</span> (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to <span>$k = 10$</span>). Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}b_p∇^pf[n]
=\sum_{p=0}^{k}b_p\sum_{j=0}^{p} c_j^if[n-j]
= \sum_{j=0}^{k}a_j^k(x)f[n-j]
= \sum_{j=0}^{k}a_{k-j}^k(x)f[n-k+j],\]</p><p>where the <span>$a_j^k(x)= \sum_{p=j}^{k} b_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Moulton integration weights</em>.</p><p>Functions:</p><p><code>β</code> = <a href="#CamiXon.fdiff_adams_moulton_expansion_coeffs-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_coeffs(k)</code></a> <span>$→ [b_0,⋯\ b_k]$</span></p><p><code>adams_moulton_weights</code> = <a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ [a_k^k,⋯\ a_0^k]$</span>.</p><p><code>adams_moulton_weights</code> = <a href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>create_adams_moulton_weights(k)</code></a> <span>$→ [a_k^k,⋯\ a_0^k]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fdiff_adams_moulton_expansion_coeffs-Tuple{Int64}" href="#CamiXon.fdiff_adams_moulton_expansion_coeffs-Tuple{Int64}"><code>CamiXon.fdiff_adams_moulton_expansion_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fdiff_adams_moulton_expansion_coeffs(k [; T=Int])</code></pre><p>Finite difference expansion coefficient vector <span>$β ≡ [β_0(x),\ ⋯,\ β_p(x)]$</span> defining <span>$k^{th}$</span>-order Adams-Moulton expansion,</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}
= \sum_{p=0}^{\infty}β_p∇^p
= 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">k = 5
β = fdiff_adams_moulton_expansion_coeffs(k::Int); println(b)
 Rational[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]

D = denominator(gcd(β)); println(D)
 1440

o = convert(Vector{Int},(β .* D)); println(o)
 [1440, -720, -120, -60, -38, -27]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_difference_adams.jl#LL3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.create_adams_moulton_weights-Tuple{Int64}" href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>CamiXon.create_adams_moulton_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])</code></pre><p><span>$k^{th}$</span>-order Adams-Moulton weights vector,</p><p class="math-container">\[y[n+1] = y[n] + \frac{1}{D}\sum_{j=0}^{k}a^k[j]f[n+1-k+j]\]</p><p>The weights are stored in the vector <span>$a^k \equiv[a_k^k/D,⋯\ a_0^k/D]$</span> under the convention <span>$a^k[j] \equiv a_{k-j}^k/D$</span>, where <span>$a_j^k$</span> are the Adams-Moulton weight coefficients and <span>$D$</span> the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational,  with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="language-none">[create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:8]
8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
 (1, 2, [1, 1])
 (2, 12, [-1, 8, 5])
 (3, 24, [1, -5, 19, 9])
 (4, 720, [-19, 106, -264, 646, 251])
 (5, 1440, [27, -173, 482, -798, 1427, 475])
 (6, 60480, [-863, 6312, -20211, 37504, -46461, 65112, 19087])
 (7, 120960, [1375, -11351, 41499, -88547, 123133, -121797, 139849, 36799])
 (8, 3628800, [-33953, 312874, -1291214, 3146338, -5033120, 5595358, -4604594, 4467094, 1070017])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/finite_difference_adams.jl#LL50-L75">source</a></section></article><h2 id="Strings"><a class="docs-heading-anchor" href="#Strings">Strings</a><a id="Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Strings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.sup-Tuple{T} where T&lt;:Real" href="#CamiXon.sup-Tuple{T} where T&lt;:Real"><code>CamiXon.sup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sup(i::T) where T&lt;:Real</code></pre><p>Superscript notation for integers and rational numbers</p><p><strong>Examples:</strong></p><pre><code class="language-none">sup(3) * &#39;P&#39;
 &quot;³P&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/strings.jl#LL58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.sub-Tuple{T} where T&lt;:Real" href="#CamiXon.sub-Tuple{T} where T&lt;:Real"><code>CamiXon.sub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sub(i::T) where T&lt;:Real</code></pre><p>Subscript notation for integers, rational numbers and a <em>subset</em> of lowercase characters (&#39;a&#39;,&#39;e&#39;,&#39;h&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;x&#39;)</p><p><strong>Examples:</strong></p><pre><code class="language-none">&#39;D&#39; * sub(5//2)
 &quot;D₅⸝₂&quot;

&quot;m&quot; * sub(&quot;e&quot;)
 &quot;mₑ&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/strings.jl#LL81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.frac-Tuple{Rational{Int64}}" href="#CamiXon.frac-Tuple{Rational{Int64}}"><code>CamiXon.frac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">frac(i)</code></pre><p>Fraction notation for rational numbers</p><p><strong>Examples:</strong></p><pre><code class="language-none">frac(-5//2)
 &quot;-⁵/₂&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/strings.jl#LL118-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.strRational-Tuple{T} where T&lt;:Union{Int64, BigInt, Rational}" href="#CamiXon.strRational-Tuple{T} where T&lt;:Union{Int64, BigInt, Rational}"><code>CamiXon.strRational</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">strRational(i)</code></pre><p>Fraction notation for rational numbers and integers</p><p><strong>Examples:</strong></p><pre><code class="language-none">strRational(-5//2)
 &quot;-5/2&quot;

 strRational(-5//2)
  &quot;-5&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/strings.jl#LL139-L151">source</a></section></article><h2 id="Dicts"><a class="docs-heading-anchor" href="#Dicts">Dicts</a><a id="Dicts-1"></a><a class="docs-heading-anchor-permalink" href="#Dicts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.dictAtomicNumbers" href="#CamiXon.dictAtomicNumbers"><code>CamiXon.dictAtomicNumbers</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">dictAtomicNumbers</code></pre><pre><code class="language-none">Dict{String, Int64} with 102 entries:
  &quot;Pd&quot; =&gt; 46
  &quot;Si&quot; =&gt; 14
  &quot;C&quot;  =&gt; 6
  &quot;P&quot;  =&gt; 15
  &quot;Nb&quot; =&gt; 41
    ⋮  =&gt;  ⋮

Z = get(dictAtomicNumbers, &quot;Rb&quot;, nothing)
  37

listElement(Z; fmt=Info)
  Element: rubidium
    symbol: Rb
    atomic number: Z = 37
    atomic weight (relative atomic mass): 85.468</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/dicts.jl#LL3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.dictElements" href="#CamiXon.dictElements"><code>CamiXon.dictElements</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">dictElements</code></pre><p>Source:  Standard atomic weights of the elements 2021 (IUPAC Technical Report)</p><p><strong>Example:</strong></p><pre><code class="language-none">dictElements
  Dict{Int64, Tuple{String, String, Any}} with 102 entries:
    5  =&gt; (&quot;boron&quot;, &quot;B&quot;, 10.81)
    56 =&gt; (&quot;barium&quot;, &quot;Ba&quot;, 137.33)
    35 =&gt; (&quot;bromine&quot;, &quot;Br&quot;, 79.904)
    55 =&gt; (&quot;caesium&quot;, &quot;Cs&quot;, 132.91)
    60 =&gt; (&quot;neodymium&quot;, &quot;Nd&quot;, 144.24)
    30 =&gt; (&quot;zinc&quot;, &quot;Zn&quot;, 65.38)
     ⋮ =&gt;            ⋮

get(dictElements, 37, nothing)
  (&quot;rubidium&quot;, &quot;Rb&quot;, 85.468)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/dicts.jl#LL48-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.dictIsotopes" href="#CamiXon.dictIsotopes"><code>CamiXon.dictIsotopes</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">dictIsotopes</code></pre><p>Sources: AME2020, LINDC(NDS)-0794 and INDC(NDS)-0833</p><p><strong>Example:</strong></p><pre><code class="language-none">dictIsotopes
  Dict{Tuple{Int64, Int64}, Tuple{String, String, Int64, Int64, Int64, Float64, Float64, Real, Int64, Float64, Float64, Any, Any}} with 341 entries:
    (71, 175) =&gt; (&quot;¹⁷⁵Lu&quot;, &quot;lutetium&quot;, 71, 175, 104, 5.37, 174.941, 7//2, 1, 1.0e…
    (40, 92)  =&gt; (&quot;⁹²Zr&quot;, &quot;zirconium&quot;, 40, 92, 52, 4.3057, 91.905, 0, 1, 1.0e100,…
    (48, 111) =&gt; (&quot;¹¹¹Cd&quot;, &quot;cadmium&quot;, 48, 111, 63, 4.5845, 110.904, 1//2, 1, 1.0e…
    (72, 176) =&gt; (&quot;¹⁷⁶Hf&quot;, &quot;hafnium&quot;, 72, 176, 104, 5.3286, 175.941, 0, 1, 1.0e10…
    (30, 68)  =&gt; (&quot;⁶⁸Zn&quot;, &quot;zinc&quot;, 30, 68, 38, 3.9658, 67.9248, 0, 1, 1.0e100, 0.0…
    (76, 184) =&gt; (&quot;¹⁸⁴Os&quot;, &quot;osmium&quot;, 76, 184, 108, 5.3823, 183.952, 0, 1, 5.6e13,…
    (54, 129) =&gt; (&quot;¹²⁹Xe&quot;, &quot;xenon&quot;, 54, 129, 75, 4.7775, 128.905, 1//2, 1, 1.0e10…
        ⋮     =&gt;                                ⋮

get(dictIsotopes, (37,87), nothing)
  (&quot;⁸⁷Rb&quot;, &quot;rubidium&quot;, 37, 87, 50, 4.1989, 86.90918053, 3//2, -1, 4.97e10, 2.75129, 0.1335, 27.83)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/4a10c9363a532a04222e1e9fc09557388f06cabb/src/dicts.jl#LL178-L198">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CamiXon.dictAtomicNumbers"><code>CamiXon.dictAtomicNumbers</code></a></li><li><a href="#CamiXon.dictElements"><code>CamiXon.dictElements</code></a></li><li><a href="#CamiXon.dictIsotopes"><code>CamiXon.dictIsotopes</code></a></li><li><a href="#CamiXon.Adams"><code>CamiXon.Adams</code></a></li><li><a href="#CamiXon.Atom"><code>CamiXon.Atom</code></a></li><li><a href="#CamiXon.Codata"><code>CamiXon.Codata</code></a></li><li><a href="#CamiXon.Def"><code>CamiXon.Def</code></a></li><li><a href="#CamiXon.Element"><code>CamiXon.Element</code></a></li><li><a href="#CamiXon.FITS_HDU"><code>CamiXon.FITS_HDU</code></a></li><li><a href="#CamiXon.FITS_data"><code>CamiXon.FITS_data</code></a></li><li><a href="#CamiXon.FITS_header"><code>CamiXon.FITS_header</code></a></li><li><a href="#CamiXon.FITS_name"><code>CamiXon.FITS_name</code></a></li><li><a href="#CamiXon.FITS_table"><code>CamiXon.FITS_table</code></a></li><li><a href="#CamiXon.FORTRAN_format"><code>CamiXon.FORTRAN_format</code></a></li><li><a href="#CamiXon.Grid"><code>CamiXon.Grid</code></a></li><li><a href="#CamiXon.Isotope"><code>CamiXon.Isotope</code></a></li><li><a href="#CamiXon.NamedValue"><code>CamiXon.NamedValue</code></a></li><li><a href="#CamiXon.Orbit"><code>CamiXon.Orbit</code></a></li><li><a href="#CamiXon.Pos"><code>CamiXon.Pos</code></a></li><li><a href="#CamiXon.SpinOrbit"><code>CamiXon.SpinOrbit</code></a></li><li><a href="#CamiXon.Term"><code>CamiXon.Term</code></a></li><li><a href="#CamiXon.Value"><code>CamiXon.Value</code></a></li><li><a href="#CamiXon.VectorRational"><code>CamiXon.VectorRational</code></a></li><li><a href="#CamiXon.CGC-NTuple{6, Real}"><code>CamiXon.CGC</code></a></li><li><a href="#CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.INSCH</code></a></li><li><a href="#CamiXon.OUTSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T&lt;:Real"><code>CamiXon.OUTSCH</code></a></li><li><a href="#CamiXon.RH1s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH1s</code></a></li><li><a href="#CamiXon.RH2p-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH2p</code></a></li><li><a href="#CamiXon.a_coeff-NTuple{5, Int64}"><code>CamiXon.a_coeff</code></a></li><li><a href="#CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_inward</code></a></li><li><a href="#CamiXon.adams_moulton_iterate-Union{Tuple{T}, Tuple{NTuple{4, T}, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_iterate</code></a></li><li><a href="#CamiXon.adams_moulton_master-NTuple{4, Any}"><code>CamiXon.adams_moulton_master</code></a></li><li><a href="#CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_normalized</code></a></li><li><a href="#CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_outward</code></a></li><li><a href="#CamiXon.adams_moulton_patch-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_patch</code></a></li><li><a href="#CamiXon.adams_moulton_prepare-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_prepare</code></a></li><li><a href="#CamiXon.adams_moulton_solve-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T&lt;:Real"><code>CamiXon.adams_moulton_solve</code></a></li><li><a href="#CamiXon.autoGrid-Tuple{Atom, Orbit, Type}"><code>CamiXon.autoGrid</code></a></li><li><a href="#CamiXon.autoNtot-Tuple{Orbit}"><code>CamiXon.autoNtot</code></a></li><li><a href="#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real"><code>CamiXon.autoPrecision</code></a></li><li><a href="#CamiXon.autoRmax-Tuple{Atom, Orbit}"><code>CamiXon.autoRmax</code></a></li><li><a href="#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.autoSteps</code></a></li><li><a href="#CamiXon.b_coeff-NTuple{5, Int64}"><code>CamiXon.b_coeff</code></a></li><li><a href="#CamiXon.bernoulli_numbers-Tuple{Int64}"><code>CamiXon.bernoulli_numbers</code></a></li><li><a href="#CamiXon.bohrformula-Tuple{Int64, Int64}"><code>CamiXon.bohrformula</code></a></li><li><a href="#CamiXon.calibrationReport-Tuple{Any, Any, Codata}"><code>CamiXon.calibrationReport</code></a></li><li><a href="#CamiXon.canonical_partitions"><code>CamiXon.canonical_partitions</code></a></li><li><a href="#CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.castAdams</code></a></li><li><a href="#CamiXon.castAtom-Tuple{}"><code>CamiXon.castAtom</code></a></li><li><a href="#CamiXon.castCodata-Tuple{Int64}"><code>CamiXon.castCodata</code></a></li><li><a href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T&lt;:Real"><code>CamiXon.castDef</code></a></li><li><a href="#CamiXon.castElement-Tuple{}"><code>CamiXon.castElement</code></a></li><li><a href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>CamiXon.castGrid</code></a></li><li><a href="#CamiXon.castIsotope-Tuple{}"><code>CamiXon.castIsotope</code></a></li><li><a href="#CamiXon.castNamedValue-Tuple{Value}"><code>CamiXon.castNamedValue</code></a></li><li><a href="#CamiXon.castOrbit-Tuple{}"><code>CamiXon.castOrbit</code></a></li><li><a href="#CamiXon.castVectorRational-Tuple{Vector{Rational{Int64}}}"><code>CamiXon.castVectorRational</code></a></li><li><a href="#CamiXon.cast_FITS_name-Tuple{String}"><code>CamiXon.cast_FITS_name</code></a></li><li><a href="#CamiXon.cast_FORTRAN_datatype-Tuple{String}"><code>CamiXon.cast_FORTRAN_datatype</code></a></li><li><a href="#CamiXon.cast_FORTRAN_format-Tuple{String}"><code>CamiXon.cast_FORTRAN_format</code></a></li><li><a href="#CamiXon.convertUnit-Tuple{Any, Any}"><code>CamiXon.convertUnit</code></a></li><li><a href="#CamiXon.count_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.count_nodes</code></a></li><li><a href="#CamiXon.createSpinOrbit-Tuple{Orbit}"><code>CamiXon.createSpinOrbit</code></a></li><li><a href="#CamiXon.createTerm-Tuple{Int64}"><code>CamiXon.createTerm</code></a></li><li><a href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>CamiXon.create_adams_moulton_weights</code></a></li><li><a href="#CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiXon.create_lagrange_differentiation_matrix</code></a></li><li><a href="#CamiXon.demo_hydrogen-Tuple{}"><code>CamiXon.demo_hydrogen</code></a></li><li><a href="#CamiXon.edges"><code>CamiXon.edges</code></a></li><li><a href="#CamiXon.factorialbig-Tuple{Int64}"><code>CamiXon.factorialbig</code></a></li><li><a href="#CamiXon.faulhaber_polynom-Tuple{Int64}"><code>CamiXon.faulhaber_polynom</code></a></li><li><a href="#CamiXon.faulhaber_summation-Tuple{Int64, Int64}"><code>CamiXon.faulhaber_summation</code></a></li><li><a href="#CamiXon.fdiff_adams_bashford_expansion_coeffs-Tuple{Int64}"><code>CamiXon.fdiff_adams_bashford_expansion_coeffs</code></a></li><li><a href="#CamiXon.fdiff_adams_moulton_expansion_coeffs-Tuple{Int64}"><code>CamiXon.fdiff_adams_moulton_expansion_coeffs</code></a></li><li><a href="#CamiXon.fdiff_differentiation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.fdiff_differentiation</code></a></li><li><a href="#CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>CamiXon.fdiff_differentiation_expansion_coeffs</code></a></li><li><a href="#CamiXon.fdiff_expansion"><code>CamiXon.fdiff_expansion</code></a></li><li><a href="#CamiXon.fdiff_expansion_weights"><code>CamiXon.fdiff_expansion_weights</code></a></li><li><a href="#CamiXon.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.fdiff_interpolation</code></a></li><li><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>CamiXon.fdiff_interpolation_expansion_coeffs</code></a></li><li><a href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>CamiXon.fdiff_weight</code></a></li><li><a href="#CamiXon.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T&lt;:Number"><code>CamiXon.findIndex</code></a></li><li><a href="#CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_all</code></a></li><li><a href="#CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_first</code></a></li><li><a href="#CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_last</code></a></li><li><a href="#CamiXon.fits_add_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_add_key</code></a></li><li><a href="#CamiXon.fits_combine-Tuple{String, String}"><code>CamiXon.fits_combine</code></a></li><li><a href="#CamiXon.fits_copy"><code>CamiXon.fits_copy</code></a></li><li><a href="#CamiXon.fits_create"><code>CamiXon.fits_create</code></a></li><li><a href="#CamiXon.fits_delete_key-Tuple{String, Int64, String}"><code>CamiXon.fits_delete_key</code></a></li><li><a href="#CamiXon.fits_edit_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_edit_key</code></a></li><li><a href="#CamiXon.fits_extend"><code>CamiXon.fits_extend</code></a></li><li><a href="#CamiXon.fits_info-Tuple{FITS_HDU}"><code>CamiXon.fits_info</code></a></li><li><a href="#CamiXon.fits_read-Tuple{String}"><code>CamiXon.fits_read</code></a></li><li><a href="#CamiXon.fits_rename_key-Tuple{String, Int64, String, String}"><code>CamiXon.fits_rename_key</code></a></li><li><a href="#CamiXon.frac-Tuple{Rational{Int64}}"><code>CamiXon.frac</code></a></li><li><a href="#CamiXon.generalized_laguerreL-Union{Tuple{T}, Tuple{U}, Tuple{Int64, U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.generalized_laguerreL</code></a></li><li><a href="#CamiXon.generalized_laguerre_coords-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.generalized_laguerre_coords</code></a></li><li><a href="#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Na</code></a></li><li><a href="#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nb</code></a></li><li><a href="#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nlctp</code></a></li><li><a href="#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.get_Nmin</code></a></li><li><a href="#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nuctp</code></a></li><li><a href="#CamiXon.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_differentiation</code></a></li><li><a href="#CamiXon.grid_integration-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.grid_integration</code></a></li><li><a href="#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.gridfunction</code></a></li><li><a href="#CamiXon.gridname-Tuple{Int64}"><code>CamiXon.gridname</code></a></li><li><a href="#CamiXon.harmonic_number-Tuple{Int64, Int64}"><code>CamiXon.harmonic_number</code></a></li><li><a href="#CamiXon.harmonic_number-Tuple{Int64}"><code>CamiXon.harmonic_number</code></a></li><li><a href="#CamiXon.hydrogenic_reduced_wavefunction-Tuple{Atom, Orbit, Grid, Def}"><code>CamiXon.hydrogenic_reduced_wavefunction</code></a></li><li><a href="#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.initE</code></a></li><li><a href="#CamiXon.integer_partitions"><code>CamiXon.integer_partitions</code></a></li><li><a href="#CamiXon.isforward-Tuple{Any}"><code>CamiXon.isforward</code></a></li><li><a href="#CamiXon.isregular-Tuple{Any}"><code>CamiXon.isregular</code></a></li><li><a href="#CamiXon.istriangle-Tuple{Real, Real, Real}"><code>CamiXon.istriangle</code></a></li><li><a href="#CamiXon.laguerreL-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.laguerreL</code></a></li><li><a href="#CamiXon.laguerre_coords-Tuple{Int64}"><code>CamiXon.laguerre_coords</code></a></li><li><a href="#CamiXon.latexIsotopeTable-Tuple{Int64, Int64}"><code>CamiXon.latexIsotopeTable</code></a></li><li><a href="#CamiXon.listAtom-Tuple{Int64, Int64, Int64}"><code>CamiXon.listAtom</code></a></li><li><a href="#CamiXon.listAtoms-Tuple{Int64, Int64, Int64}"><code>CamiXon.listAtoms</code></a></li><li><a href="#CamiXon.listCodata-Tuple{Codata}"><code>CamiXon.listCodata</code></a></li><li><a href="#CamiXon.listElement-Tuple{Int64}"><code>CamiXon.listElement</code></a></li><li><a href="#CamiXon.listElements-Tuple{Int64, Int64}"><code>CamiXon.listElements</code></a></li><li><a href="#CamiXon.listIsotope-Tuple{Int64, Int64}"><code>CamiXon.listIsotope</code></a></li><li><a href="#CamiXon.listIsotopes-Tuple{Int64, Int64}"><code>CamiXon.listIsotopes</code></a></li><li><a href="#CamiXon.log10_characteristic_power-Tuple{Any}"><code>CamiXon.log10_characteristic_power</code></a></li><li><a href="#CamiXon.log10_mantissa-Tuple{Any}"><code>CamiXon.log10_mantissa</code></a></li><li><a href="#CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matG</code></a></li><li><a href="#CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T&lt;:Real"><code>CamiXon.matMinv</code></a></li><li><a href="#CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matσ</code></a></li><li><a href="#CamiXon.parse_FITS_TABLE-Tuple{FITS_HDU}"><code>CamiXon.parse_FITS_TABLE</code></a></li><li><a href="#CamiXon.pascal_next-Tuple{Vector{Int64}}"><code>CamiXon.pascal_next</code></a></li><li><a href="#CamiXon.pascal_triangle-Tuple{Int64}"><code>CamiXon.pascal_triangle</code></a></li><li><a href="#CamiXon.permutations_unique_count-Tuple{Vector{Vector{Int64}}, Int64}"><code>CamiXon.permutations_unique_count</code></a></li><li><a href="#CamiXon.pochhammer-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Real"><code>CamiXon.pochhammer</code></a></li><li><a href="#CamiXon.polynom_derivative-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.polynom_derivative</code></a></li><li><a href="#CamiXon.polynom_derivatives-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.polynom_derivatives</code></a></li><li><a href="#CamiXon.polynom_derivatives_all-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.polynom_derivatives_all</code></a></li><li><a href="#CamiXon.polynom_power-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Real"><code>CamiXon.polynom_power</code></a></li><li><a href="#CamiXon.polynom_powers-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Real"><code>CamiXon.polynom_powers</code></a></li><li><a href="#CamiXon.polynom_primitive-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.polynom_primitive</code></a></li><li><a href="#CamiXon.polynom_product-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Vector{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.polynom_product</code></a></li><li><a href="#CamiXon.polynom_product_expansion-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:Real"><code>CamiXon.polynom_product_expansion</code></a></li><li><a href="#CamiXon.polynomial-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.polynomial</code></a></li><li><a href="#CamiXon.reduce_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.reduce_wavefunction</code></a></li><li><a href="#CamiXon.restore_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.restore_wavefunction</code></a></li><li><a href="#CamiXon.select125-Tuple{Any}"><code>CamiXon.select125</code></a></li><li><a href="#CamiXon.step125-Tuple{Real}"><code>CamiXon.step125</code></a></li><li><a href="#CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepcenters</code></a></li><li><a href="#CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepedges</code></a></li><li><a href="#CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.steps</code></a></li><li><a href="#CamiXon.strRational-Tuple{T} where T&lt;:Union{Int64, BigInt, Rational}"><code>CamiXon.strRational</code></a></li><li><a href="#CamiXon.strValue-Tuple{Value}"><code>CamiXon.strValue</code></a></li><li><a href="#CamiXon.sub-Tuple{T} where T&lt;:Real"><code>CamiXon.sub</code></a></li><li><a href="#CamiXon.sup-Tuple{T} where T&lt;:Real"><code>CamiXon.sup</code></a></li><li><a href="#CamiXon.texp-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Real"><code>CamiXon.texp</code></a></li><li><a href="#CamiXon.threeJsymbol-NTuple{6, Real}"><code>CamiXon.threeJsymbol</code></a></li><li><a href="#CamiXon.trapezoidal_integration-NTuple{4, Any}"><code>CamiXon.trapezoidal_integration</code></a></li><li><a href="#CamiXon.trapezoidal_weights-Tuple{Int64}"><code>CamiXon.trapezoidal_weights</code></a></li><li><a href="#CamiXon.triangle_coefficient-Tuple{Real, Real, Real}"><code>CamiXon.triangle_coefficient</code></a></li><li><a href="#CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.updateAdams!</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 27 October 2022 20:50">Thursday 27 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
