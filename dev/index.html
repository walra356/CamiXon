<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CamiXon.jl</title><link rel="canonical" href="https://walra356.github.io/CamiXon.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CamiXon.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Table-of-contents"><span>Table of contents</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/walra356/CamiXon.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CamiXon.jl"><a class="docs-heading-anchor" href="#CamiXon.jl">CamiXon.jl</a><a id="CamiXon.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CamiXon.jl" title="Permalink"></a></h1><p>A package for image analysis of backscattered light</p><hr/><h2 id="Table-of-contents"><a class="docs-heading-anchor" href="#Table-of-contents">Table of contents</a><a id="Table-of-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-contents" title="Permalink"></a></h2><ul><li><a href="#CamiXon.jl">CamiXon.jl</a></li><ul><li><a href="#Table-of-contents">Table of contents</a></li><li><a href="#Introduction">Introduction</a></li></ul></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>CamiXon is a package for the numerical solution of the radial Schrödinger equation allowing for screening. In Hartree atomic units (a.u.) the equation</p><p>Numerical methods are indispensable for the structure analysis of many-electron atoms. We have selected a numerical solution of de radial wave equation for the case of a single electron in the central potential field of a many electron atom. Along with more advanced methods examples like this can be found in the book \emph{Atomic Structure Theory} by Walter R.\,Johnson \cite{Johnson}.</p><p>Our starting point is the 1D Schrödinger equation for one electron, acting as a <em>spectator</em> in the atomic central field in the presence screening by the other electrons (the <em>screening</em> electrons). In Hartree atomic units (a.u.) this equation is given by</p><p class="math-container">\[\tilde{\chi}_{l}^{\prime\prime}+2\left[Z_{\mathrm{eff}}(\rho)/\rho-l(l+1)/2\rho^{2}+\varepsilon_{l}\right]\tilde{\chi}_{l}=0,
````
where $\tilde{\chi}_{l}(\rho)=\rho\tilde{R}_{l}(\rho)$ is the reduced
radial wavefunction and $\varepsilon_{l}=-\kappa_{l}^{2}$ is the
corresponding binding energy in Hartree atomic units. As compared
to the hydrogenic case - see Eq.\,(\ref{1D-SchrodingerEquation-2})
- the atomic number has been replaced by $Z_{\mathrm{eff}}(\rho)$,
the \emph{effective nuclear charge} at distance $\rho$ from the atomic
center.\index{Effective!nuclear charge}\index{Nuclear!charge!effective}
In other words, the energy of the electron in the Coulomb field of
the nucleus, $-Z/\rho$, is replaced by a central potential,
$U_{\mathrm{CF}}(\rho)=-Z_{\mathrm{eff}}(\rho)/\rho$,
composed of the bare Coulomb contribution and the screening energy
$U_{\mathrm{scr}}(\rho)$,
\]</p><p>math Z<em>{\mathrm{eff}}(\rho)/\rho=Z/\rho-U</em>{\mathrm{scr}}(\rho),</p><pre><code class="language-none">
with boundary conditions $U_{\mathrm{scr}}(0)=Z$ and
$\mathrm{lim}_{\rho\rightarrow\infty}U_{\mathrm{scr}}(\rho)=Z_{c}/\rho$
- see e.g.~Fig.\,\ref{fig:h.1.he}. Here $Z$ is the atomic number
and $Z_{c}$ the Rydberg charge. Within these boundary conditions
we can optimize the central potential while preserving the bare Coulomb
field close to the nucleus and the Rydberg potential in the far field.
The price we pay is that the radial Schrödinger
equation has to be solved numerically by radial integration. Our strategy will
be to use both *inward* and *outward* integration and match
the two branches by *equating the two solutions* for the *wavefunction*
and its *derivative* at a point near the classical turning point
of the radial motion.


![Image](./assets/H1_3d.png)
</code></pre><p>math y[n+1]-y[n] = -\frac{h \nabla}{(1-\nabla)ln(1-\nabla)}f[n+1]=h (\sum<em>{p=0}^{\infty}B</em>p\nabla^p)f[n+1].</p><pre><code class="language-none">
## Codata
</code></pre><p>@docs Codata Value strValue(f::Value) NamedValue castNamedValue(val::Value; name=&quot; &quot;, comment=&quot; &quot;) castCodata(year::Int) listCodata(codata::Codata) convertUnit(val, codata::Codata; unitIn=&quot;Hartree&quot;, unitOut=&quot;xHz&quot;) myconvert(T::Type, val::V) where V &lt;: Number calibrationReport(E, Ecal, codata::Codata; unitIn=&quot;Hartree&quot;)</p><pre><code class="language-none">
## Atomic properties
</code></pre><p>@docs Atom castAtom(;Z=1, Q=0, M=1.0, I=1//2, gI=5.5, msg=true) Orbit castOrbit(;n=1, ℓ=0, msg=true) SpinOrbit createSpinOrbit(o::Orbit; up=true, msg=true) Term createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true) bohrformula(Z::Int, n::Int) mendeleev(Z::Int)</p><pre><code class="language-none">
## Adams-Moulton integration

The Adams-Moulton method is used for numerical integration of the reduces
radial wave equation. In the present implementation it is constructed on top
the objects [`Atom`](@ref), [`Orbit`](@ref), [`Grid`](@ref), [`Def`](@ref)
and [`Adams`](@ref) using 5 globally defined instances called `atom`, `orbit`,
`grid`, `def` and `adams`.

### Pos

The `Pos` object serves within [`Def`](@ref) object to contain the position
indices `def.Na`, `def.Nb`, `def.Nlctp`, `def.Nmin`, `def.Nuctp` used in
Adams-Moulton integration. These positions are contained in the fields
`def.pos.Na`, `def.pos.Nb`, `def.pos.Nlctp`, `def.pos.Nmin`, `def.pos.Nuctp`.
Alternatively, they can be determined with the functions [`get_Na`](@ref),
[`get_Nb`](@ref), [`get_Nlctp`](@ref), [`get_Nmin`](@ref), [`get_Nuctp`](@ref).</code></pre><p>@docs Pos</p><pre><code class="language-none">
### Def

The `Def` object serves to define the problem to be solved and to contain in
the field `def.Z` the solution as a discrete function of `N` elements.
</code></pre><p>@docs Def{T} castDef(grid::Grid{T}, atom::Atom, orbit::Orbit) where T &lt;: Real initE(def::Def{T}; E=nothing) where T&lt;:Real get<em>Na(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real get</em>Nb(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real get<em>Nlctp(E::T, def::Def{T}) where T&lt;:Real get</em>Nmin(def::Def{T}) where T&lt;:Real get<em>Nuctp(E::T, def::Def{T}) where T&lt;:Real get</em>nodes(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</p><pre><code class="language-none"></code></pre><p>@docs matG(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real matσ(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real matMinv(E::T, grid::Grid{T}, def::Def{T}, amEnd::T) where T&lt;:Real OUTSCH(grid::Grid{T}, def::Def{T}, σ::Vector{Matrix{T}}) where T&lt;:Real OUTSCH_WKB(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</p><pre><code class="language-none">
### Adams

The `Adams` object serves to hold the Adams-Moulton integration matrices
`matG`, `matσ`, `matMinv` as well as the *actual* normalized solution `Z` in
the form of a tabulated function of `N` elements.
</code></pre><p>@docs Adams castAdams(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real updateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T&lt;:Real INSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real adams<em>moulton</em>inward(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real adams<em>moulton</em>outward(def::Def{T}, adams::Adams{T}) where T&lt;:Real adams<em>moulton</em>normalized(Z::Vector{Complex{T}}, ΔQ::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real solve<em>adams</em>moulton(E::T, grid::Grid{T}, def::Def{T}, adams::Adams) where T&lt;:Real</p><pre><code class="language-none">
## Grid

The `Grid` object is the backbone for the numerical procedure on a non-uniform
grid. Its principal fields are `grid.r` and `grid.r′`, which are discrete
functions of `N` elements representing the grid function and its derivative.
</code></pre><p>@docs Grid{T} gridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T &lt;: Real castGrid(ID::Int, N::Int, T::Type; h=1, r0=0.001,  p=5, coords=[0,1], epn=7, k=7, msg=true) autoRmax(atom::Atom, orbit::Orbit) autoNtot(orbit::Orbit) autoPrecision(Rmax::T, orbit::Orbit) where T&lt;:Real autoSteps(ID::Int, Ntot::Int, Rmax::T; p=5, coords=[0,1]) where T&lt;:Real autoGrid(atom::Atom, orbit::Orbit, codata::Codata, T::Type ; p=0, coords=[], Nmul=1, epn=7, k=7, msg=true) grid<em>lagrange</em>derivative(f::Vector{T}, grid::Grid{T}; k=5) where T&lt;:Real grid<em>trapezoidal</em>integral(f::Vector{T}, n1::Int, n2::Int, grid::Grid{T}) where T&lt;:Real</p><pre><code class="language-none">
## FITS

FITS stands for &#39;Flexible Image Transport System&#39;. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.

Within CamiXon only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.

A FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.

By the command `f = fits_read(filnam)` we asign a collection of `FITS_HDU` objects from the file `filnam` to the variable `f`.

### FITS - Types
</code></pre><p>@docs FITS<em>HDU{T,V} FITS</em>header FITS<em>data FITS</em>table FITS_name</p><pre><code class="language-none">
### FITS - HDU Methods
</code></pre><p>@docs fits<em>info(hdu::FITS</em>HDU) parse<em>FITS</em>TABLE(hdu::FITS_HDU)</p><pre><code class="language-none">
### FITS - File Methods
</code></pre><p>@docs cast<em>FITS</em>name(filename::String) fits<em>combine(filnamFirst::String, filnamLast::String; protect=true) fits</em>copy(filenameA::String, filenameB::String=&quot; &quot;; protect=true) fits<em>create(filename::String, data=[]; protect=true) fits</em>extend(filename::String, data<em>extend, hdutype=&quot;IMAGE&quot;) fits</em>read(filename::String)</p><pre><code class="language-none">
### FITS - Key Methods
</code></pre><p>@docs fits<em>add</em>key(filename::String, hduindex::Int, key::String, val::Real, com::String) fits<em>delete</em>key(filename::String, hduindex::Int, key::String) fits<em>edit</em>key(filename::String, hduindex::Int, key::String, val::Real, com::String) fits<em>rename</em>key(filename::String, hduindex::Int, keyold::String, keynew::String)</p><pre><code class="language-none">
## FORTRAN
</code></pre><p>@docs FORTRAN<em>format cast</em>FORTRAN<em>format(str::String) cast</em>FORTRAN_datatype(str::String)</p><pre><code class="language-none">
## Plotting
</code></pre><p>@docs step125(x::Real) select125(x) steps(x::Vector{T} where T&lt;:Real) stepcenters(x::Vector{T} where T&lt;:Real) stepedges(x::Vector{T} where T&lt;:Real) edges(px, Δx=1.0, x0=0.0)</p><pre><code class="language-none">
## Search and conversion tools
</code></pre><p>@docs find<em>all(A::Union{String,AbstractArray{T,1}}, a::T...; count=false)  where T find</em>first(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T find_last(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T</p><pre><code class="language-none">
## Math
</code></pre><p>@docs bernoulli<em>numbers(nmax::Int) canonical</em>partitions(n::Int, m=0; header=true, reverse=true) faulhaber<em>polynom(p::Int) faulhaber</em>summation(n::Int, p::Int; T=Int) harmonic<em>number(n::Int, p::Int) harmonic</em>number(n::Int) integer<em>partitions(n::Int, m=0; transpose=false, count=false) log10</em>characteristic<em>power(x) log10</em>mantissa(x) permutations<em>unique</em>count(p::Array{Array{Int64,1},1}, i::Int) pascal<em>triangle(nmax::Int) pascal</em>next(a::Vector{Int}) polynomial(coords::Vector{T}, x::T; deriv=0) where T&lt;:Number polynom<em>derivative(coords::Vector{&lt;:Number}) polynom</em>derivatives(coords::Vector{&lt;:Number}; deriv=0) polynom<em>derivatives</em>all(coords::Vector{&lt;:Number}) polynom<em>power(coords::Vector{&lt;:Number}, power::Int) polynom</em>powers(coords::Vector{&lt;:Number}, pmax::Int) polynom<em>primitive(coeffs::Vector{&lt;:Number}) polynom</em>product(a::Vector{T}, b::Vector{T}) where T&lt;:Number polynom<em>product</em>expansion(a::Vector{T}, b::Vector{T}, p::Int) where T&lt;:Number texp(x::T, a::T, p::Int) where T &lt;: Real VectorRational normalize_VectorRational(vec::Vector{Rational{Int}})</p><pre><code class="language-none">
## Finite-difference methods

### Finite differences

Consider the analytic function ``f`` tabulated in *forward order*  (growing index) at ``n`` positions on a *grid*. The *finite difference* of two adjacent values on a *uniform grid* is defined by the relation
</code></pre><p>math \nabla f[n] = f[n]-f[n-1].</p><pre><code class="language-none">
This is called the finite difference in *backward difference* notation. In this notation the  ``k^{th}``-*order backward difference* (which involves ``k+1`` points) is defined by a *weighted sum* over the function values in backward order, ``f[n],\ \ldots,\ f[n-k]``,
</code></pre><p>math \nabla^k f[n] = f[n] + c<em>1^kf[n-1] + \cdots + c</em>k^kf[n-k] = \sum<em>{j=0}^{k} c</em>j^kf[n-j].</p><pre><code class="language-none">
The ``k+1`` coefficients ``c_{j}^{k}=(-1)^{j}\binom{k}{j}`` are *weight factors* (short: *weights*) defining the summation. Note that ``c_{0}^{k}\equiv1`` and ``c_{k}^{k}=(-1)^{k}``. As the function ``f`` is tabulated in forward order it is good practice to change dummy index to also write the summation in forward order (coefficients in backward order),
</code></pre><p>math \nabla^k f[n] = \sum_{j=0}^{k} c^k[j]f[n-k+j],</p><pre><code class="language-none">where ``c^k[j] \equiv c_{k-j}^k``.    

Functions:  

[`f_diff_weight(k,j)`](@ref) `` \rightarrow c_j^k``

[`f_diff_weights(k)`](@ref) `` \rightarrow \ c^k ≡ [c_k^k,\ c_1^k,\ldots,\ c_0^k]``

[`f_diff_weights_array(kmax)`](@ref) `` \rightarrow \ [\ c^0,\ c^1,\ \ldots,\ c^{kmax} ]``
</code></pre><p>@docs f<em>diff</em>weight(k::Int, i::Int) f<em>diff</em>weights(k::Int) f<em>diff</em>weights_array(kmax::Int)</p><pre><code class="language-none">
### Finite difference expansion

Finite-difference calculus builds on the *finite-difference expansion*, in practice truncated at *order* ``k``,
</code></pre><p>math \sum<em>{p=0}^{\infty}a</em>{p}\nabla^{p}f[n]=\sum<em>{p=0}^{k}a</em>{p}\nabla^{p}f[n]+\cdots.</p><pre><code class="language-none">
By choosing the order sufficiently high the expansion can be approximated to any desired level of accuracy. A finite-difference expansion of order ``k`` is defined by ``k+1`` *finite-difference expansion coefficients*, above denoted by ``a_{0},\ \ldots,\ a_{k}``. Note that both the coefficients and the operators appear in forward order. It takes some bookkeeping to rewrite the expansion in the form of a *weighted sum* over the ``k+1`` *function values* ``f[n],\ldots,f[n-k]`` (note the *backward order*). Substituting the finite-difference expression for ``\nabla^k``, we obtain
</code></pre><p>math \sum<em>{p=0}^{k}a</em>{p}\nabla^{p}f[n]=\sum<em>{p=0}^{k}a</em>{p}\sum<em>{j=0}^{p}c</em>{j}^{i}f[n-j]=\sum<em>{j=0}^{k}\sum</em>{p=j}^{k}a<em>{p}c</em>{j}^{p}f[n-j]=\sum<em>{j=0}^{k}b</em>{j}^{k}f[n-j],</p><pre><code class="language-none">
where the weighted summation is defined by the *weights* ``b_{j}^{k}=\sum_{p=j}^{k}a_{p}c_{j}^{p}``, with ``j=0,\ \ldots,\ k``. By a change of dummy index we write the summation in *forward order*
</code></pre><p>math \sum<em>{p=0}^{k}a</em>{p}\nabla^{p}f[n]=\sum_{j=0}^{k}b^k[j]f[n-k+j],</p><pre><code class="language-none">where ``b^k[j] \equiv b_{k-j}^k``.  
Note that the *weights vector* ``b^k`` contains the weights in backward order. It is generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), where `∇ =`[` f_diff_weights_array(kmax)`](@ref).

Functions:

`coeffs` = ``[a_0,\ \ldots,\ a_k]``

[`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow b^k \equiv [b_k^k,\ ,\ldots,\ b_0^k]``
</code></pre><p>@docs f<em>diff</em>expansion_weights(coeffs, ∇)</p><pre><code class="language-none">### Lagrangian interpolation

Using the definition of the finite difference we can express the relation between ``f[n]`` and ``f[n+1]`` in operator form,</code></pre><p>math f[n]=(1-\nabla)f[n+1].</p><pre><code class="language-none">By formal inversion of the operator we have</code></pre><p>math f[n+1] = (1 - \nabla)^{-1} f[n] \equiv \sum_{p=0}^{\infty}∇^p f[n],</p><pre><code class="language-none"></code></pre><p>math f[n+2] = (1 - \nabla)^{-2} f[n] \equiv \sum_{p=0}^{\infty}p∇^p f[n],</p><pre><code class="language-none"></code></pre><p>math \vdots</p><pre><code class="language-none">
which can be generalized to the form of *lagrangian interpolation*,
</code></pre><p>math f[n+x] = (1 - \nabla)^{-x} f[n] \equiv \sum<em>{p=0}^{\infty}l</em>p(x)∇^p f[n],</p><pre><code class="language-none">
where ``l_0\equiv 1`` and ``l_p(x) = x(x+1)(x+2)\cdots(x+p-1)/p!`` for ``p&gt;0`` are the *finite-difference expansion coefficients* for *lagrangian interpolation*. These are generated by the function [`f_diff_expansion_coeffs_lagrange(k,x)`](@ref). Evaluating the finite-difference expansion up to order ``k`` we obtain
</code></pre><p>math f[n+x] =\sum<em>{p=0}^{k}l</em>p(x)\nabla^pf[n]= \sum<em>{j=0}^{k}r</em>j^k(x)f[n-j],</p><pre><code class="language-none">
where the ``k+1`` *weights* ``r_j^k(x)= \sum_{p=j}^{k} l_p(x) c_j^p`` are the  *lagrangian interpolation weights*.  After changing dummy index to bring the summation in forward order the expansion becomes</code></pre><p>math f[n+x] =\sum<em>{p=0}^{k}l</em>p(x)\nabla^pf[n]= \sum<em>{j=0}^{k}r</em>x^k[j]f[n-k+j],</p><pre><code class="language-none">where ``r^k_x[j] ≡ r_{k-j}^k(x)``. The weights vector ``r^k_x`` is generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ =` [`f_diff_weights_array(k)`](@ref).

Functions:

`coeffs` = [`f_diff_expansion_coeffs_lagrange(k,x)`](@ref) ``\rightarrow [l_0(x),\ \ldots,\ l_k(x)]``

`lagrangian interpolation weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow r^k_x ≡ [r_k^k(x),\ ,\ldots,\ r_0^k(x)]``
</code></pre><p>@docs</p><p>f<em>diff</em>expansion<em>coeffs</em>lagrange(k::Int, x::T) where T&lt;:Real summation<em>range(n::Int, i::Int, k::Int, μ::Int) f</em>diff<em>function</em>sequences(f, k::Int, μ=0) lagrange<em>interpolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, i=0) lagrange</em>extrapolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, e=2, μ=0)</p><pre><code class="language-none">### Lagrangian differentiation

To derive the *lagrangian differentiation* formulas we formally differentiate
</code></pre><p>math f[n+x] = (1 - \nabla)^{-x} f[n]</p><pre><code class="language-none">
with respect to ``x``.
</code></pre><p>math \frac{df}{dx}[n+x]=-ln(1-\nabla)\ (1-\nabla)^{-x}f[n]=\sum<em>{q=1}^{k}\tfrac{1}{q}∇^{q}\sum</em>{p=0}^{k}l_{p}(x)∇^{p}f[n]+\cdots.</p><pre><code class="language-none">
Rewriting the r.h.s. as a single summation in powers of ``\nabla`` for given values of ``n`` and ``x`` we obtain an expression of the form
</code></pre><p>math \frac{df}{dx}[n+x]=\sum<em>{p=1}^{k}l</em>{p}^{\prime}(x)\nabla^{p}f[n]+\cdots,</p><pre><code class="language-none">
where ``l_{p}^{\prime}(x)`` represents the *finite-difference expansion coefficients* for *lagrangian differentiation* at position ``n+x``. These coefficients are determined numerically by polynomial multiplication after adding the ``p=0`` term, ``l_{0}^{\prime}(x)\equiv 0``, to the first sum. The corresponding coefficient vector is generated in *forward order* by the function [`f_diff_expansion_coeffs_differentiation(k,x)`](@ref). Evaluating the finite-difference expansion up to order ``k`` we obtain
</code></pre><p>math \frac{df}{dx}[n+x]=\sum<em>{p=0}^{k}l</em>{p}^{\prime}(x)\nabla^{p}f[n]=\sum<em>{j=0}^{k}s</em>{j}^{k}(x)f[n-j],</p><pre><code class="language-none">
where the ``s_{j}^{k}(x)=\sum_{p=j}^{k}l_{p}^{\prime}(x)c_{j}^{p}`` are the ``k^{th}``-order lagrangian differentiation weights.  After changing dummy index to reverse the summation from backward to forward order the expansion becomes
</code></pre><p>math \frac{df}{dx}[n+x]]= \sum<em>{j=0}^{k}s^k</em>x[j]f[n-k+j],</p><pre><code class="language-none">where ``s^k_x[j] ≡ s^k_{k-j}(x)``. The weights vector ``s^k_x`` is generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ =` [`f_diff_weights_array(k)`](@ref).

Functions:

`coeffs` = [`f_diff_expansion_coeffs_differentiation(k,x)`](@ref) ``\rightarrow [l_0^{\prime}(x),\ \ldots,\ l_k^{\prime}(x)]``

`Lagrange differentiation weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``s^k_x[j] ≡ \rightarrow [s_k^k(x),\ ,\ldots,\ s_0^k(x)]``

`Lagrange differentiation weights` = [`create_lagrange_differentiation_weights(k,x) `](@ref) ``s^k_x[j] ≡ \rightarrow [s_k^k(x),\ ,\ldots,\ s_0^k(x)]``
</code></pre><p>@docs f<em>diff</em>expansion<em>coeffs</em>differentiation(k::Int, x::T) where T&lt;:Real create<em>lagrange</em>differentiation<em>weights(k::Int, x::T) where T&lt;:Real create</em>lagrange<em>differentiation</em>matrix(k::Int) lagrange_differentiation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=3, i=0)</p><pre><code class="language-none">
### Integration
</code></pre><p>@docs trapezoidal<em>weights(k::Int; rationalize=false, devisor=false) trapezoidal</em>integration(f, domain, weights)</p><pre><code class="language-none">
### Adams Method

#### Adams-Bashford expansion

The *Adams-Bashford integration step* is given by the expansion
</code></pre><p>math y[n+1]-y[n] = -\frac{h \nabla}{(1-\nabla)ln(1-\nabla)}f[n+1]=h (\sum<em>{p=0}^{\infty}B</em>p\nabla^p)f[n+1].</p><pre><code class="language-none">
A closed expression for the *Adams-Bashford expansion coefficients*, ``B_k``, is not available. As we already have a finite-difference expansion for the operator ``(1-∇)^{-1}``,
</code></pre><p>math \frac{1}{1-∇}\equiv\sum_{p=0}^{\infty}\nabla^p,</p><pre><code class="language-none">
we ask for the expansion of
</code></pre><p>math -\frac{∇}{ln(1-∇)}=(1-\frac{1}{2}∇-\frac{1}{24}∇^2-\frac{1}{12}∇^3+\cdots)f[n+1]= (\sum<em>{p=0}^{\infty}b</em>p\nabla^p)f[n+1].</p><pre><code class="language-none">
This is known as the *Adams-Moulton expansion*. Its coefficients are calculated numerically by the function `f_diff_expansion_adams_moulton_coeffs(k)`. The *Adams-Bashford expansion* is obtained as the polynomial product of the two expansions,
</code></pre><p>math (\sum<em>{p=0}^{\infty}B</em>p∇^p)f[n+1]=(\sum<em>{p=0}^{\infty}∇^p)(\sum</em>{p=0}^{\infty}b_p∇^p)f[n+1]=\ ( 1 + \frac{1}{2}\nabla + \frac{5}{12}\nabla^2 + \cdots)f[n+1].</p><pre><code class="language-none">
The coefficients ``B_p`` are calculated numerically with the function `f_diff_expansion_adams_bashford_coeffs(k)`. Evaluating the finite-difference expansion up to order ``k`` we obtain (after changing dummy index bring the summation in forward order)
</code></pre><p>math \sum<em>{p=0}^{k}B</em>p\nabla^pf[n]=\sum<em>{p=0}^{k}B</em>p\sum<em>{j=0}^{p} c</em>j^if[n-j]= \sum<em>{j=0}^{k}A</em>j^k(x)f[n-j]= \sum<em>{j=0}^{k}A</em>{k-j}^k(x)f[n-k+j],</p><pre><code class="language-none">
where the ``A_j^k(x)= \sum_{p=j}^{k} B_pc_j^p`` are the ``(k+1)``-point *Adams-Bashford integration weights*.

Function:

`coeffs` = [`f_diff_expansion_coeffs_adams_bashford(k)`](@ref) ``\rightarrow [B_k^k(x),\ ,\ldots,\ B_0^k(x)]``

`adams_bashford_integration_weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow [A_k^k(x),\ ,\ldots,\ A_0^k(x)]``
</code></pre><p>@docs f<em>diff</em>expansion<em>coeffs</em>adams_bashford(k::Int)</p><pre><code class="language-none">
### Adams-Moulton expansion

The *Adams-Moulton integration* step is given by the expansion
</code></pre><p>math y[n+1]-y[n] = -\frac{\nabla}{ln(1-\nabla)}f[n+1] = ( 1 - \frac{1}{2}\nabla - \frac{1}{12}\nabla^2 - \frac{1}{24}\nabla^3 +\cdots)f[n+1].</p><pre><code class="language-none">
For the evaluation of the integration step we limit the summation to ``k+1`` terms (order ``k``),
</code></pre><p>math y[n+1]-y[n]= (\sum<em>{p=0}^{k}b</em>p\nabla^p)f[n+1]+\cdots.</p><pre><code class="language-none">
where ``b_0,\ldots,b_k`` are the *Adams-Moulton expansion coefficients*, rational numbers generated numerically by the function [`f_diff_expansion_coeffs_adams_moulton(k)`](@ref). Extracting the greatest common denominator, ``1/D``, the step becomes
</code></pre><p>math y[n+1]-y[n]= \frac{1}{D}(\sum<em>{p=0}^{k}b</em>p^{\prime}\nabla^p)f[n+1]+\cdots,</p><pre><code class="language-none">
where ``b_0^{\prime},\ldots,b_k^{\prime}`` are integers and ``b_p=b_p^{\prime}/D``. In practice the expansion is restricted to ``k&lt;18`` (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to ``k = 10``). Evaluating the finite-difference expansion up to order ``k`` we obtain (after changing dummy index bring the summation in forward order)
</code></pre><p>math \sum<em>{p=0}^{k}b</em>p\nabla^pf[n]=\sum<em>{p=0}^{k}b</em>p\sum<em>{j=0}^{p} c</em>j^if[n-j]= \sum<em>{j=0}^{k}a</em>j^k(x)f[n-j]= \sum<em>{j=0}^{k}a</em>{k-j}^k(x)f[n-k+j],</p><pre><code class="language-none">
where the ``a_j^k(x)= \sum_{p=j}^{k} b_pc_j^p`` are the ``(k+1)``-point *Adams-Moulton integration weights*. These are generated in *backward order* by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ = `[`f_diff_weights_array(k)`](@ref).

Functions:

`coeffs` = [`f_diff_expansion_coeffs_adams_moulton(k)`](@ref) ``\rightarrow [b_0,\ldots,b_k]``

`adams_moulton_weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref)``\rightarrow [a_k^k,\ ,\ldots,\ a_0^k]``

`adams_moulton_weights` = [`create_adams_moulton_weights(k)`](@ref)``\rightarrow [a_k^k,\ ,\ldots,\ a_0^k]``
</code></pre><p>@docs f<em>diff</em>expansion<em>coeffs</em>adams<em>moulton(k::Int) create</em>adams<em>moulton</em>weights(k::Int; rationalize=false, devisor=false, T=Int)</p><pre><code class="language-none">
## Strings
</code></pre><p>@docs sup(i::T) where T&lt;:Real sub(i::T) where T&lt;:Real frac(i::Rational{Int})</p><pre><code class="language-none">
## Index
</code></pre><p>@index ```</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 19 April 2022 09:52">Tuesday 19 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
