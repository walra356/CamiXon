<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CamiXon.jl</title><link rel="canonical" href="https://walra356.github.io/CamiXon.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CamiXon.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Table-of-contents"><span>Table of contents</span></a></li><li><a class="tocitem" href="#Strings"><span>Strings</span></a></li><li><a class="tocitem" href="#Codata"><span>Codata</span></a></li><li><a class="tocitem" href="#Atomic-properties"><span>Atomic properties</span></a></li><li><a class="tocitem" href="#Finite-difference-methods"><span>Finite-difference methods</span></a></li><li><a class="tocitem" href="#Grid"><span>Grid</span></a></li><li><a class="tocitem" href="#Def-settings-for-the-1D-Schrödinger-equation"><span>Def settings for the 1D Schrödinger equation</span></a></li><li><a class="tocitem" href="#FITS"><span>FITS</span></a></li><li><a class="tocitem" href="#FORTRAN"><span>FORTRAN</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Search-and-conversion-tools"><span>Search and conversion tools</span></a></li><li><a class="tocitem" href="#Math"><span>Math</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/walra356/CamiXon.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CamiXon.jl"><a class="docs-heading-anchor" href="#CamiXon.jl">CamiXon.jl</a><a id="CamiXon.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CamiXon.jl" title="Permalink"></a></h1><p>A package for image analysis of backscattered light</p><hr/><h2 id="Table-of-contents"><a class="docs-heading-anchor" href="#Table-of-contents">Table of contents</a><a id="Table-of-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-contents" title="Permalink"></a></h2><ul><li><a href="#CamiXon.jl">CamiXon.jl</a></li><ul><li><a href="#Table-of-contents">Table of contents</a></li><li><a href="#Strings">Strings</a></li><li><a href="#Codata">Codata</a></li><li><a href="#Atomic-properties">Atomic properties</a></li><li><a href="#Finite-difference-methods">Finite-difference methods</a></li><li><a href="#Grid">Grid</a></li><li><a href="#Def-settings-for-the-1D-Schrödinger-equation">Def settings for the 1D Schrödinger equation</a></li><li><a href="#FITS">FITS</a></li><li><a href="#FORTRAN">FORTRAN</a></li><li><a href="#Plotting">Plotting</a></li><li><a href="#Search-and-conversion-tools">Search and conversion tools</a></li><li><a href="#Math">Math</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Strings"><a class="docs-heading-anchor" href="#Strings">Strings</a><a id="Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Strings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.sup-Tuple{T} where T&lt;:Real" href="#CamiXon.sup-Tuple{T} where T&lt;:Real"><code>CamiXon.sup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sup(i::T) where T&lt;:Real</code></pre><p>Superscript notation for integers and rational numbers</p><p><strong>Examples:</strong></p><pre><code class="language-none">sup(3) * &#39;P&#39;
 &quot;³P&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/strings.jl#LL58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.sub-Tuple{T} where T&lt;:Real" href="#CamiXon.sub-Tuple{T} where T&lt;:Real"><code>CamiXon.sub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sub(i::T) where T&lt;:Real</code></pre><p>Subscript notation for integers, rational numbers and a <em>subset</em> of lowercase characters (&#39;a&#39;,&#39;e&#39;,&#39;h&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;x&#39;)</p><p><strong>Examples:</strong></p><pre><code class="language-none">&#39;D&#39; * sub(5//2)
 &quot;D₅⸝₂&quot;

&quot;m&quot; * sub(&quot;e&quot;)
 &quot;mₑ&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/strings.jl#LL81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.frac-Tuple{Rational{Int64}}" href="#CamiXon.frac-Tuple{Rational{Int64}}"><code>CamiXon.frac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">frac(i)</code></pre><p>Fraction notation for rational numbers</p><p><strong>Examples:</strong></p><pre><code class="language-none">frac(-5//2)
 &quot;-⁵/₂&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/strings.jl#LL118-L127">source</a></section></article><h2 id="Codata"><a class="docs-heading-anchor" href="#Codata">Codata</a><a id="Codata-1"></a><a class="docs-heading-anchor-permalink" href="#Codata" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Codata" href="#CamiXon.Codata"><code>CamiXon.Codata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Codata</code></pre><p>Object to hold the natural constants from CODATA. It is best created with the function <a href="#CamiXon.castCodata-Tuple{Int64}"><code>castCodata</code></a></p><p>The fields are:</p><ul><li><code>.∆νCs</code>: Cs hyperfine transition frequency (<code>::Value</code>)</li><li><code>.c</code>: speed of light in vacuum (<code>::Value</code>)</li><li><code>.h</code>: Planck constant (<code>::Value</code>)</li><li><code>.ħ</code>: Planck constant - reduced (<code>::Value</code>)</li><li><code>.e</code>: elementary charge (<code>::Value</code>)</li><li><code>.kB</code>: Boltzmann constant (<code>::Value</code>)</li><li><code>.NA</code>: Avogadro constant (<code>::Value</code>)</li><li><code>.Kcd</code>: Luminous efficacy (<code>::Value</code>)</li><li><code>.me</code>: electron rest mass (<code>::Value</code>)</li><li><code>.R∞</code>: Rydberg constant (<code>::Value</code>)</li><li><code>.Ry</code>: Rydberg frequency (<code>::Value</code>)</li><li><code>.Eh</code>: Hartree a.u. (<code>::Value</code>)</li><li><code>.α</code>: fine-structure constant (<code>::Value</code>)</li><li><code>.μ0</code>: magnetic permitivity of vacuum (<code>::Value</code>)</li><li><code>.ε0</code>: electric permitivity of vacuum (<code>::Value</code>)</li><li><code>.KJ</code>: Josephson constant (<code>::Value</code>)</li><li><code>.RK</code>: Von Klitzing constant (<code>::Value</code>)</li><li><code>.R</code>: Molar gas constant (<code>::Value</code>)</li><li><code>.matE</code>: unit conversion matrix (Matrix{Float64})</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
codata.μ0
  Value(1.2566370621250601e-6, &quot;N A⁻²&quot;)

codata.μ0.val
  1.2566370621250601e-6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL107-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Value" href="#CamiXon.Value"><code>CamiXon.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Value(val::Real, unit::String)</code></pre><p>Object to hold a real numerical value together with a unit specifier.</p><p>The fields are:</p><ul><li><code>.val</code>: numerical value (<code>::Real</code>)</li><li><code>.unit</code>: unit specifier (<code>::String</code>)</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">f = Value(1,&quot;Hz&quot;)
  Value(1, &quot;Hz&quot;)

f.val
  1

f.unit
  &quot;Hz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.strValue-Tuple{Value}" href="#CamiXon.strValue-Tuple{Value}"><code>CamiXon.strValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">strValue(f::Value)</code></pre><p>String expression for a <a href="#CamiXon.Value"><code>Value</code></a> object in <code>:compact =&gt; true</code> representation</p><p><strong>Example:</strong></p><pre><code class="language-none">f = Value(1,&quot;Hz&quot;)
strValue(f)
  &quot;1 Hz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.NamedValue" href="#CamiXon.NamedValue"><code>CamiXon.NamedValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NamedValue(val::Value, name::String, comment::String)</code></pre><p>Object to hold a <a href="#CamiXon.Value"><code>Value</code></a> together with its <code>symbolic name</code> and a <code>short</code> description</p><p>The fields are:</p><ul><li><code>.val</code>: Value  (<code>::Value</code>)</li><li><code>.name</code>: symbolic name (<code>::String</code>)</li><li><code>.comment</code>: description (<code>::String</code>)</li></ul><p>Named Value object The object <code>NamedValue</code> is best created using <a href="#CamiXon.castNamedValue-Tuple{Value}"><code>castNamedValue</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = Value(1,&quot;Hz&quot;)
  Value(1, &quot;Hz&quot;, &quot;frequency&quot;)

f.name
  &quot;frequency&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL55-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castNamedValue-Tuple{Value}" href="#CamiXon.castNamedValue-Tuple{Value}"><code>CamiXon.castNamedValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castNamedValue(val::Value; name=&quot; &quot;, comment=&quot; &quot;)</code></pre><p>Method to create a <a href="#CamiXon.NamedValue"><code>NamedValue</code></a> object</p><p><strong>Example</strong></p><pre><code class="language-none">v = Value(1.602176634e-19, &quot;C&quot;)
nv = castNamedValue(v; name=&quot;e&quot;)
nv.name * &quot; = &quot; * strValue2(nv.val)
  &quot;e = 1.60218e-19 C&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL87-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castCodata-Tuple{Int64}" href="#CamiXon.castCodata-Tuple{Int64}"><code>CamiXon.castCodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castCodata(year::Int)</code></pre><p>Method to create the <a href="#CamiXon.Codata"><code>Codata</code></a> object</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
strValue.([codata.∆νCs,codata.c,codata.h])
 3-element Vector{String}:
  &quot;9192631770 Hz&quot;
  &quot;299792458 m s⁻¹&quot;
  &quot;6.62607e-34 J Hz⁻¹&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL170-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.listCodata-Tuple{Codata}" href="#CamiXon.listCodata-Tuple{Codata}"><code>CamiXon.listCodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">listCodata(codata::Codata)</code></pre><p>Method to list the fields of <a href="#CamiXon.Codata"><code>Codata</code></a> by their symbolic name</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
listCodata(codata::Codata)
  ∆νCs = 9192631770 Hz
  c = 299792458 m s⁻¹
  h = 6.62607e-34 J Hz⁻¹
  ħ = 1.05457e-34 J s
  e = 1.60218e-19 C
  kB = 1.38065e-23 J K⁻¹
  NA = 6.02214e23 mol⁻¹
  Kcd = 683 lm W⁻¹
  mₑ = 9.10938e-31 Kg
  R∞ = 1.09737e7 m⁻¹
  Ry = 3.28984e15 Hz
  Eₕ = 4.35974e-18 Hartree a.u.
  α = 0.00729735
  μ₀ = 1.25664e-6 N A⁻²
  ε₀ = 8.85419e-12 F m⁻¹
  KJ = 4.83598e14 Hz V⁻¹
  RK = 25812.8 Ω
  R = 8.31446 J mol⁻¹K⁻¹</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL241-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.convertUnit-Tuple{Any, Codata}" href="#CamiXon.convertUnit-Tuple{Any, Codata}"><code>CamiXon.convertUnit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convertUnit(val, codata::Codata; unitIn=&quot;Hartree&quot;, unitOut=&quot;xHz&quot;)</code></pre><p>Unit conversion between μHz, ..., EHz, Hartree, Rydberg, Joule, and eV</p><p>default input: Hartree</p><p>default output: xHz ∈ {μHz, mHz, Hz, kHz, MHz, GHz, THz, PHz, EHz}</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = createCodata(2018)
convertUnit(1, codata; unitIn=&quot;Hz&quot;, unitOut=&quot;Joule&quot;)
  6.62607015e-34

convertUnit(1, codata; unitIn=&quot;Hartree&quot;, unitOut=&quot;Hz&quot;)
  Value(6.57968392050182e15, &quot;Hz&quot;)

f = convertUnit(1, codata) # default input (Hartree) and output (xHz)
strf = strValue(f)
  &quot;6.57968 PHz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL303-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.myconvert-Union{Tuple{V}, Tuple{Type, V}} where V&lt;:Number" href="#CamiXon.myconvert-Union{Tuple{V}, Tuple{Type, V}} where V&lt;:Number"><code>CamiXon.myconvert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">myconvert(T::Type, val::V) where V &lt;: Number</code></pre><p>Conversion including <code>BigFloat</code>, <code>Rational{BigFloat}</code>, BigInt, and <code>Rational{BigInt}</code></p><p><strong>Examples:</strong></p><pre><code class="language-none">convert(BigInt,1//3)
  InexactError: BigInt(1//3)

myconvert(BigInt, 1//3)
  0.3333333333333333333333333333333333333333333333333333333333333333333333333348</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL414-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.calibrationReport-Tuple{Any, Any, Codata}" href="#CamiXon.calibrationReport-Tuple{Any, Any, Codata}"><code>CamiXon.calibrationReport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calibrationReport(E, Ecal, codata::Codata; unitIn=&quot;Hartree&quot;)</code></pre><p>Comparison of energy E with calibration value Ecal</p><p>default input: Hartree</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
calibrationReport1(1.1, 1.0, codata; unitIn=&quot;Hartree&quot;)
  calibration report (Float64):
  Ecal = 1.0 Hartree
  E = 1.1 Hartree
  absolute accuracy: ΔE = 0.1 Hartree (657.968 THz)
  relative accuracy: ΔE/E = 0.0909091</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/codata.jl#LL366-L382">source</a></section></article><h2 id="Atomic-properties"><a class="docs-heading-anchor" href="#Atomic-properties">Atomic properties</a><a id="Atomic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Atom" href="#CamiXon.Atom"><code>CamiXon.Atom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Atom(name::String, symbol::String, Z::Int,Zc::Int,Q::Int,M::Float64,I::Real,gI::Float64)</code></pre><p>Type with fields:</p><ul><li><code>.name</code>:  name of element</li><li><code>.symbol</code>:  symbol of element</li><li><code>.Z</code>:  atomic number</li><li><code>.Zc</code>:  Rydberg charge in a.u.</li><li><code>.Q</code>:  ionic charge in a.u.</li><li><code>.M</code>:  nuclear mass in amu</li><li><code>.I</code>:  nuclear spin in units of ħ</li><li><code>.gI</code>:  nuclear g-factor</li></ul><p>The type <code>Atom</code> is best created by the function <code>castAtom</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castAtom-Tuple{}" href="#CamiXon.castAtom-Tuple{}"><code>CamiXon.castAtom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castAtom(;Z=1, Q=0, M=1.0, I=1//2, gI=5.5, msg=true)</code></pre><p>Create Atom with fields</p><ul><li><code>.name</code>:  name of element</li><li><code>.symbol</code>:  symbol of element</li><li><code>.Z</code>:  atomic number</li><li><code>.Zc</code>:  Rydberg charge in a.u. (autogenerated)</li><li><code>.Q</code>:  ionic charge in a.u.</li><li><code>.M</code>:  nuclear mass in amu</li><li><code>.I</code>:  nuclear spin in units of ħ</li><li><code>.gI</code>:  nuclear g-factor</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">castAtom(Z=1, Q=0, M=1.00782503223, I=1//2, gI=5.585694713)
 Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.00782503223, I = 1//2, gI = 5.585694713)
 Atom(&quot;Hydrogen&quot;, &quot;¹H&quot;, 1, 1, 0, 1.00782503223, 1//2, 5.585694713)

castAtom(Z=2, Q=1, M=4.00260325413, I=1//2, gI=0.0)
 Atom created: Helium ion - ⁴Heᐩ (Z = 2, Zc = 2, Q = 1, M = 4.00260325413, I = 1//2, gI = 0.0)
 Atom(&quot;Helium ion&quot;, &quot;⁴Heᐩ&quot;, 2, 2, 1, 4.00260325413, 1//2, 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL32-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Orbit" href="#CamiXon.Orbit"><code>CamiXon.Orbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Orbit(name, n, n′, ℓ)</code></pre><p>Type for specification of <em>atomic orbitals</em> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li></ul><p>The type <code>Orbit</code> is best created by the function <code>castOrbit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castOrbit-Tuple{}" href="#CamiXon.castOrbit-Tuple{}"><code>CamiXon.castOrbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castOrbit(;n=1, ℓ=0, msg=true)</code></pre><p>Specify <code>Orbit</code> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.ms</code>:  spin magnetic quantum number</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">castOrbit(n=1, ℓ=0)
 Orbit created: 1s (n = 1, n′ = 0, ℓ = 0)
 Orbit(&quot;1s&quot;, 1, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL99-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.SpinOrbit" href="#CamiXon.SpinOrbit"><code>CamiXon.SpinOrbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpinOrbit</code></pre><p>Type for specification of <em>atomic spinorbitals</em> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.ms</code>:  spin magnetic quantum number</li></ul><p>The type <code>SpinOrbit</code> is best created by the function <code>createSpinOrbit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL133-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.createSpinOrbit-Tuple{Orbit}" href="#CamiXon.createSpinOrbit-Tuple{Orbit}"><code>CamiXon.createSpinOrbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">createSpinOrbital(o::Orbit; up=true, msg=true)</code></pre><p>Specify <code>SpinOrbit</code> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>: principal quantum number</li><li><code>.n′</code>: radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>: orbital angular momentum valence electron</li><li><code>.ms</code>: spin magnetic quantum number</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">s1s = castOrbit(1,0)
createSpinOrbit(s1s; up=true)
  SpinOrbit created: 1s↑ (n = 1, n′ = 0, ℓ = 0, ms = 1//2)
  SpinOrbit(&quot;1s↑&quot;, 1, 0, 0, 1//2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL156-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Term" href="#CamiXon.Term"><code>CamiXon.Term</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Term(name::String, n::Int, ℓ::Int, S::Real, L::Int, J::Real)</code></pre><p>Type for specification of atomic <em>fine-structure Terms</em> with fields:</p><ul><li><code>name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.S</code>:  total electron spin in units of ħ</li><li><code>.L</code>:  total orbital angular momentum in units of ħ</li><li><code>.J</code>:  total electronic angular momentum in units of ħ</li></ul><p>The type <code>Term</code> is best created by the function <code>createTerm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL186-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.createTerm-Tuple{Int64}" href="#CamiXon.createTerm-Tuple{Int64}"><code>CamiXon.createTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)</code></pre><p>Specify Term in the <em>Term notatation</em> with fields:</p><ul><li><code>.n</code>: principal quantum number</li><li><code>.n′</code>: radial quantum number (number of nodes - autogenerated)</li><li><code>.ℓ</code>: orbital angular momentum valence electron</li><li><code>.S</code>: total electron spin</li><li><code>.L</code>: total orbital angular momentum</li><li><code>.J</code>: total electronic angular momentum</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">term_H1I = createTerm(1; ℓ=0, S=1//2, L=0, J=1//2)
 Term created: 1s ²S₁⸝₂, n = 1, n′ = 0, ℓ = 0, S = 1//2, L = 0, J = 1//2
 Term(&quot;1s ²S₁⸝₂&quot;, 1, 0, 0, 1//2, 0, 1//2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL212-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.bohrformula-Tuple{Int64, Int64}" href="#CamiXon.bohrformula-Tuple{Int64, Int64}"><code>CamiXon.bohrformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bohrformula(Z::Int, n::Int)</code></pre><p>Hydrogenic energy (in Hartree a.u.) for <em>atom</em> with <em>atomic number</em> <code>Z</code> and <em>principal quantum number</em> <code>n</code>.</p><p class="math-container">\[    E_n = - \frac{Z^2}{2n^2}\]</p><p><strong>Example:</strong></p><pre><code class="language-none">Z = 2
n = 4
bohrformula(Z,n)
 -0.125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL251-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.mendeleev-Tuple{Int64}" href="#CamiXon.mendeleev-Tuple{Int64}"><code>CamiXon.mendeleev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mendeleev(Z::Int)</code></pre><p>The properties <code>name</code> and <code>symbol</code> of the <em>element</em> with <em>atomic number</em> <code>Z</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">mendeleev(11)
 (&quot;Sodium&quot;, &quot;Na&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/atom.jl#LL270-L279">source</a></section></article><h2 id="Finite-difference-methods"><a class="docs-heading-anchor" href="#Finite-difference-methods">Finite-difference methods</a><a id="Finite-difference-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-methods" title="Permalink"></a></h2><h3 id="Finite-differences"><a class="docs-heading-anchor" href="#Finite-differences">Finite differences</a><a id="Finite-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-differences" title="Permalink"></a></h3><p>Consider the analytic function <span>$f$</span> tabulated in <em>forward order</em>  (growing index) at <span>$n$</span> positions on a <em>grid</em>. The <em>finite difference</em> of two adjacent values on a <em>uniform grid</em> is defined by the relation</p><p class="math-container">\[\nabla f[n] = f[n]-f[n-1].\]</p><p>This is called the finite difference in <em>backward difference</em> notation. In this notation the  <span>$k^{th}$</span>-<em>order backward difference</em> (which involves <span>$k+1$</span> points) is defined by a <em>weighted sum</em> over the function values in backward order, <span>$f[n],\ \ldots,\ f[n-k]$</span>,</p><p class="math-container">\[\nabla^k f[n] = f[n] + c_1^kf[n-1] + \cdots + c_k^kf[n-k] = \sum_{j=0}^{k} c_j^kf[n-j].\]</p><p>The <span>$k+1$</span> coefficients <span>$c_{j}^{k}=(-1)^{j}\binom{k}{j}$</span> are <em>weight factors</em> (short: <em>weights</em>) defining the summation. Note that <span>$c_{0}^{k}\equiv1$</span> and <span>$c_{k}^{k}=(-1)^{k}$</span>. As the function <span>$f$</span> is tabulated in forward order it is good practice to change dummy index to also write the summation in forward order (coefficients in backward order),</p><p class="math-container">\[\nabla^k f[n] = \sum_{j=0}^{k} c^k[j]f[n-k+j],\]</p><p>where <span>$c^k[j] \equiv c_{k-j}^k$</span>.    </p><p>Functions:  </p><p><a href="#CamiXon.f_diff_weight-Tuple{Int64, Int64}"><code>f_diff_weight(k,j)</code></a> <span>$\rightarrow c_j^k$</span></p><p><a href="#CamiXon.f_diff_weights-Tuple{Int64}"><code>f_diff_weights(k)</code></a> <span>$\rightarrow \ c^k ≡ [c_k^k,\ c_1^k,\ldots,\ c_0^k]$</span></p><p><a href="#CamiXon.f_diff_weights_array-Tuple{Int64}"><code>f_diff_weights_array(kmax)</code></a> <span>$\rightarrow \ [\ c^0,\ c^1,\ \ldots,\ c^{kmax} ]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.f_diff_weight-Tuple{Int64, Int64}" href="#CamiXon.f_diff_weight-Tuple{Int64, Int64}"><code>CamiXon.f_diff_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_diff_weight(k, j)</code></pre><p>Weight coefficient</p><p class="math-container">\[c_{j}^{k}=(-1)^{j}\binom{k}{j},\]</p><p>of the <span>$k^{th}$</span>-order finite difference operator <span>$\nabla^k$</span> and corresponding to the function value <span>$f[n-j]$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">k = 5; j = 3
f_diff_weight(k, j)
 -10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.f_diff_weights-Tuple{Int64}" href="#CamiXon.f_diff_weights-Tuple{Int64}"><code>CamiXon.f_diff_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_diff_weights(k)</code></pre><p>Weight vector <span>$[c_k^k,\ \ldots,\ c_0^k]$</span> defining the <span>$k^{th}$</span>-order finite difference operator,</p><p class="math-container">\[\nabla^{k}f[n]	=[c_{k}^{k},\thinspace c_{k-1}^{k},\thinspace\ldots,c_{0}^{k}]\left[\begin{array}{c}
f[n-k]\\
\vdots\\
f[n]
\end{array}\right]=\sum_{j=0}^{k}c^k[j]f[n-k+j],\]</p><p>where <span>$c^k[j] ≡ c_{k-j}^{k}$</span>. This form is designed for use with <em>analytic</em> functions, <span>$f$</span>, tabulated in <em>forward</em> order, <span>$f[n-k], ...,f[n]$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">k = 3
f_diff_weights(k)
4-element Vector{Int64}:
  1
 -3
  3
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL20-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.f_diff_weights_array-Tuple{Int64}" href="#CamiXon.f_diff_weights_array-Tuple{Int64}"><code>CamiXon.f_diff_weights_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_diff_weights_array(kmax)</code></pre><p>Collection of weight vectors, <span>$c^0,\ \ldots,\ c^k$</span>, defining the finite difference operators <span>$\nabla^0,\ \ldots,\ \nabla^k$</span> under the convention <span>$c^k ≡ [c_k^k,\ c_1^k,\ldots,\ c_0^k])$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">kmax = 3
∇ = f_diff_weights_array(kmax)
4-element Vector{Vector{Int64}}:
 [1]
 [-1, 1]
 [1, -2, 1]
 [-1, 3, -3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL48-L64">source</a></section></article><h3 id="Finite-difference-expansion"><a class="docs-heading-anchor" href="#Finite-difference-expansion">Finite difference expansion</a><a id="Finite-difference-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-expansion" title="Permalink"></a></h3><p>Finite-difference calculus builds on the <em>finite-difference expansion</em>, in practice truncated at <em>order</em> <span>$k$</span>,</p><p class="math-container">\[\sum_{p=0}^{\infty}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]+\cdots.\]</p><p>By choosing the order sufficiently high the expansion can be approximated to any desired level of accuracy. A finite-difference expansion of order <span>$k$</span> is defined by <span>$k+1$</span> <em>finite-difference expansion coefficients</em>, above denoted by <span>$a_{0},\ \ldots,\ a_{k}$</span>. Note that both the coefficients and the operators appear in forward order. It takes some bookkeeping to rewrite the expansion in the form of a <em>weighted sum</em> over the <span>$k+1$</span> <em>function values</em> <span>$f[n],\ldots,f[n-k]$</span> (note the <em>backward order</em>). Substituting the finite-difference expression for <span>$\nabla^k$</span>, we obtain</p><p class="math-container">\[\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\sum_{j=0}^{p}c_{j}^{i}f[n-j]=\sum_{j=0}^{k}\sum_{p=j}^{k}a_{p}c_{j}^{p}f[n-j]=\sum_{j=0}^{k}b_{j}^{k}f[n-j],\]</p><p>where the weighted summation is defined by the <em>weights</em> <span>$b_{j}^{k}=\sum_{p=j}^{k}a_{p}c_{j}^{p}$</span>, with <span>$j=0,\ \ldots,\ k$</span>. By a change of dummy index we write the summation in <em>forward order</em></p><p class="math-container">\[\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]=\sum_{j=0}^{k}b^k[j]f[n-k+j],\]</p><p>where <span>$b^k[j] \equiv b_{k-j}^k$</span>.   Note that the <em>weights vector</em> <span>$b^k$</span> contains the weights in backward order. It is generated by the function <a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>f_diff_expansion_weights(coeffs,∇)</code></a>, where <code>∇ =</code><a href="#CamiXon.f_diff_weights_array-Tuple{Int64}"><code>f_diff_weights_array(kmax)</code></a>.</p><p>Functions:</p><p><code>coeffs</code> = <span>$[a_0,\ \ldots,\ a_k]$</span></p><p><a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>f_diff_expansion_weights(coeffs,∇)</code></a> <span>$\rightarrow b^k \equiv [b_k^k,\ ,\ldots,\ b_0^k]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.f_diff_expansion_weights-Tuple{Any, Any}" href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>CamiXon.f_diff_expansion_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_diff_expansion_weights(a, ∇)</code></pre><p>Weight vector <span>$b^k ≡ [b_k^k,\ ,\ldots,\ b_0^k]$</span> corresponding to the expansion coefficients <span>$[a_0^k,\ ,\ldots,\ a_k^k]$</span> of the <span>$k^{th}$</span>-order finite-difference expansion,</p><p class="math-container">\[\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]=\sum_{j=0}^{k}b^k[j]f[n-k+j],\]</p><p>where <span>$b^k[j] \equiv b_{k-j}^k$</span> and <span>$f[n-k], ...,f[n]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order. Note the difference in ordering between the finite-difference expansion <em>coefficients</em>, <span>$a_{0},\ \ldots,\ a_{k}$</span>, and the finite-difference expansion <em>weights</em>, <span>$b_k^{k},\ \ldots,\ b_0^{k}$</span>. Note further the difference in <span>$k$</span> dependence: the <em>weights</em>, <span>$b_j^k$</span>, are <span>$k$</span><em>-dependent</em>, whereas the <em>coefficients</em>, <span>$a_j$</span>, are not.</p><p><strong>Example:</strong></p><pre><code class="language-none">k=5
∇ = f_diff_weights_array(k)
a = UnitRange(0,k)
b = f_diff_expansion_weights(a, ∇)
6-element Vector{Int64}:
  -5
  29
 -69
  85
 -55
  15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL69-L101">source</a></section></article><h3 id="Lagrangian-interpolation"><a class="docs-heading-anchor" href="#Lagrangian-interpolation">Lagrangian interpolation</a><a id="Lagrangian-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-interpolation" title="Permalink"></a></h3><p>Using the definition of the finite difference we can express the relation between <span>$f[n]$</span> and <span>$f[n+1]$</span> in operator form,</p><p class="math-container">\[f[n]=(1-\nabla)f[n+1].\]</p><p>By formal inversion of the operator we have</p><p class="math-container">\[f[n+1] = (1 - \nabla)^{-1} f[n] \equiv \sum_{p=0}^{\infty}∇^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 - \nabla)^{-2} f[n] \equiv \sum_{p=0}^{\infty}p∇^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>which can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n+x] = (1 - \nabla)^{-x} f[n] \equiv \sum_{p=0}^{\infty}l_p(x)∇^p f[n],\]</p><p>where <span>$l_0\equiv 1$</span> and <span>$l_p(x) = x(x+1)(x+2)\cdots(x+p-1)/p!$</span> for <span>$p&gt;0$</span> are the <em>finite-difference expansion coefficients</em> for <em>lagrangian interpolation</em>. These are generated by the function <a href="#CamiXon.f_diff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>f_diff_expansion_coeffs_lagrange(k,x)</code></a>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[f[n+x] =\sum_{p=0}^{k}l_p(x)\nabla^pf[n]= \sum_{j=0}^{k}r_j^k(x)f[n-j],\]</p><p>where the <span>$k+1$</span> <em>weights</em> <span>$r_j^k(x)= \sum_{p=j}^{k} l_p(x) c_j^p$</span> are the  <em>lagrangian interpolation weights</em>.  After changing dummy index to bring the summation in forward order the expansion becomes</p><p class="math-container">\[f[n+x] =\sum_{p=0}^{k}l_p(x)\nabla^pf[n]= \sum_{j=0}^{k}r_x^k[j]f[n-k+j],\]</p><p>where <span>$r^k_x[j] ≡ r_{k-j}^k(x)$</span>. The weights vector <span>$r^k_x$</span> is generated by the function <a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>f_diff_expansion_weights(coeffs,∇)</code></a>, with <code>∇ =</code> <a href="#CamiXon.f_diff_weights_array-Tuple{Int64}"><code>f_diff_weights_array(k)</code></a>.</p><p>Functions:</p><p><code>coeffs</code> = <a href="#CamiXon.f_diff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>f_diff_expansion_coeffs_lagrange(k,x)</code></a> <span>$\rightarrow [l_0(x),\ \ldots,\ l_k(x)]$</span></p><p><code>lagrangian interpolation weights</code> = <a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>f_diff_expansion_weights(coeffs,∇)</code></a> <span>$\rightarrow r^k_x ≡ [r_k^k(x),\ ,\ldots,\ r_0^k(x)]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.f_diff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real" href="#CamiXon.f_diff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.f_diff_expansion_coeffs_lagrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_diff_expansion_coeffs_lagrange(k::Int, x::T) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector <span>$[l_0(x),\ \ldots,\ l_p(x)]$</span> defining <span>$k^{th}$</span>-order lagrangian interpolation of the tabulated analytic function <span>$f(n+x)$</span> at offset position <span>$x$</span> with respect to position <span>$n$</span>,</p><p class="math-container">\[f[n+x] = (1 - \nabla)^{-x} f[n] \equiv \sum_{p=0}^{\infty}l_p(x)∇^p f[n],\]</p><p>where <span>$l_0\equiv 1$</span> and <span>$l_p(x) = x(x+1)(x+2)\cdots(x+p-1)/p!$</span>. Interpolation corresponds to the interval <span>$-k\le\ x\le 0$</span>; extrapolation to <span>$x\ge 0$</span>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">k = 5; x = 1
l = f_diff_expansion_coeffs_lagrange(k,x); println(l)
 [1, 1, 1, 1, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL113-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.summation_range-NTuple{4, Int64}" href="#CamiXon.summation_range-NTuple{4, Int64}"><code>CamiXon.summation_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">summation_range(n, i, k, m)</code></pre><p>Summation range for interpolation position <span>$0\le i/m \le 1$</span> used in <span>$k^{th}$</span>-order lagrangian interpolation of the anaytic function <span>$f$</span> tabulated in forward order on a uniform grid of <span>$n$</span> points, <span>$f[1],\ \ldots,\ f[n]$</span>; <span>$m$</span> is the multiplier defining the interpolation grid size.</p><p><strong>Examples:</strong></p><pre><code class="language-none">n = 7; k = 2; m = 1
o = [summation_range(n,i,k,m) for i=0:(n-1)*m]; println(o)
 UnitRange{Int64}[1:3, 2:4, 3:5, 4:6, 5:7, 5:7, 5:7]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL142-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.f_diff_function_sequences" href="#CamiXon.f_diff_function_sequences"><code>CamiXon.f_diff_function_sequences</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">f_diff_function_sequences(f, k::Int, m=1)</code></pre><p>Finite-difference summation sequences of function values given in forward order for use in <span>$k^{th}$</span>-order lagrangian interpolation of the anaytic function <span>$f$</span> tabulated in forward order on a regular grid of <span>$n$</span> points, <span>$f[1], ...,f[n]$</span>; <span>$m$</span> is the multiplier defining the interpolation grid size. Each sequence consists of <span>$k⋅m+1$</span> function values.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = [0,1,2,3,4,5,6]
k = 2
o = f_diff_function_sequences(f, k); println(o)
 [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL167-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.lagrange_interpolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}" href="#CamiXon.lagrange_interpolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_interpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lagrangian_interpolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, m=1)</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>interpolation</em> of the analytic function <span>$f$</span> tabulated in forward order on a regular grid of <span>$n$</span> points, <span>$f[1],\ \ldots,\ f[n]$</span>; <span>$m$</span> is the multiplier defining the interpolation grid size.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = [0.0,1,2,3,4,5,6,7]
domain = 0.0..1.0
(X,Y) = lagrangian_interpolation(f, domain; k=2, m=2); println((X,Y))
 (0.0:0.07142857142857142:1.0, [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL192-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.lagrange_extrapolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}" href="#CamiXon.lagrange_extrapolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_extrapolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lagrangian_extrapolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, e=1, m=1)</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>extrapolation</em> up to position <span>$n+e$</span> of the analytic function <span>$f$</span> tabulated in forward order at <span>$n$</span> points, <span>$f[1],\ \ldots,\ f[n]$</span>; <span>$m$</span> is the multiplier defining the interpolation grid size.</p><p><strong>Example:</strong></p><pre><code class="language-none">f = [0.0,1,2,3,4,5,6,7]
domain = 0.0..1.0
(X,Y) = lagrangian_extrapolation(f, domain; k=2, e=1, m=2); println((X,Y))
 (0.0:0.07142857142857142:1.0, [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL225-L238">source</a></section></article><h3 id="Lagrangian-differentiation"><a class="docs-heading-anchor" href="#Lagrangian-differentiation">Lagrangian differentiation</a><a id="Lagrangian-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-differentiation" title="Permalink"></a></h3><p>To derive the <em>lagrangian differentiation</em> formulas we formally differentiate</p><p class="math-container">\[f[n+x] = (1 - \nabla)^{-x} f[n]\]</p><p>with respect to <span>$x$</span>.</p><p class="math-container">\[\frac{df}{dx}[n+x]=-ln(1-\nabla)\ (1-\nabla)^{-x}f[n]=\sum_{q=1}^{k}\tfrac{1}{q}∇^{q}\sum_{p=0}^{k}l_{p}(x)∇^{p}f[n]+\cdots.\]</p><p>Rewriting the r.h.s. as a single summation in powers of <span>$\nabla$</span> for given values of <span>$n$</span> and <span>$x$</span> we obtain an expression of the form</p><p class="math-container">\[\frac{df}{dx}[n+x]=\sum_{p=1}^{k}l_{p}^{\prime}(x)\nabla^{p}f[n]+\cdots,\]</p><p>where <span>$l_{p}^{\prime}(x)$</span> represents the <em>finite-difference expansion coefficients</em> for <em>lagrangian differentiation</em> at position <span>$n+x$</span>. These coefficients are determined numerically by polynomial multiplication after adding the <span>$p=0$</span> term, <span>$l_{0}^{\prime}(x)\equiv 0$</span>, to the first sum. The corresponding coefficient vector is generated in <em>forward order</em> by the function <a href="#CamiXon.f_diff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>f_diff_expansion_coeffs_differentiation(k,x)</code></a>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[\frac{df}{dx}[n+x]=\sum_{p=0}^{k}l_{p}^{\prime}(x)\nabla^{p}f[n]=\sum_{j=0}^{k}s_{j}^{k}(x)f[n-j],\]</p><p>where the <span>$s_{j}^{k}(x)=\sum_{p=j}^{k}l_{p}^{\prime}(x)c_{j}^{p}$</span> are the <span>$k^{th}$</span>-order lagrangian differentiation weights.  After changing dummy index to reverse the summation from backward to forward order the expansion becomes</p><p class="math-container">\[\frac{df}{dx}[n+x]]= \sum_{j=0}^{k}s^k_x[j]f[n-k+j],\]</p><p>where <span>$s^k_x[j] ≡ s^k_{k-j}(x)$</span>. The weights vector <span>$s^k_x$</span> is generated by the function <a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>f_diff_expansion_weights(coeffs,∇)</code></a>, with <code>∇ =</code> <a href="#CamiXon.f_diff_weights_array-Tuple{Int64}"><code>f_diff_weights_array(k)</code></a>.</p><p>Functions:</p><p><code>coeffs</code> = <a href="#CamiXon.f_diff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>f_diff_expansion_coeffs_differentiation(k,x)</code></a> <span>$\rightarrow [l_0^{\prime}(x),\ \ldots,\ l_k^{\prime}(x)]$</span></p><p><code>Lagrange differentiation weights</code> = <a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>f_diff_expansion_weights(coeffs,∇)</code></a> <span>$s^k_x[j] ≡ \rightarrow [s_k^k(x),\ ,\ldots,\ s_0^k(x)]$</span></p><p><code>Lagrange differentiation weights</code> = <a href="#CamiXon.create_lagrange_differentiation_weights-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>create_lagrange_differentiation_weights(k,x)</code></a> <span>$s^k_x[j] ≡ \rightarrow [s_k^k(x),\ ,\ldots,\ s_0^k(x)]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.f_diff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real" href="#CamiXon.f_diff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.f_diff_expansion_coeffs_differentiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_diff_expansion_coeffs_differentiation(k::Int, x::T) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector <span>$[l_0^{\prime}(x),\ \ldots,\ l_p^{\prime}(x)]$</span> defining <span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the tabulated analytic function <span>$f(n+x)$</span> at position <span>$x$</span>,</p><p class="math-container">\[\frac{df}{dx}[n+x]=\sum_{p=0}^{k}l_{p}^{\prime}(x)\nabla^{p}f[n]\]</p><p><strong>Example:</strong></p><pre><code class="language-none">k = 2; x = 0
o = f_diff_expansion_coeffs_differentiation(k,x); println(o)
 [0.0, 1.0, -1.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL260-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.create_lagrange_differentiation_weights-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real" href="#CamiXon.create_lagrange_differentiation_weights-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.create_lagrange_differentiation_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_lagrange_differentiation_weights(k::Int, x::T) where T&lt;:Real</code></pre><p><span>$k^{th}$</span>-order Lagrange differentiation weights vector, <span>$s^k(x) ≡ [s_k^k(x),\ ,\ldots,\ s_0^k(x)]$</span>, where <span>$x$</span> is the position relative point <span>$n$</span>.</p><p class="math-container">\[\frac{df}{dx}[n+x]= \sum_{j=0}^{k}s_{k-j}^k(x)f[n-k+j],\]</p><p>where <span>$s^k_x[j] ≡ s_{k-j}(x)^k$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">k = 3
x = 0
ldw = create_lagrange_differentiation_weights(k,x); println(ldw)
  Rational{Int64}[-11//6, 3//1, -3//2, 1//3]

 sum(ldw)
   0//1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL291-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}" href="#CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiXon.create_lagrange_differentiation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_lagrange_differentiation_matrix(k::Int)</code></pre><p>Lagrange differentiation matrix, <span>$m[i,j]=s_{k-j}^k(i)$</span>, for <span>$k^{th}$</span>-order lagrangian differentiation,</p><p class="math-container">\[\frac{dy}{dx}[i]= \sum_{j=0}^{k}m[i,j]y[j],\]</p><p><strong>Example:</strong></p><pre><code class="language-none">k = 3
create_lagrange_differentiation_matrix(k)
 4×4 Matrix{Rational{Int64}}:
  -11//6   3//1  -3//2   1//3
   -1//3  -1//2   1//1  -1//6
    1//6  -1//1   1//2   1//3
   -1//3   3//2  -3//1  11//6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL322-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.lagrange_differentiation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}" href="#CamiXon.lagrange_differentiation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_differentiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lagrange_differentiation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, m=1)</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the analytic function <span>$f$</span>, tabulated in forward order on a regular grid of <span>$n$</span> points, <span>$f[1],\ \ldots,\ f[n]$</span>; <span>$m$</span> is the multiplier for intermediate positions</p><p><strong>Example:</strong></p><pre><code class="language-none">f = [0.0,1,2,3,4,5]
domain = 0.0..5.0
X,Y = lagrangian_differentiation(f, domain; k=2, i = 0); println(X,Y)
 (0.0:1.0:5.0, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL357-L370">source</a></section></article><h3 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.trapezoidal_weights-Tuple{Int64}" href="#CamiXon.trapezoidal_weights-Tuple{Int64}"><code>CamiXon.trapezoidal_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trapezoidal_weights(k::Int [; rationalize=false [, devisor=false]])</code></pre><p>Weight coefficient vector <span>$a=[a_1,\cdots,\ a_k]$</span> of trapeziodal rule optimized for functions of polynomial form,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n)+\cdots+a_k (f_{k-1}+f_{n-k+1}) + (f_k+\cdots+f_{n-k}),\]</p><p>where <span>$k$</span> is <em>odd</em>. The rule is exact for polynonials of degree <span>$d=0,\ 1,\cdots,\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.</p><p><strong>Example::</strong></p><pre><code class="language-none">[trapezoidal_weights(k; rationalize=true, devisor=true) for k=1:2:9]
5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
 (1, 2, [1])
 (3, 24, [9, 28, 23])
 (5, 1440, [475, 1902, 1104, 1586, 1413])
 (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])
 (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922, 5095890, 7783754, 7200319])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL392-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.trapezoidal_integration-Tuple{Any, Any, Any}" href="#CamiXon.trapezoidal_integration-Tuple{Any, Any, Any}"><code>CamiXon.trapezoidal_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trapezoidal_integration(f, domain, weights)</code></pre><p>Integral of the tabulated function <span>$f=[f_0,\cdots,\ f_n]$</span> over the <code>domain</code> <span>$a..b$</span> using the optimized trapezoidal rule with endpoint correction by the weightsvector <code>weights</code>,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n)+\cdots+a_k (f_{k-1}+f_{n-k+1}) + (f_k+\cdots+f_{n-k}).\]</p><p>The rule is exact for polynonials of degree <span>$d=0,\ 1,\cdots,\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Examples::</strong></p><pre><code class="language-none">p = 3
c = [1 for i=0:p]
pol = ImmutablePolynomial(c,:z)
Ipol = integrate(pol)
n = 10

domain = 0.0..5.0
x = collect(range(domain, n))
f = pol.(x .-2.5)

w3 = trapezoidal_weights(3)
trapezoidal_integration(f, domain, w3)
 15.416666666666673

Ipol(2.5)-Ipol(-2.5)
 15.41666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/finite_differences.jl#LL449-L478">source</a></section></article><h3 id="Adams-Method"><a class="docs-heading-anchor" href="#Adams-Method">Adams Method</a><a id="Adams-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Method" title="Permalink"></a></h3><h4 id="Adams-Bashford-expansion"><a class="docs-heading-anchor" href="#Adams-Bashford-expansion">Adams-Bashford expansion</a><a id="Adams-Bashford-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Bashford-expansion" title="Permalink"></a></h4><p>The <em>Adams-Bashford integration step</em> is given by the expansion</p><p class="math-container">\[y[n+1]-y[n] = -\frac{h \nabla}{(1-\nabla)ln(1-\nabla)}f[n+1]=h (\sum_{p=0}^{\infty}B_p\nabla^p)f[n+1].\]</p><p>A closed expression for the <em>Adams-Bashford expansion coefficients</em>, <span>$B_k$</span>, is not available. As we already have a finite-difference expansion for the operator <span>$(1-∇)^{-1}$</span>,</p><p class="math-container">\[\frac{1}{1-∇}\equiv\sum_{p=0}^{\infty}\nabla^p,\]</p><p>we ask for the expansion of</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}=(1-\frac{1}{2}∇-\frac{1}{24}∇^2-\frac{1}{12}∇^3+\cdots)f[n+1]= (\sum_{p=0}^{\infty}b_p\nabla^p)f[n+1].\]</p><p>This is known as the <em>Adams-Moulton expansion</em>. Its coefficients are calculated numerically by the function <code>f_diff_expansion_adams_moulton_coeffs(k)</code>. The <em>Adams-Bashford expansion</em> is obtained as the polynomial product of the two expansions,</p><p class="math-container">\[(\sum_{p=0}^{\infty}B_p∇^p)f[n+1]=(\sum_{p=0}^{\infty}∇^p)(\sum_{p=0}^{\infty}b_p∇^p)f[n+1]=\ ( 1 + \frac{1}{2}\nabla + \frac{5}{12}\nabla^2 + \cdots)f[n+1].\]</p><p>The coefficients <span>$B_p$</span> are calculated numerically with the function <code>f_diff_expansion_adams_bashford_coeffs(k)</code>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}B_p\nabla^pf[n]=\sum_{p=0}^{k}B_p\sum_{j=0}^{p} c_j^if[n-j]= \sum_{j=0}^{k}A_j^k(x)f[n-j]= \sum_{j=0}^{k}A_{k-j}^k(x)f[n-k+j],\]</p><p>where the <span>$A_j^k(x)= \sum_{p=j}^{k} B_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Bashford integration weights</em>.</p><p>Function:</p><p><code>coeffs</code> = <a href="#CamiXon.f_diff_expansion_coeffs_adams_bashford-Tuple{Int64}"><code>f_diff_expansion_coeffs_adams_bashford(k)</code></a> <span>$\rightarrow [B_k^k(x),\ ,\ldots,\ B_0^k(x)]$</span></p><p><code>adams_bashford_integration_weights</code> = <a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>f_diff_expansion_weights(coeffs,∇)</code></a> <span>$\rightarrow [A_k^k(x),\ ,\ldots,\ A_0^k(x)]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.f_diff_expansion_coeffs_adams_bashford-Tuple{Int64}" href="#CamiXon.f_diff_expansion_coeffs_adams_bashford-Tuple{Int64}"><code>CamiXon.f_diff_expansion_coeffs_adams_bashford</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_diff_expansion_coeffs_adams_bashford(k [; T=Int])</code></pre><p><span>$(k+1)$</span>-point Adams-Bashford expansion coefficients <span>$B_p$</span>.</p><p class="math-container">\[-\frac{\nabla}{(1-\nabla)ln(1-\nabla)}=\sum_{p=0}^{\infty}B_p\nabla^p=1+\ \frac{1}{2}∇+\ \frac{5}{12}∇^2+\ \cdots.\]</p><p>The weights are stored in <em>forward</em> order: <span>$[B_0^k,\ \cdots,\ B_k^k]$</span> - order of use in summation.</p><p><strong>Examples:</strong></p><pre><code class="language-none">k = 5
o = f_diff_expansion_coeffs_adams_bashford(k); println(o)
 Rational{Int64}[1//1, 1//2, 5//12, 3//8, 251//720, 95//288]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/adams.jl#LL94-L110">source</a></section></article><h3 id="Adams-Moulton-expansion"><a class="docs-heading-anchor" href="#Adams-Moulton-expansion">Adams-Moulton expansion</a><a id="Adams-Moulton-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-expansion" title="Permalink"></a></h3><p>The <em>Adams-Moulton integration</em> step is given by the expansion</p><p class="math-container">\[y[n+1]-y[n] = -\frac{\nabla}{ln(1-\nabla)}f[n+1] = ( 1 - \frac{1}{2}\nabla - \frac{1}{12}\nabla^2 - \frac{1}{24}\nabla^3 +\cdots)f[n+1].\]</p><p>For the evaluation of the integration step we limit the summation to <span>$k+1$</span> terms (order <span>$k$</span>),</p><p class="math-container">\[y[n+1]-y[n]= (\sum_{p=0}^{k}b_p\nabla^p)f[n+1]+\cdots.\]</p><p>where <span>$b_0,\ldots,b_k$</span> are the <em>Adams-Moulton expansion coefficients</em>, rational numbers generated numerically by the function <a href="#CamiXon.f_diff_expansion_coeffs_adams_moulton-Tuple{Int64}"><code>f_diff_expansion_coeffs_adams_moulton(k)</code></a>. Extracting the greatest common denominator, <span>$1/D$</span>, the step becomes</p><p class="math-container">\[y[n+1]-y[n]= \frac{1}{D}(\sum_{p=0}^{k}b_p^{\prime}\nabla^p)f[n+1]+\cdots,\]</p><p>where <span>$b_0^{\prime},\ldots,b_k^{\prime}$</span> are integers and <span>$b_p=b_p^{\prime}/D$</span>. In practice the expansion is restricted to <span>$k&lt;18$</span> (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to <span>$k = 10$</span>). Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}b_p\nabla^pf[n]=\sum_{p=0}^{k}b_p\sum_{j=0}^{p} c_j^if[n-j]= \sum_{j=0}^{k}a_j^k(x)f[n-j]= \sum_{j=0}^{k}a_{k-j}^k(x)f[n-k+j],\]</p><p>where the <span>$a_j^k(x)= \sum_{p=j}^{k} b_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Moulton integration weights</em>. These are generated in <em>backward order</em> by the function <a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>f_diff_expansion_weights(coeffs,∇)</code></a>, with <code>∇ =</code><a href="#CamiXon.f_diff_weights_array-Tuple{Int64}"><code>f_diff_weights_array(k)</code></a>.</p><p>Functions:</p><p><code>coeffs</code> = <a href="#CamiXon.f_diff_expansion_coeffs_adams_moulton-Tuple{Int64}"><code>f_diff_expansion_coeffs_adams_moulton(k)</code></a> <span>$\rightarrow [b_0,\ldots,b_k]$</span></p><p><code>adams_moulton_weights</code> = <a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>f_diff_expansion_weights(coeffs,∇)</code></a><span>$\rightarrow [a_k^k,\ ,\ldots,\ a_0^k]$</span></p><p><code>adams_moulton_weights</code> = <a href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>create_adams_moulton_weights(k)</code></a><span>$\rightarrow [a_k^k,\ ,\ldots,\ a_0^k]$</span></p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.f_diff_expansion_coeffs_adams_moulton-Tuple{Int64}" href="#CamiXon.f_diff_expansion_coeffs_adams_moulton-Tuple{Int64}"><code>CamiXon.f_diff_expansion_coeffs_adams_moulton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_diff_expansion_coeffs_adams_moulton(k [; T=Int])</code></pre><p><span>$k^{th}$</span>-order Adams-Moulton expansion coefficients,</p><p class="math-container">\[-\frac{\nabla}{ln(1-\nabla)} = \sum_{p=0}^{\infty}b_p\nabla^p= 1 - \frac{1}{2}\nabla - \frac{1}{12}\nabla^2 - \frac{1}{24}\nabla^3 +\cdots.\]</p><p>The weights are stored in <em>forward</em> order: <span>$[b_0^k,\ \cdots,\ b_k^k]$</span> - order of use in summation.</p><p><strong>Examples:</strong></p><pre><code class="language-none">k = 5
b = f_diff_expansion_coeffs_adams_moulton(k::Int); println(b)
 Rational[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]

D = denominator(gcd(b)); println(D)
 1440

o = convert(Vector{Int},(b .* D)); println(o)
 [1440, -720, -120, -60, -38, -27]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/adams.jl#LL3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.create_adams_moulton_weights-Tuple{Int64}" href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>CamiXon.create_adams_moulton_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])</code></pre><p><span>$k^{th}$</span>-order Adams-Moulton weights vector,</p><p class="math-container">\[y[n+1] = y[n] + \frac{1}{D}\sum_{j=0}^{k}a^k[j]f[n+1-k+j]\]</p><p>The weights are stored in the vector <span>$a^k \equiv[a_k^k/D,\ \cdots,\ a_0^k/D]$</span> under the convention <span>$a^k[j] \equiv a_{k-j}^k/D$</span>, where <span>$a_j^k$</span> are the Adams-Moulton weight coefficients and <span>$D$</span> the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="language-none">[create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:8]
8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
 (1, 2, [1, 1])
 (2, 12, [-1, 8, 5])
 (3, 24, [1, -5, 19, 9])
 (4, 720, [-19, 106, -264, 646, 251])
 (5, 1440, [27, -173, 482, -798, 1427, 475])
 (6, 60480, [-863, 6312, -20211, 37504, -46461, 65112, 19087])
 (7, 120960, [1375, -11351, 41499, -88547, 123133, -121797, 139849, 36799])
 (8, 3628800, [-33953, 312874, -1291214, 3146338, -5033120, 5595358, -4604594, 4467094, 1070017])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/adams.jl#LL49-L73">source</a></section></article><h2 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h2><p>The <code>Grid</code> object is the backbone for the numerical procedure on a non-uniform grid. Its principal fields are <code>grid.r</code> and <code>grid.r′</code>, which are discrete functions of <code>N</code> elements representing the grid function and its derivative.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Grid" href="#CamiXon.Grid"><code>CamiXon.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Grid(ID, name, T, N, r, r′, h, r0, epn, epw, k)</code></pre><p>Type with fields:</p><ul><li><code>.ID</code>::Int                 grid identifer name</li><li><code>.name</code>::String              grid identifer name</li><li><code>.T</code>::Type                gridType</li><li><code>.N</code>::Int                 number of grid points</li><li><code>.r</code>::Vector{T}           tabulated grid function</li><li><code>.r′</code>::Vector{T}           tabulated derivative of grid function</li><li><code>.h</code> ::T                   grid step multiplyer</li><li><code>.r0</code>::T                   grid scale factor</li><li><code>.epn</code>::Int                 number of endpoints used for trapezoidal endpoint correction (must be odd)</li><li><code>.epw</code>::Vector{Vector{T}}   trapezoidal endpoint weights for n=1:epn</li><li><code>.k</code>::Int                 Adams-Moulton order</li></ul><p>The object <code>Grid</code> is best created by the function <a href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>castGrid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/grid.jl#LL3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.gridfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T &lt;: Real</code></pre><ul><li><code>ID = 1</code>: exponential grid function,</li></ul><p class="math-container">\[    f[n] = exp(h(n-1)) - 1.0\]</p><ul><li><code>ID = 2</code>: quasi-exponential grid function (linear grid for p = 1),</li></ul><p class="math-container">\[    f[n] = h(n-1) + \frac{1}{2}(h(n-1))^2 + \cdots + \frac{1}{p!}(h(n-1))^p\]</p><ul><li><code>ID = 3</code>: polynomial grid function based on <code>polynom</code> <span>$c = [c_1,c_2,\ldots,c_p]$</span>,</li></ul><p class="math-container">\[    f[n] = c_1h(n-1) + c_2(h(n-1))^2 + \cdots + c_p(h(n-1))^p\]</p><ul><li><code>ID = 4</code>: linear grid function,</li></ul><p class="math-container">\[    f[n] = (n-1) * h\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">h = 0.1
r = [gridfunction(1, n-1, h) for n=1:5]                            # exponential
 [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032, 0.49182469764127035]

r = [gridfunction(2, n-1, h; p = 4) for n=1:5]  # quasi exponential (degree p=4)
 [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375, 0.49173333333333336]

r = [gridfunction(3, n-1, h; coords = [0,1,1/2,1/6,1/24]) for n=1:5]  # polynomial (degree p=4)
 [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001, 0.49173333333333336]

r = [gridfunction(4, n-1, h) for n=1:5]              # linear
  [0.0, 0.1, 0.2, 0.3, 0.4]

r′= [gridfunction(4, n-1, h; deriv=1) for n=1:5]     # linear (first derivative)
   [0.1, 0.1, 0.1, 0.1, 0.1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/grid.jl#LL124-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castGrid-Tuple{Int64, Int64, Type}" href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>CamiXon.castGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castGrid(ID::Int, N::Int, T::Type; h=1, r0=1,  p=5, coords=[0,1], epn=7, k=7, msg=true)</code></pre><p>Method to create the Grid object</p><p><code>ID = 1</code>: exponential grid, <code>ID = 2</code>: quasi-exponential grid, <code>ID = 3</code>: polynomial grid <code>ID = 4</code>: linear grid</p><p><strong>Examples:</strong></p><pre><code class="language-none">h = 0.1
r0 = 1.0
grid = castGrid(1, 4, Float64; h, r0)                 # exponential grid
grid.r
 [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]

grid = castGrid(2, 4, Float64; p = 4, h, r0)          # quasi-exponential grid
grid.r
 [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375]

grid = castGrid(3, 4, Float64; coords=[0, 1, 1/2, 1/6, 1/24], h, r0)  # polynomial grid
grid.r
 [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001]

grid = castGrid(4, 4, Float64; h, r0)                 # linear grid
grid.r
 [0.0, 0.1, 0.2, 0.3]
grid.r′
 [0.1, 0.1, 0.1, 0.1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/grid.jl#LL175-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoRmax-Tuple{Atom, Orbit}" href="#CamiXon.autoRmax-Tuple{Atom, Orbit}"><code>CamiXon.autoRmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoRmax(atom::Atom, orbit::Orbit)</code></pre><p>Largest relevant radial distance in a.u. (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
atom = castAtom(Z=1, Q=0, M=1.00782503223, I=1//2, gI=5.585694713; msg=true)
orbit = castOrbit(n=1, ℓ=0)
rmax = autoRmax(atom::Atom, orbit::Orbit); println(&quot;rmax = $(rmax) a.u.&quot;)
  Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.00782503223, I = 1//2, gI = 5.585694713)
  Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)
  rmax = 63.0 a.u.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/grid.jl#LL228-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoNtot-Tuple{Orbit}" href="#CamiXon.autoNtot-Tuple{Orbit}"><code>CamiXon.autoNtot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoNtot(orbit::Orbit)</code></pre><p>Total number of gridpoints (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="language-none">orbit = castOrbit(1,0)
autoNtot(orbit)
 Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)

 100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/grid.jl#LL258-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real" href="#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real"><code>CamiXon.autoPrecision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoPrecision(Rmax::T, orbit::Orbit) where T&lt;:Real</code></pre><p>Floating point precision (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="language-none">atom = castAtom(1)
orbit = castOrbit(1,0)
Rmax = autoRmax(atom, orbit)
autoPrecision(Rmax, orbit)
 Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.0, I = 1//2, gI = 5.5)
 Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)

 Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/grid.jl#LL286-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.autoSteps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoSteps(ID::Int, Ntot::Int, Rmax::T; p=5, coords=[0,1]) where T&lt;:Real</code></pre><p>Step size parameter (h) and range parameter (r0) (rule of thumb values).</p><p><strong>Example:</strong></p><pre><code class="language-none">(h, r0) = autoSteps(1, 100, 100)
 (0.1, 0.004540199100968777)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/grid.jl#LL317-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.grid_trapezoidal_integral-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{T}}} where T&lt;:Real" href="#CamiXon.grid_trapezoidal_integral-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_trapezoidal_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_trapezoidal_integral(f::Vector{T}, n1::Int, n2::Int, grid::Grid{T}) where T&lt;:Real</code></pre><p>Integral of the function <span>$f=[f_0,\cdots,\ f_n]$</span> tabulated on a <a href="#CamiXon.Grid"><code>Grid</code></a> using the trapezoidal rule optimized with endpoint correction by the weightsvector <code>grid.epw</code>,</p><p class="math-container">\[    ∫_{0}^{r_n} f(r) dr = ∫_{0}^{n} f(x) r^{\prime}(x) dx,\]</p><p>where the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see <a href="#CamiXon.trapezoidal_integration-Tuple{Any, Any, Any}"><code>trapezoidal_integration</code></a>). The rule is exact for polynonials of degree <span>$d=0,\ 1,\cdots,\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Example:</strong></p><pre><code class="language-none">f1s(r) = 2.0*r*exp(-r)  # hydrogen 1s wavefunction (reduced and unit normalized)
N = 1000
grid = castGrid(1, N, Float64; h=0.01, r0=0.005)
r = grid.r
f2 = [f1s(r[n])^2 for n=1:N]
norm = grid_trapezoidal_integral(f2, 1:N, grid)
  create exponential Grid: Float64, Rmax = 110.127 (a.u.), Ntot = 1000, h = 0.01, r0 = 0.005

  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/grid.jl#LL341-L366">source</a></section></article><h2 id="Def-settings-for-the-1D-Schrödinger-equation"><a class="docs-heading-anchor" href="#Def-settings-for-the-1D-Schrödinger-equation">Def settings for the 1D Schrödinger equation</a><a id="Def-settings-for-the-1D-Schrödinger-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Def-settings-for-the-1D-Schrödinger-equation" title="Permalink"></a></h2><p>The <code>Def</code> object serves to define the problem to be solved and to contain in the field <code>def.Z</code> the solution as a discrete function of <code>N</code> elements.</p><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Pos" href="#CamiXon.Pos"><code>CamiXon.Pos</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pos(Nmin::Int, Na::Int, Nuctp::Int, Nb::Int, N::Int, nodes::Int)</code></pre><p>Type with fields:</p><ul><li><code>.Na</code>: grid index of last leading point (<code>::Int</code>)</li><li><code>.Nlctp</code>: grid index of classical turning point (<code>::Int</code>)</li><li><code>.Nmin</code>: grid index of (screened) potential minimum (<code>::Int</code>)</li><li><code>.Nuctp</code>: grid index of classical turning point (<code>::Int</code>)</li><li><code>.Nb</code>: grid index first trailing point (<code>::Int</code>)</li><li><code>.N</code>: grid index last point (<code>::Int</code>)</li><li><code>.nodes</code>: number of nodes  (<code>::Int</code>)</li></ul><p>Mutable struct to hold special grid indices as well as the number of nodes</p><p><strong>Examples:</strong></p><pre><code class="language-none">pos = Pos(1, 2, 3, 4, 5, 6, 7)
pos.Nuctp
 4

pos.Nuctp = 8
pos
 Pos(1, 2, 3, 8, 5, 6, 7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/def.jl#LL2-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.Def" href="#CamiXon.Def"><code>CamiXon.Def</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Def(T, atom, orbit, pot, scr, o1, o2, o3, pos, epn, k, am, matLD)</code></pre><p>Type with fields:</p><ul><li><code>.T</code>: gridType (<code>::Type</code>)</li><li><code>.atom</code>: atom object (<code>::Atom</code>)</li><li><code>.orbit</code>: orbit object (<code>::Orbit</code>)</li><li><code>.pot</code>: tabulated potential function (<code>::Vector{T}</code>)</li><li><code>.scr</code>: tabulated screening function (<code>::Vector{T}</code>)</li><li><code>.o1</code>: vector of zero-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.o2</code>: vector of zero-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.o3</code>: vector of unit-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.pos</code>: object containing Na, Nlctp, Nmin, Nuctp, Nb, N and nodes (<code>::Pos</code>)</li><li><code>.epn</code>: number of endpoints trapezoidal correction - must be odd (<code>::Int</code>)</li><li><code>.k</code>: Adams-Moulton order (<code>::Int</code>)</li><li><code>.am</code>: Adams-Moulton weight coefficients (<code>::Vector{T}</code>)</li><li><code>.matLD</code>: Lagrangian differentiation matrix (`::Matrix{T} )</li></ul><p>The object <code>Def</code> is best created by the function <code>castDef</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/def.jl#LL38-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit}} where T&lt;:Real" href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit}} where T&lt;:Real"><code>CamiXon.castDef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">castDef(grid::Grid{T}, atom::Atom, orbit::Orbit) where T &lt;: Real</code></pre><p>Create the Def object starting from the Grid and atomic properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/def.jl#LL74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.initE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initE(def::Def{T}; E=nothing) where T&lt;:Real</code></pre><p>Autogenerated seed value for the energy (option: E as a manual seed)</p><p><strong>Example:</strong></p><pre><code class="language-none">codata = castCodata(2018)
atom = castAtom(Z=1, Q=0, M=1.00782503223, I=1//2, gI=5.585694713)
orbit = castOrbit(n=1, ℓ=0)
Ecal = convert(Float64, bohrformula(atom.Z, orbit.n))
grid = autoGrid(atom, orbit, codata; msg=false)
def = castDef(grid, atom, orbit)
  Atom created: Hydrogen - ¹H (Z = 1, Zc = 1, Q = 0, M = 1.00782503223, I = 1//2, gI = 5.585694713)
  Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)

E = initE(def); println(&quot;E = $E&quot;)
  E = -0.03508495857961283

E = initE(def; E=Ecal); println(&quot;E = $E&quot;)
  E = -0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/def.jl#LL111-L132">source</a></section></article><h2 id="FITS"><a class="docs-heading-anchor" href="#FITS">FITS</a><a id="FITS-1"></a><a class="docs-heading-anchor-permalink" href="#FITS" title="Permalink"></a></h2><p>FITS stands for &#39;Flexible Image Transport System&#39;. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.</p><p>Within CamiXion only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.</p><p>A FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.</p><p>By the command <code>f = fits_read(filnam)</code> we asign a collection of <code>FITS_HDU</code> objects from the file <code>filnam</code> to the variable <code>f</code>.</p><h3 id="FITS-Types"><a class="docs-heading-anchor" href="#FITS-Types">FITS - Types</a><a id="FITS-Types-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_HDU" href="#CamiXon.FITS_HDU"><code>CamiXon.FITS_HDU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_HDU{T,V}</code></pre><p>Object to hold a single &quot;Header-Data Unit&quot; (HDU).</p><p>The fields are</p><ul><li><code>.filename</code>:  name of the corresponding FITS file (<code>::String</code>)</li><li><code>.hduindex:</code>:  identifier (a file may contain more than one HDU) (<code>:Int</code>)</li><li><code>.header</code>:  the header object where T=FITS_header (<code>::T</code>)</li><li><code>.dataobject</code>:  the data object where V=FITS_data (<code>::V</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_objects.jl#LL3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_header" href="#CamiXon.FITS_header"><code>CamiXon.FITS_header</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_header</code></pre><p>Object to hold the header information of a <a href="#CamiXon.FITS_HDU"><code>FITS_HDU</code></a>.</p><p>The fields are:</p><ul><li><code>.hduindex</code>:  identifier (a file may contain more than one HDU) (<code>::Int</code>)</li><li><code>.records</code>:  the header formated as an array of strings of 80 ASCII characters (<code>::Array{String,1}</code>)</li><li><code>.keys</code>:  <code>keys[i]</code> - key corresponding to <code>records[i]</code> (record of index <code>i</code>)  (<code>::Array{String,1}</code>)</li><li><code>.values</code>:  <code>value[i]</code> - corresponding to <code>records[i]</code>  (<code>::Array{Any,1}</code>)</li><li><code>.comments</code>:  <code>comments[i]</code> - comment corresponding to <code>records[i]</code> (<code>::String</code>)</li><li><code>.dict</code>:  Dictionary <code>key[i] =&gt; value[i]</code> (<code>::Dict{String,Any}</code>)</li><li><code>.maps</code>:  Dictionary <code>key[i] =&gt; i</code> (<code>::Dict{String,Int}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_objects.jl#LL47-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_data" href="#CamiXon.FITS_data"><code>CamiXon.FITS_data</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_data</code></pre><p>Object to hold the data of the <a href="#CamiXon.FITS_HDU"><code>FITS_HDU</code></a> of given <code>hduindex</code> and <code>hdutype</code>.</p><p>The fields are:</p><ul><li><code>.hduindex</code>:  identifier (a file may contain more than one HDU) (<code>::Int</code>)</li><li><code>.hdutype</code>:  accepted types are &#39;PRIMARY&#39;, &#39;IMAGE&#39; and &#39;TABLE&#39; (<code>::String</code>)</li><li><code>.data</code>:  in the from appropriate for the <code>hdutype</code> (::Any)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_objects.jl#LL75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_table" href="#CamiXon.FITS_table"><code>CamiXon.FITS_table</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_table</code></pre><p>Object to hold the data of a <code>TABLE HDU</code> (a <a href="#CamiXon.FITS_HDU"><code>FITS_HDU</code></a> for ASCII tables). It contains the data in the form of records (rows) of ASCII strings.</p><p>The fields are:</p><ul><li><code>.hduindex</code>:  identifier (a file may contain more than one HDU) (<code>::Int</code>)</li><li><code>.rows</code>:  the table formated as an array of rows of ASCII strings (<code>::Array{String,1}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_objects.jl#LL96-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FITS_name" href="#CamiXon.FITS_name"><code>CamiXon.FITS_name</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FITS_name</code></pre><p>FITS object to hold the decomposed name of a .fits file.</p><p>The fields are:</p><ul><li><code>.name</code>:  for &#39;p#.fits&#39; this is &#39;p#.fits&#39; (<code>::String</code>)</li><li><code>.prefix</code>:  for &#39;p#.fits&#39; this is &#39;p&#39; (<code>::String</code>)</li><li><code>.numerator</code>:  for &#39;p#.fits&#39; this is &#39;#&#39;, a serial number (e.g., &#39;3&#39;) or a range (e.g., &#39;3-7&#39;) (<code>::String</code>)</li><li><code>.extension</code>:  for &#39;p#.fits&#39; this is &#39;.fits&#39; (<code>::String</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_objects.jl#LL25-L35">source</a></section></article><h3 id="FITS-HDU-Methods"><a class="docs-heading-anchor" href="#FITS-HDU-Methods">FITS - HDU Methods</a><a id="FITS-HDU-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-HDU-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_info-Tuple{FITS_HDU}" href="#CamiXon.fits_info-Tuple{FITS_HDU}"><code>CamiXon.fits_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_info(hdu)</code></pre><p>Print metafinformation and data of given <code>FITS_HDU</code></p><p><strong>Example:</strong></p><pre><code class="language-none">strExample = &quot;remove.fits&quot;
data = [11,21,31,12,22,23,13,23,33]
data = reshape(data,(3,3,1))
fits_create(strExample, data; protect=false)

f = fits_read(strExample)
fits_info(f[1])

  File: remove.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Int64
  Datasize: (3, 3, 1)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  BITPIX  =                   64 / number of bits per data pixel
  NAXIS   =                    3 / number of data axes
  NAXIS1  =                    3 / length of data axis 1
  NAXIS2  =                    3 / length of data axis 2
  NAXIS3  =                    1 / length of data axis 3
  BZERO   =                  0.0 / offset data range to that of unsigned integer
  BSCALE  =                  1.0 / default scaling factor
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  END

  3×3×1 Array{Int64, 3}:
  [:, :, 1] =
   11  12  13
   21  22  23
   31  23  33
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL208-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.parse_FITS_TABLE-Tuple{FITS_HDU}" href="#CamiXon.parse_FITS_TABLE-Tuple{FITS_HDU}"><code>CamiXon.parse_FITS_TABLE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_FITS_TABLE(hdu)</code></pre><p>Parse <code>FITS_TABLE</code> (ASCII table) into a Vector of its columns for further processing by the user. Default formatting in ISO 2004 FORTRAN data format specified by keys &quot;TFORMS1&quot; - &quot;TFORMSn&quot;). Display formatting in ISO 2004 FORTRAN data format (&quot;TDISP1&quot; - &quot;TDISPn&quot;) prepared for user editing.</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample = &quot;example.fits&quot;
data = [10, 20, 30]
fits_create(strExample, data; protect=false)

t1 = Float16[1.01E-6,2.0E-6,3.0E-6,4.0E-6,5.0E-6]
t2 = [0x0000043e, 0x0000040c, 0x0000041f, 0x0000042e, 0x0000042f]
t3 = [1.23,2.12,3.,4.,5.]
t4 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]
t5 = [&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;,&quot;dddd&quot;,&quot;ABCeeaeeEEEEEEEEEEEE&quot;]
data = [t1,t2,t3,t4,t5]
fits_extend(strExample, data, &quot;TABLE&quot;)

f = fits_read(strExample)
d = f[2].header.dict
d = [get(d,&quot;TFORM$i&quot;,0) for i=1:5]; println(strip.(d))
  SubString{String}[&quot;&#39;E6.1    &#39;&quot;, &quot;&#39;I4      &#39;&quot;, &quot;&#39;F4.2    &#39;&quot;, &quot;&#39;A1      &#39;&quot;, &quot;&#39;A20     &#39;&quot;]

f[2].dataobject.data                            # this is the table hdu
  5-element Vector{String}:
   &quot;1.0e-6 1086 1.23 a a                    &quot;
   &quot;2.0e-6 1036 2.12 b bb                   &quot;
   &quot;3.0e-6 1055 3.0  c ccc                  &quot;
   &quot;4.0e-6 1070 4.0  d dddd                 &quot;
   &quot;5.0e-6 1071 5.0  e ABCeeaeeEEEEEEEEEEEE &quot;

parse_FITS_TABLE(f[2])
  5-element Vector{Vector{T} where T}:
   [1.0e-6, 2.0e-6, 3.0e-6, 4.0e-6, 5.0e-6]
   [1086, 1036, 1055, 1070, 1071]
   [1.23, 2.12, 3.0, 4.0, 5.0]
   [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
   [&quot;a                   &quot;, &quot;bb                  &quot;, &quot;ccc                 &quot;, &quot;dddd                &quot;, &quot;ABCeeaeeEEEEEEEEEEEE&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL743-L784">source</a></section></article><h3 id="FITS-File-Methods"><a class="docs-heading-anchor" href="#FITS-File-Methods">FITS - File Methods</a><a id="FITS-File-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-File-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.cast_FITS_name-Tuple{String}" href="#CamiXon.cast_FITS_name-Tuple{String}"><code>CamiXon.cast_FITS_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cast_FITS_name(filename::String)</code></pre><p>Decompose the FITS filename &#39;filnam.fits&#39; into its name, prefix, numerator and extension.</p><p><strong>Examples:</strong></p><pre><code class="language-none">strExample = &quot;T23.01.fits&quot;
f = cast_FITS_name(strExample)
FITS_name(&quot;T23.01&quot;, &quot;T23.&quot;, &quot;01&quot;, &quot;.fits&quot;)

f.name, f.prefix, f.numerator, f.extension
(&quot;T23.01&quot;, &quot;T23.&quot;, &quot;01&quot;, &quot;.fits&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_private_sector.jl#LL7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_combine-Tuple{String, String}" href="#CamiXon.fits_combine-Tuple{String, String}"><code>CamiXon.fits_combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_combine(strFirst, strLast [; protect=true])</code></pre><p>Copy &quot;filenameFirst&quot; to &quot;filenameLast&quot; (with mandatory &quot;.fits&quot; extension)</p><p>Key:</p><ul><li><code>protect::Bool</code>: overwrite protection</li></ul><p><strong>Example:</strong></p><pre><code class="language-none">fits_combine(&quot;T01.fits&quot;, &quot;T22.fits&quot;)
  &#39;T01-T22.fits&#39;: file created</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL40-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_copy" href="#CamiXon.fits_copy"><code>CamiXon.fits_copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fits_copy(filenameA [, filenameB=&quot;&quot; [; protect=true]])</code></pre><p>Copy &quot;filenameA&quot; to &quot;filenameB&quot; (with mandatory &quot;.fits&quot; extension) Key:</p><ul><li><code>protect::Bool</code>: overwrite protection</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">fits_copy(&quot;T01.fits&quot;)
  &#39;T01.fits&#39; was saved as &#39;T01 - Copy.fits&#39;

fits_copy(&quot;T01.fits&quot;, &quot;T01a.fits&quot;)
  FitsError: &#39;T01a.fits&#39; in use (set &#39;;protect=false&#39; to lift overwrite protection)

fits_copy(&quot;T01.fits&quot;, &quot;T01a.fits&quot;; protect=false)
  &#39;T01.fits&#39; was saved as &#39;T01a.fits&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_create" href="#CamiXon.fits_create"><code>CamiXon.fits_create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fits_create(filename [, data [; protect=true]])</code></pre><p>Create FITS file of given filename [, optional data block [, default overwrite protection]] and return Array of HDUs. Key:</p><ul><li><code>protect::Bool</code>: overwrite protection</li></ul><p><strong>Examples:</strong></p><pre><code class="language-none">strExample = &quot;minimal.fits&quot;
fits_create(strExample;protect=false)

f = fits_read(strExample)
a = f[1].dataobject.data
b = f[1].header.keys
println(a);println(b)
  Any[]
  [&quot;SIMPLE&quot;, &quot;NAXIS&quot;, &quot;EXTEND&quot;, &quot;COMMENT&quot;, &quot;END&quot;]

strExample = &quot;remove.fits&quot;
data = [11,21,31,12,22,23,13,23,33]
data = reshape(data,(3,3,1))
fits_create(strExample, data; protect=false)

f = fits_read(strExample)
fits_info(f[1])

  File: remove.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Int64
  Datasize: (3, 3, 1)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  BITPIX  =                   64 / number of bits per data pixel
  NAXIS   =                    3 / number of data axes
  NAXIS1  =                    3 / length of data axis 1
  NAXIS2  =                    3 / length of data axis 2
  NAXIS3  =                    1 / length of data axis 3
  BZERO   =                  0.0 / offset data range to that of unsigned integer
  BSCALE  =                  1.0 / default scaling factor
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  END

  3×3×1 Array{Int64, 3}:
  [:, :, 1] =
   11  12  13
   21  22  23
   31  23  33</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL115-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_extend" href="#CamiXon.fits_extend"><code>CamiXon.fits_extend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fits_extend(filename, data_extend, hdutype=&quot;IMAGE&quot;)</code></pre><p>Extend the FITS file of given filename with the data of <code>hdutype</code> from <code>data_extend</code>  and return Array of HDUs.</p><p><strong>Examples:</strong></p><pre><code class="language-none">strExample = &quot;test_example.fits&quot;
data = [0x0000043e, 0x0000040c, 0x0000041f]
fits_create(strExample, data, protect=false)

f = fits_read(strExample)
a = Float16[1.01E-6,2.0E-6,3.0E-6,4.0E-6,5.0E-6]
b = [0x0000043e, 0x0000040c, 0x0000041f, 0x0000042e, 0x0000042f]
c = [1.23,2.12,3.,4.,5.]
d = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]
e = [&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;,&quot;dddd&quot;,&quot;ABCeeaeeEEEEEEEEEEEE&quot;]
data = [a,b,c,d,e]
fits_extend(strExample, data, &quot;TABLE&quot;)

f = fits_read(strExample)
f[2].dataobject.data
  5-element Vector{String}:
   &quot;1.0e-6 1086 1.23 a a                    &quot;
   &quot;2.0e-6 1036 2.12 b bb                   &quot;
   &quot;3.0e-6 1055 3.0  c ccc                  &quot;
   &quot;4.0e-6 1070 4.0  d dddd                 &quot;
   &quot;5.0e-6 1071 5.0  e ABCeeaeeEEEEEEEEEEEE &quot;

rm(strExample); f = data = a = b = c = d = e = nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL324-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_read-Tuple{String}" href="#CamiXon.fits_read-Tuple{String}"><code>CamiXon.fits_read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_read(filename)</code></pre><p>Read FITS file and return Array of <code>FITS_HDU</code>s</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample = &quot;minimal.fits&quot;
fits_create(strExample;protect=false)

f = fits_read(strExample)
f[1].dataobject.data
  Any[]

rm(strExample); f = nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL273-L288">source</a></section></article><h3 id="FITS-Key-Methods"><a class="docs-heading-anchor" href="#FITS-Key-Methods">FITS - Key Methods</a><a id="FITS-Key-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FITS-Key-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_add_key-Tuple{String, Int64, String, Real, String}" href="#CamiXon.fits_add_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_add_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_add_key(filename, hduindex, key, value, comment)</code></pre><p>Add a header record of given &#39;key, value and comment&#39; to &#39;HDU[hduindex]&#39; of file with name &#39;filename&#39;</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;FITS dataset may contain extension&quot;)

f = fits_read(strExample)
fits_info(f[1])

  File: minimal.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Any
  Datasize: (0,)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  NAXIS   =                    0 / number of data axes
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  KEYNEW1 =                    T / FITS dataset may contain extension
  END

  Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL413-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_delete_key-Tuple{String, Int64, String}" href="#CamiXon.fits_delete_key-Tuple{String, Int64, String}"><code>CamiXon.fits_delete_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_delete_key(filename, hduindex, key)</code></pre><p>Delete a header record of given <code>key</code>, <code>value</code> and <code>comment</code> to <code>FITS_HDU[hduindex]</code> of file with name  &#39;filename&#39;</p><p><strong>Examples:</strong></p><pre><code class="language-none">strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;this is record 5&quot;)

f = fits_read(strExample)
get(f[1].header.maps,&quot;KEYNEW1&quot;,0)
  5

fits_delete_key(strExample, 1, &quot;KEYNEW1&quot;)

f = fits_read(strExample)
get(f[1].header.maps,&quot;KEYNEW1&quot;,0)
  0

fits_delete_key(filnam, 1, &quot;NAXIS&quot;)
 &#39;NAXIS&#39;: cannot be deleted (key protected under FITS standard)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL573-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_edit_key-Tuple{String, Int64, String, Real, String}" href="#CamiXon.fits_edit_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_edit_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_edit_key(filename, hduindex, key, value, comment)</code></pre><p>Edit a header record of given &#39;key, value and comment&#39; to &#39;HDU[hduindex]&#39; of file with name &#39;filename&#39;</p><p><strong>Example:</strong></p><pre><code class="language-none">data = DateTime(&quot;2020-01-01T00:00:00.000&quot;)
strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;this is record 5&quot;)
fits_edit_key(strExample, 1, &quot;KEYNEW1&quot;, data, &quot;record 5 changed to a DateTime type&quot;)

f = fits_read(strExample)
fits_info(f[1])

  File: minimal.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Any
  Datasize: (0,)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  NAXIS   =                    0 / number of data axes
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  KEYNEW1 = &#39;2020-01-01T00:00:00&#39; / record 5 changed to a DateTime type
  END

  Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL489-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.fits_rename_key-Tuple{String, Int64, String, String}" href="#CamiXon.fits_rename_key-Tuple{String, Int64, String, String}"><code>CamiXon.fits_rename_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fits_rename_key(filename, hduindex, keyold, kewnew)</code></pre><p>Rename the key of a header record of file with name &#39;filename&#39;</p><p><strong>Example:</strong></p><pre><code class="language-none">strExample=&quot;minimal.fits&quot;
fits_create(strExample;protect=false)
fits_add_key(strExample, 1, &quot;KEYNEW1&quot;, true, &quot;this is record 5&quot;)
fits_rename_key(strExample, 1, &quot;KEYNEW1&quot;,  &quot;KEYNEW2&quot;)

f = fits_read(strExample)
fits_info(f[1])

  File: minimal.fits
  hdu: 1
  hdutype: PRIMARY
  DataType: Any
  Datasize: (0,)

  Metainformation:
  SIMPLE  =                    T / file does conform to FITS standard
  NAXIS   =                    0 / number of data axes
  EXTEND  =                    T / FITS dataset may contain extensions
  COMMENT    Primary FITS HDU    / http://fits.gsfc.nasa.gov/iaufwg
  KEYNEW2 =                    T / this is record 5
  END

  Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/fits_public_sector.jl#LL654-L684">source</a></section></article><h2 id="FORTRAN"><a class="docs-heading-anchor" href="#FORTRAN">FORTRAN</a><a id="FORTRAN-1"></a><a class="docs-heading-anchor-permalink" href="#FORTRAN" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.FORTRAN_format" href="#CamiXon.FORTRAN_format"><code>CamiXon.FORTRAN_format</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FORTRAN_format</code></pre><p>Object to hold a FORTRAN format specifier decomposed in its fields.</p><p>Accepted <em>datatype specifiers</em> are:  <code>Aw</code>,  <code>Iw</code>,  <code>Fw.d</code>,  <code>Ew.d</code>,  <code>Dw.d</code></p><p>Accepted <em>output formating specifiers</em> are: <code>Aw</code>,  <code>Iw.m</code>,  <code>Bw.m</code>,  <code>Ow.m</code>, <code>Zw.m</code>,  <code>Fw.d</code>,  <code>Ew.dEe</code>,  <code>ENw.d</code>,  <code>ESw.d</code>,  <code>Gw.dEe</code>,  <code>Dw.dEe</code>. Notation: <code>w</code> - width, <code>m</code> (optional) - minimum number of digits, <code>d</code> - number of digits to right of decimal, <code>e</code> - number of digits in exponent <code>N</code>/<code>S</code> (optional) indicates engineering/scientific formating of the <code>E</code> type.</p><p>The fields are:</p><ul><li><code>.Type</code>: primary FORTRAN datatype (<code>::String</code>)</li><li><code>.TypeChar</code>: primary FORTRAN datatype character (<code>::Char</code>)</li><li><code>.EngSci</code>: secundary datatype character - N for engineering/ S for scientific (<code>::Union{Char,Nothing}</code>)</li><li><code>.width</code>: width of numeric field (<code>::Int</code>)</li><li><code>.nmin</code>: minimum number of digits displayed (<code>::Int</code>)</li><li><code>.ndec</code>: number of digits to right of decimal (<code>::Int</code>)</li><li><code>.nexp</code>: number of digits in exponent (<code>::Int</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/FORTRAN.jl#LL3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.cast_FORTRAN_format-Tuple{String}" href="#CamiXon.cast_FORTRAN_format-Tuple{String}"><code>CamiXon.cast_FORTRAN_format</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cast_FORTRAN_format(format::String)</code></pre><p>Decompose the format specifier <code>format</code> into its fields and cast this into the <a href="#CamiXon.FORTRAN_format"><code>FORTRAN_format</code></a> object. Allowed format specifiers are of the types: <code>Aw</code>, <code>Iw.m</code>, <code>Bw.m</code>, <code>Ow.m</code>, <code>Zw.m</code>, <code>Fw.d</code>, <code>Ew.dEe</code>, <code>ENw.d</code>, <code>ESw.d</code>, <code>Gw.dEe</code>, <code>Dw.dEe</code>, with: <code>w</code> - width, <code>m</code>(optional) - minimum number of digits, <code>d</code> - number of digits to right of decimal, <code>e</code> - number of digits in exponent; <code>N</code>/<code>S</code> (optional) indicates engineering/scientific formating of the <code>E</code> type.</p><p><strong>Examples:</strong></p><pre><code class="language-none">f = cast_FORTRAN_format(&quot;I10&quot;)
  FORTRAN_format(&quot;Iw&quot;, &#39;I&#39;, nothing, 10, 0, 0, 0)

f = cast_FORTRAN_format(&quot;I10.12&quot;)
  FORTRAN_format(&quot;Iw.m&quot;, &#39;I&#39;, nothing, 10, 12, 0, 0)

f = cast_FORTRAN_format(&quot;E10.5E3&quot;)
  FORTRAN_format(&quot;Ew.dEe&quot;, &#39;E&#39;, nothing, 10, 0, 5, 3)

f.Type, f.TypeChar, f.EngSci, f.width, f.nmin, f.ndec, f.nexp
  (&quot;Ew.dEe&quot;, &#39;E&#39;, nothing, 10, 0, 5, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/FORTRAN.jl#LL39-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.cast_FORTRAN_datatype-Tuple{String}" href="#CamiXon.cast_FORTRAN_datatype-Tuple{String}"><code>CamiXon.cast_FORTRAN_datatype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cast_FORTRAN_datatype(format::String)</code></pre><p>Decompose the format specifier <code>format</code> into its fields and cast this into the <a href="#CamiXon.FORTRAN_format"><code>FORTRAN_format</code></a> object. Allowed format specifiers are of the types: <code>Aw</code>, <code>Iw</code>, <code>Fw.d</code>, <code>Ew.d</code>, <code>Dw.d</code>, where: <code>w</code> - width, <code>d</code> - number of digits to right of decimal point.</p><p><strong>Examples:</strong></p><pre><code class="language-none">f = cast_FORTRAN_datatype(&quot;I10&quot;)
  FORTRAN_format(&quot;Iw&quot;, &#39;I&#39;, nothing, 10, 0, 0, 0)

f = cast_FORTRAN_datatypet(&quot;F10.4&quot;)
  FORTRAN_format(&quot;Fw.d&quot;, &#39;F&#39;, nothing, 10, 0, 4, 0)

f = cast_FORTRAN_datatype(&quot;E10.5&quot;)
  FORTRAN_format(&quot;Ew.d&quot;, &#39;E&#39;, nothing, 10, 0, 5, 0)

f.Type, f.TypeChar, f.EngSci, f.width, f.nmin, f.ndec, f.nexp
  (&quot;Ew.d&quot;, &#39;E&#39;, nothing, 10, 0, 5, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/FORTRAN.jl#LL113-L134">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.step125-Tuple{Real}" href="#CamiXon.step125-Tuple{Real}"><code>CamiXon.step125</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step125(x)</code></pre><p>Step used for deviding the number x in steps according to 1-2-5 scheme</p><p><strong>Examples:</strong></p><pre><code class="language-none">step125.([5,10,21.3,50,100.1])
5-element Vector{Int64}:
  1
  2
  5
 10
 20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/plot_public_sector.jl#LL3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.select125-Tuple{Any}" href="#CamiXon.select125-Tuple{Any}"><code>CamiXon.select125</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">select125(x)</code></pre><p>Select elements of the collection x by index according to 1-2-5 scheme</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [1,2,4,6,8,10,13,16,18,20,40,60,80,100]
select125(x)
 [2, 6, 10, 16, 20, 60, 100]

x = string.(x)
select125(x)
 [&quot;2&quot;, &quot;6&quot;, &quot;10&quot;, &quot;16&quot;, &quot;20&quot;, &quot;60&quot;, &quot;100&quot;]

x = 1:100
select125(x)
 [20, 40, 60, 80, 100]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/plot_public_sector.jl#LL31-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.steps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">steps(x)</code></pre><p>Heatmap range transformation for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [4,2,6]
steps(x)
 [0, 4, 6, 12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/plot_public_sector.jl#LL78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepcenters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stepcenters(x)</code></pre><p>Stepcenter positions for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [4,2,6]
stepcenters(x)
 [2.0, 5.0, 9.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/plot_public_sector.jl#LL99-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepedges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stepedges(x)</code></pre><p>Stepedges for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language-">x = [4,2,6]
stepedges(x)
 [0, 4, 6, 12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/plot_public_sector.jl#LL120-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.edges" href="#CamiXon.edges"><code>CamiXon.edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edges(px [, Δx[, x0]])</code></pre><p>Heatmap range transformation from pixel coordinates to physical coordinates, with pixelsize Δx and offset x0, both in physical units.</p><p><strong>Examples:</strong></p><pre><code class="language-">px = 1:5
Δx = 2.5
x0 = 2.5
edges(px)
 [0.5, 1.5, 2.5, 3.5, 4.5]

edges(px, Δx)
 [1.25, 3.75, 6.25, 8.75, 11.25]

edges(px, Δx, x0)
 [-1.25, 1.25, 3.75, 6.25, 8.75]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/plot_public_sector.jl#LL54-L73">source</a></section></article><h2 id="Search-and-conversion-tools"><a class="docs-heading-anchor" href="#Search-and-conversion-tools">Search and conversion tools</a><a id="Search-and-conversion-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Search-and-conversion-tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_all(A [,a...]; count=false)</code></pre><p>A: string/array of elements of the same type</p><p>default   : Array containing the index (indices) of selected elements of A (default: all elements)</p><p>count=true: The number of indices found for selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="language-none">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;
find_all(A) == find_all(B) == find_all(str)
true

find_all(A,:📌)
1-element Array{Array{Int64,1},1}:
 [2, 4]

find_all(str)
4-element Array{Array{Int64,1},1}:
 [1]
 [2, 4]
 [3]
 [5]

find_all(A; count=true)
4-element Array{Int64,1}:
 1
 2
 1
 1

str = &quot;📑📌📢📌📞&quot;
find_all(str,&#39;📌&#39;)
1-element Array{Array{Int64,1},1}:
 [2, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/search_algorithms.jl#LL1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_first(A [,a...]; dict=false)</code></pre><p>The first index of selected Array element</p><p>A: string/array of elements of the same type</p><p>default  : Array containing the first index (indices) of selected elements of A (default: all elements)</p><p>dict=true: Dict for the first index (indices) of selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="language-none">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;

find_first(A) == find_first(B) == find_first(str)
true

find_first(A,:📌)
1-element Array{Array{Int64,1},1}:
 2

find_last(A,:📌; dict=true)
1-element Array{Pair{Symbol,Int64},1}:
 :📌 =&gt; 2

find_last(A; dict=true)
4-element Array{Pair{Symbol,Int64},1}:
 :📑 =&gt; 1
 :📌 =&gt; 2
 :📢 =&gt; 3
 :📞 =&gt; 5

find_first(str)
4-element Array{Int64,1}:
 1
 2
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/search_algorithms.jl#LL53-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_last(A [,a...]; dict=false)</code></pre><p>The last index of selected Array element</p><p>A: string/array of elements of the same type</p><p>default  : Array containing the lasst index (indices) of selected elements of A (default: all elements)</p><p>dict=true: Dict for the lasst index (indices) of selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="language-none">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;
find_last(A) == find_first(B) == find_first(str)
true

find_last(A,:📌)
1-element Array{Array{Int64,1},1}:
 4

find_last(A,:📌; dict=true)
1-element Array{Pair{Symbol,Int64},1}:
 :📌 =&gt; 4

find_last(A; dict=true)
4-element Array{Pair{Symbol,Int64},1}:
 :📑 =&gt; 1
 :📌 =&gt; 4
 :📢 =&gt; 3
 :📞 =&gt; 5

find_last(str)
4-element Array{Int64,1}:
 1
 4
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/search_algorithms.jl#LL106-L146">source</a></section></article><h2 id="Math"><a class="docs-heading-anchor" href="#Math">Math</a><a id="Math-1"></a><a class="docs-heading-anchor-permalink" href="#Math" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CamiXon.bernoulli_numbers-Tuple{Int64}" href="#CamiXon.bernoulli_numbers-Tuple{Int64}"><code>CamiXon.bernoulli_numbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bernoulli_numbers(nmax [, T=Int])</code></pre><p>Bernoulli numbers <span>$B_0,\ \cdots,\ B_{nmax}$</span> calculated by repetative use of the recurrence relation</p><p class="math-container">\[    B_n = - \frac{1}{n+1}\sum_{k=0}^{n-1}\frac{(n+1)!}{k!(n+1-k)}B_k.\]</p><p>Special numbers: <span>$B_0=1,\ B_1=-1/2,\ B_{2n+1}=0\ (\rm{for}\ n&gt;1)$</span>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">bernoulli_numbers(10)
11-element Vector{Rational{Int64}}:
  1//1
 -1//2
  1//6
  0//1
 -1//30
  0//1
  1//42
  0//1
 -1//30
  0//1
  5//66</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.canonical_partitions" href="#CamiXon.canonical_partitions"><code>CamiXon.canonical_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">canonical_partitions(n; header=false, reverse=true)</code></pre><p>The canonical partition in integers of the integer n</p><p>header=true : unit patition included in output</p><p><strong>Examples:</strong></p><pre><code class="language-none">canonical_partitions(6; header=true, reverse=false)
6-element Array{Array{Int64,1},1}:
 [6]
 [5, 1]
 [4, 2]
 [3, 3]
 [2, 2, 2]
 [1, 1, 1, 1, 1, 1]

canonical_partitions(6; header=true)
6-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1]
 [2, 2, 2]
 [3, 3]
 [4, 2]
 [5, 1]
 [6]

canonical_partitions(6)
5-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1]
 [2, 2, 2]
 [3, 3]
 [4, 2]
 [5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL325-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.faulhaber_polynom-Tuple{Int64}" href="#CamiXon.faulhaber_polynom-Tuple{Int64}"><code>CamiXon.faulhaber_polynom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">faulhaber_polynom(p [, T=Int])</code></pre><p>Vector representation of the Faulhaber polynomial of degree <span>$p$</span>,</p><p class="math-container">\[    F(n,p)=\frac{1}{p}\sum_{j=1}^{p}{\binom {p}{p-j}}B_{p-j}n^{j}.\]</p><p><span>$F(n,p)=$</span> <code>polynomial(c,n)</code>, where <span>$c=[c_0,\cdots,\ c_p]$</span> is the coefficient vector, with</p><p class="math-container">\[    c_0=0,\ c_j=\frac{1}{p}{\binom {p}{p-j}}B_{p-j},\]</p><p>with <span>$j∈\{ 1,\cdots,\ p\}$</span>. The <span>$B_0,\cdots,\ B_{p-1}$</span> are Bernoulli numbers (but with <span>$B_1=+\frac{1}{2}$</span> rather than <span>$-\frac{1}{2}$</span>).</p><p><strong>Example:</strong></p><pre><code class="language-none">faulhaber_polynom(6)
7-element Vector{Rational{Int64}}:
  0//1
  0//1
 -1//12
  0//1
  5//12
  1//2
  1//6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL71-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.faulhaber_summation-Tuple{Int64, Int64}" href="#CamiXon.faulhaber_summation-Tuple{Int64, Int64}"><code>CamiXon.faulhaber_summation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">faulhaber_summation(n, p [, T=Int])</code></pre><p>Sum of powers of natural numbers <span>$1,\ \cdots,\ n$</span>,</p><p class="math-container">\[    FS(n,p)=\sum_{k=1}^{n}k^{p}=F(n,p+1).\]</p><p>where <span>$F(n,p)$</span> is the Faulhamer polynomial of degree <span>$p$</span>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">faulhaber_summation(5,1)
 15

faulhaber_summation(3,60; T=BigInt)
  42391158276369125018901280178</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL130-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.harmonic_number-Tuple{Int64, Int64}" href="#CamiXon.harmonic_number-Tuple{Int64, Int64}"><code>CamiXon.harmonic_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">harmonic_number(n, p [, T=Int])</code></pre><p>Sum of the <span>$p_{th}$</span> power of reciprocals of the first <span>$n$</span> numbers</p><p class="math-container">\[    H_{n,p}=\sum_{k=1}^{n}\frac{1}{k^p}.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">harmonic_number(12, 3)
 25535765062457//21300003648000

harmonic_number(12, 5; T=BigInt)
 16971114472329088045481//16366888723117363200000

harmonic_number(12, -3) == faulhaber_summation(12, 3)
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL234-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.harmonic_number-Tuple{Int64}" href="#CamiXon.harmonic_number-Tuple{Int64}"><code>CamiXon.harmonic_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">harmonic_number(n [, T=Int])</code></pre><p>Sum of the reciprocals of the first <span>$n$</span> natural numbers</p><p class="math-container">\[    H_n=\sum_{k=1}^{n}\frac{1}{k}.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">o = [harmonic_number(i) for i=1:10]; println(o)
 [1//1, 3//2, 11//6, 25//12, 137//60, 49//20, 363//140, 761//280, 7129//2520, 7381//2520]

harmonic_number(60; T=BigInt)
 15117092380124150817026911//3230237388259077233637600

harmonic_number(12) == harmonic_number(12, 1)
 true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL186-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.integer_partitions" href="#CamiXon.integer_partitions"><code>CamiXon.integer_partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">integer_partitions(n [,m]; transpose=false, count=false)</code></pre><p>default              : The integer partitions of n</p><p>count=true           : The number of integer partitions of n</p><p>transpose=false/true : for m&gt;0 restricted to partitions with maximum part/length m</p><p>definitions:</p><p>The integer partition of the positive integer n is a nonincreasing sequence of positive integers p1, p2,... pk whose sum is n.</p><p>The elements of the sequence are called the parts of the partition.</p><p><strong>Examples:</strong></p><pre><code class="language-none">integer_partitions(7)
15-element Array{Array{Int64,1},1}:
 [1, 1, 1, 1, 1, 1, 1]
 [2, 2, 2, 1]
 [3, 3, 1]
 [4, 3]
 [5, 2]
 [6, 1]
 [7]
 [2, 2, 1, 1, 1]
 [3, 2, 2]
 [4, 2, 1]
 [5, 1, 1]
 [2, 1, 1, 1, 1, 1]
 [3, 2, 1, 1]
 [4, 1, 1, 1]
 [3, 1, 1, 1, 1]

integer_partitions(7; count=true)
15

integer_partitions(7,4; count=true)
3

integer_partitions(7,4)
3-element Array{Array{Int64,1},1}:
 [4, 3]
 [4, 2, 1]
 [4, 1, 1, 1]

integer_partitions(7,4; transpose=true)
3-element Array{Array{Int64,1},1}:
 [2, 2, 2, 1]
 [3, 2, 1, 1]
 [4, 1, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL413-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.log10_characteristic_power-Tuple{Any}" href="#CamiXon.log10_characteristic_power-Tuple{Any}"><code>CamiXon.log10_characteristic_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log10_characteristic_power(x)</code></pre><p>characteristic power-of-10 of the number x</p><p><strong>Examples:</strong></p><pre><code class="language-none">log10_characteristic_power.([3,30,300])
3-element Vector{Int64}:
 0
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL501-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.log10_mantissa-Tuple{Any}" href="#CamiXon.log10_mantissa-Tuple{Any}"><code>CamiXon.log10_mantissa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log10_mantissa(x)</code></pre><p>log10 mantissa of the number x</p><p><strong>Examples:</strong></p><pre><code class="language-none">log10_mantissa.([3,30,300])
3-element Vector{Float64}:
 0.47712125471966244
 0.4771212547196624
 0.4771212547196626</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL517-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.permutations_unique_count-Tuple{Vector{Vector{Int64}}, Int64}" href="#CamiXon.permutations_unique_count-Tuple{Vector{Vector{Int64}}, Int64}"><code>CamiXon.permutations_unique_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permutations_unique_count(p::Array{Array{Int64,1},1}, i::Int)</code></pre><p>Number of unique permutations of the subarray <span>$p[i]$</span>.</p><p><strong>Example:</strong></p><pre><code class="language-none">p = [[1,2,3],[2,3,1,4,3]]
permutations_unique_count(p,2)
 60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL612-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.pascal_triangle-Tuple{Int64}" href="#CamiXon.pascal_triangle-Tuple{Int64}"><code>CamiXon.pascal_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pascal_triangle(nmax [, T=Int])</code></pre><p>Pascal triangle of binomial coefficients <span>$\binom{n}{k}$</span> for <span>$n=0,\ 1,\ \cdots,\ nmax$</span></p><p><strong>Example:</strong></p><pre><code class="language-none">pascal_triangle(5)
6-element Vector{Vector{Int64}}:
 [1]
 [1, 1]
 [1, 2, 1]
 [1, 3, 3, 1]
 [1, 4, 6, 4, 1]
 [1, 5, 10, 10, 5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL534-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.pascal_next-Tuple{Vector{Int64}}" href="#CamiXon.pascal_next-Tuple{Vector{Int64}}"><code>CamiXon.pascal_next</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pascal_next(nmax)</code></pre><p>Next row of Pascal triangle</p><p><strong>Example:</strong></p><pre><code class="language-none">a = [1, 4, 6, 4, 1]
pascal_next(a)
 [1, 5, 10, 10, 5, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL585-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynomial-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Number" href="#CamiXon.polynomial-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Number"><code>CamiXon.polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynomial(coords::Vector{T}, x::T[; deriv=0]) where T&lt;:Number</code></pre><p>Method to evaluate the function <span>$f(x)=\text{polynomial}(c,x)$</span>, where <span>$c=[c_0,\ \ldots,\ c_d]$</span> is the vector representation of a polynomial of degree <span>$d$</span>.</p><p class="math-container">\[    \text{polynomial}(c,x)=c_0 + c_1 x + \cdots + c_d x^d.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords = ones(Int,6)                     # for polynomial of degree 5 with unit coefficients
f0(x) = polynomial(coords,x)             # default
fd(x) = polynomial(coords,x; deriv=1)    # first derivative
fp(x) = polynomial(coords,x; deriv=-1)   # primitive (with zero integration constant)
f0(1)
 6

fd(1)
 15

fp(1)
 49//20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL638-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_derivative-Tuple{Vector{&lt;:Number}}" href="#CamiXon.polynom_derivative-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_derivative(coords)</code></pre><p>Vector representation of the first derivative of the polynomial <code>coords</code>,</p><p class="math-container">\[    p&#39;(c,x)=c_1 + 2 c_2 x + \cdots + d c_d x^{d-1},\]</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,\ \ldots,\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]                 # vector representation of polynomial of degree d=4
polynom_derivative(coords)         # (first) derivative of polynomial `coords`
4-element Vector{Int64}:
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL679-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_derivatives-Tuple{Vector{&lt;:Number}}" href="#CamiXon.polynom_derivatives-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivatives</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_derivatives(coords::Vector{&lt;:Number}[;deriv=0])</code></pre><p>Vector representation of derivatives of the polynomial <code>coords</code>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,\ \ldots,\ c_d]$</span> consisting of the polynomial coefficients.</p><p><code>deriv</code>: derivative of choice; <code>default</code>: <code>coords</code> remains unchanged.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]               # vector representation of a polynomial of degree d=4
polynom_derivatives(coords)      # default no (zero) derivative of polynomial `coords`
5-element Vector{Vector{Int64}}:
 1
 1
 1
 1
 1

polynom_derivatives(coords; deriv=2)        # second derivative of polynomial `coords`
3-element Vector{Int64}:
  2
  6
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL711-L739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_derivatives_all-Tuple{Vector{&lt;:Number}}" href="#CamiXon.polynom_derivatives_all-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivatives_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_derivatives_all(coords::Vector{&lt;:Number})</code></pre><p>Vector representation of all nontrivial derivatives of the polynomial <code>coords</code>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,\ \ldots,\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]               # vector representation of a polynomial of degree d=4
polynom_derivatives_all(coords)      # `all&#39; (nontrivial) derivatives of polynomial `coords`
5-element Vector{Vector{Int64}}:
 [1, 2, 3, 4]
 [2, 6, 12]
 [6, 24]
 [24]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL754-L773">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_power-Tuple{Vector{&lt;:Number}, Int64}" href="#CamiXon.polynom_power-Tuple{Vector{&lt;:Number}, Int64}"><code>CamiXon.polynom_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_power(coords, p)</code></pre><p>Vector representation of the polynomial <code>coords</code> raised to the power <code>p</code> which results in a polynomial in a vector space of dimension <span>$p d + 1$</span>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,\ \ldots,\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1]             # vector representation of polynomial of degree ``d=2``
polynom_power(coords,2)
5-element Vector{Int64}:
 1
 2
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL792-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_powers-Tuple{Vector{&lt;:Number}, Int64}" href="#CamiXon.polynom_powers-Tuple{Vector{&lt;:Number}, Int64}"><code>CamiXon.polynom_powers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_powers(coords, pmax)</code></pre><p>The polynomial <code>coords</code> raised to the powers 1,...,pmax  which results in a collection of polynomials in vector spaces of dimension <span>$d+1$</span> tot <span>$p d + 1$</span>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,\ \ldots,\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1]                   # vector representation of polynomial of degree d=2
polynom_powers(coords,3)
3-element Vector{Vector{Int64}}:
 [1, 1, 1]
 [1, 2, 3, 2, 1]
 [1, 3, 6, 7, 6, 3, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL832-L850">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_primitive-Tuple{Vector{&lt;:Number}}" href="#CamiXon.polynom_primitive-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_primitive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_primitive(coords)</code></pre><p>Vector representation of the primitive of the polynomial <code>coords</code> which is a polynomial in a vector space of dimension <span>$p d + 1$</span>.</p><p class="math-container">\[    P(c,x)=c_{int} +c_0 x + \frac{1}{2} c_1 x^2 + \frac{1}{3} c_2 x^3 + \cdots + \frac{1}{d+1} c_d x^{d+1},\]</p><p>The constant of integration is set to zero, <span>$c_{int} = 0$</span>.</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span>. The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,\ \ldots,\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong>Examples:</strong></p><pre><code class="language-none">coords=[1,1,1,1,1]         # vector representation of polynomial of degree ``d=4``
polynom_primitive(coords)
6-element Vector{Rational{Int64}}:
 0//1
 1//1
 1//2
 1//3
 1//4
 1//5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL867-L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_product-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number" href="#CamiXon.polynom_product-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>CamiXon.polynom_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_product(a::Vector{T}, b::Vector{V}) where {T&lt;:Number, V&lt;:Number}</code></pre><p>Vector representation of the product of two polynomials, <span>$a$</span> and <span>$b$</span> which is a polynomial in a vector space of dimension <span>$d=m+n$</span>,</p><p class="math-container">\[    p(c,x)=a_0b_0 + (a_0b_1 + b_0a_1)x + \cdots + a_n b_m x^{n+m}.\]</p><p>Polynomials of degree <span>$d$</span> are represented by a vector in a vector space of dimension <span>$d+1$</span> The polynomial <code>coords</code> is specified by the coordinates vector <span>$c=[c_0,\ \ldots,\ c_d]$</span> consisting of the polynomial coefficients.</p><p><strong></strong></p><pre><code class="language-none">[polynom_product1([1.0,1],[1,-1,2])]
 [1.0, 0.0, 1.0, 2.0]

[polynom_product1([1//1,1],[1,-1,2])]
 [1//1, 0//1, 1//1, 2//1]

[polynom_product([1,1],[1,- 1,2])]
 [1, 0, 1, 2]

[polynom_product([1,- 1,2],[1,1])]
 [1, 0, 1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL905-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.polynom_product_expansion-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:Number" href="#CamiXon.polynom_product_expansion-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:Number"><code>CamiXon.polynom_product_expansion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polynom_product_expansion(a::Vector{T}, b::Vector{T}, p::Int) where T&lt;:Number</code></pre><p>Vector representation of the product of two polynomials, <span>$a$</span> (of degree <span>$n$</span>) and <span>$b$</span> (of degree <span>$m$</span>), with <span>$m≤n$</span> truncated at the order <span>$p$</span> is a polynomial in a vector space of dimension <span>$d=p+1$</span>. If <span>$ab$</span> is the <code>polynom_product</code>, the <code>polynom_product_expansion</code> is <span>$ab[1:p+1]$</span></p><p><strong></strong></p><pre><code class="language-none">a = [1,-1,1]
b = [1,1,-1,1,1,1]
o = polynom_product(a, b); println(o)
 [1, 0, -1, 3, -1, 1, 0, 1]

o = expand_product(a, b, 4); println(o)
 [1, 0, -1, 3, -1]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL954-L971">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.texp-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Real" href="#CamiXon.texp-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Real"><code>CamiXon.texp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">texp(x::T, a::T, p::Int) where T &lt;: Real</code></pre><p>Taylor expansion of exp(x) about <span>$x = a$</span> up to order p.</p><p class="math-container">\[    \mathsf{texp}(x,a,p) = 1 + (x-a) + \frac{1}{2}(x-a)^2 + \cdots + \frac{1}{p!}(x-a)^p.\]</p><p><strong>Examples:</strong></p><pre><code class="language-none">p = 5
texp(1.0, 0.0, 5)
 2.7166666666666663

texp(1, 0, 5)
 163//60</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL1029-L1045">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.VectorRational" href="#CamiXon.VectorRational"><code>CamiXon.VectorRational</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorRational</code></pre><p>Object to decompose a vector of rational numbers</p><p>The fields are:</p><ul><li><code>.num::Vector{Int}</code>`: vector of normalized numerators</li><li><code>.den::Int</code>: common denominator</li><li><code>.val::Vector{Rational}</code>: vector of rational numbers (simplified = not normalized)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL1058-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CamiXon.normalize_VectorRational-Tuple{Vector{Rational{Int64}}}" href="#CamiXon.normalize_VectorRational-Tuple{Vector{Rational{Int64}}}"><code>CamiXon.normalize_VectorRational</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize_VectorRational(vec::Vector{Rational{Int}})</code></pre><p>Decompose vector of rational numbers.</p><p><strong>Example:</strong></p><pre><code class="language-none">v = [2//3,4//5]
normalize_VectorRational(v)
 VectorRational([10, 12], 15, Rational{Int64}[2//3, 4//5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiXon.jl/blob/b03931558b83c9f9ece1c2813b392112d45d2b75/src/mathematics.jl#LL1078-L1088">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CamiXon.Atom"><code>CamiXon.Atom</code></a></li><li><a href="#CamiXon.Codata"><code>CamiXon.Codata</code></a></li><li><a href="#CamiXon.Def"><code>CamiXon.Def</code></a></li><li><a href="#CamiXon.FITS_HDU"><code>CamiXon.FITS_HDU</code></a></li><li><a href="#CamiXon.FITS_data"><code>CamiXon.FITS_data</code></a></li><li><a href="#CamiXon.FITS_header"><code>CamiXon.FITS_header</code></a></li><li><a href="#CamiXon.FITS_name"><code>CamiXon.FITS_name</code></a></li><li><a href="#CamiXon.FITS_table"><code>CamiXon.FITS_table</code></a></li><li><a href="#CamiXon.FORTRAN_format"><code>CamiXon.FORTRAN_format</code></a></li><li><a href="#CamiXon.Grid"><code>CamiXon.Grid</code></a></li><li><a href="#CamiXon.NamedValue"><code>CamiXon.NamedValue</code></a></li><li><a href="#CamiXon.Orbit"><code>CamiXon.Orbit</code></a></li><li><a href="#CamiXon.Pos"><code>CamiXon.Pos</code></a></li><li><a href="#CamiXon.SpinOrbit"><code>CamiXon.SpinOrbit</code></a></li><li><a href="#CamiXon.Term"><code>CamiXon.Term</code></a></li><li><a href="#CamiXon.Value"><code>CamiXon.Value</code></a></li><li><a href="#CamiXon.VectorRational"><code>CamiXon.VectorRational</code></a></li><li><a href="#CamiXon.autoNtot-Tuple{Orbit}"><code>CamiXon.autoNtot</code></a></li><li><a href="#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real"><code>CamiXon.autoPrecision</code></a></li><li><a href="#CamiXon.autoRmax-Tuple{Atom, Orbit}"><code>CamiXon.autoRmax</code></a></li><li><a href="#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.autoSteps</code></a></li><li><a href="#CamiXon.bernoulli_numbers-Tuple{Int64}"><code>CamiXon.bernoulli_numbers</code></a></li><li><a href="#CamiXon.bohrformula-Tuple{Int64, Int64}"><code>CamiXon.bohrformula</code></a></li><li><a href="#CamiXon.calibrationReport-Tuple{Any, Any, Codata}"><code>CamiXon.calibrationReport</code></a></li><li><a href="#CamiXon.canonical_partitions"><code>CamiXon.canonical_partitions</code></a></li><li><a href="#CamiXon.castAtom-Tuple{}"><code>CamiXon.castAtom</code></a></li><li><a href="#CamiXon.castCodata-Tuple{Int64}"><code>CamiXon.castCodata</code></a></li><li><a href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit}} where T&lt;:Real"><code>CamiXon.castDef</code></a></li><li><a href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>CamiXon.castGrid</code></a></li><li><a href="#CamiXon.castNamedValue-Tuple{Value}"><code>CamiXon.castNamedValue</code></a></li><li><a href="#CamiXon.castOrbit-Tuple{}"><code>CamiXon.castOrbit</code></a></li><li><a href="#CamiXon.cast_FITS_name-Tuple{String}"><code>CamiXon.cast_FITS_name</code></a></li><li><a href="#CamiXon.cast_FORTRAN_datatype-Tuple{String}"><code>CamiXon.cast_FORTRAN_datatype</code></a></li><li><a href="#CamiXon.cast_FORTRAN_format-Tuple{String}"><code>CamiXon.cast_FORTRAN_format</code></a></li><li><a href="#CamiXon.convertUnit-Tuple{Any, Codata}"><code>CamiXon.convertUnit</code></a></li><li><a href="#CamiXon.createSpinOrbit-Tuple{Orbit}"><code>CamiXon.createSpinOrbit</code></a></li><li><a href="#CamiXon.createTerm-Tuple{Int64}"><code>CamiXon.createTerm</code></a></li><li><a href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>CamiXon.create_adams_moulton_weights</code></a></li><li><a href="#CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiXon.create_lagrange_differentiation_matrix</code></a></li><li><a href="#CamiXon.create_lagrange_differentiation_weights-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.create_lagrange_differentiation_weights</code></a></li><li><a href="#CamiXon.edges"><code>CamiXon.edges</code></a></li><li><a href="#CamiXon.f_diff_expansion_coeffs_adams_bashford-Tuple{Int64}"><code>CamiXon.f_diff_expansion_coeffs_adams_bashford</code></a></li><li><a href="#CamiXon.f_diff_expansion_coeffs_adams_moulton-Tuple{Int64}"><code>CamiXon.f_diff_expansion_coeffs_adams_moulton</code></a></li><li><a href="#CamiXon.f_diff_expansion_coeffs_differentiation-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.f_diff_expansion_coeffs_differentiation</code></a></li><li><a href="#CamiXon.f_diff_expansion_coeffs_lagrange-Union{Tuple{T}, Tuple{Int64, T}} where T&lt;:Real"><code>CamiXon.f_diff_expansion_coeffs_lagrange</code></a></li><li><a href="#CamiXon.f_diff_expansion_weights-Tuple{Any, Any}"><code>CamiXon.f_diff_expansion_weights</code></a></li><li><a href="#CamiXon.f_diff_function_sequences"><code>CamiXon.f_diff_function_sequences</code></a></li><li><a href="#CamiXon.f_diff_weight-Tuple{Int64, Int64}"><code>CamiXon.f_diff_weight</code></a></li><li><a href="#CamiXon.f_diff_weights-Tuple{Int64}"><code>CamiXon.f_diff_weights</code></a></li><li><a href="#CamiXon.f_diff_weights_array-Tuple{Int64}"><code>CamiXon.f_diff_weights_array</code></a></li><li><a href="#CamiXon.faulhaber_polynom-Tuple{Int64}"><code>CamiXon.faulhaber_polynom</code></a></li><li><a href="#CamiXon.faulhaber_summation-Tuple{Int64, Int64}"><code>CamiXon.faulhaber_summation</code></a></li><li><a href="#CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_all</code></a></li><li><a href="#CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_first</code></a></li><li><a href="#CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_last</code></a></li><li><a href="#CamiXon.fits_add_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_add_key</code></a></li><li><a href="#CamiXon.fits_combine-Tuple{String, String}"><code>CamiXon.fits_combine</code></a></li><li><a href="#CamiXon.fits_copy"><code>CamiXon.fits_copy</code></a></li><li><a href="#CamiXon.fits_create"><code>CamiXon.fits_create</code></a></li><li><a href="#CamiXon.fits_delete_key-Tuple{String, Int64, String}"><code>CamiXon.fits_delete_key</code></a></li><li><a href="#CamiXon.fits_edit_key-Tuple{String, Int64, String, Real, String}"><code>CamiXon.fits_edit_key</code></a></li><li><a href="#CamiXon.fits_extend"><code>CamiXon.fits_extend</code></a></li><li><a href="#CamiXon.fits_info-Tuple{FITS_HDU}"><code>CamiXon.fits_info</code></a></li><li><a href="#CamiXon.fits_read-Tuple{String}"><code>CamiXon.fits_read</code></a></li><li><a href="#CamiXon.fits_rename_key-Tuple{String, Int64, String, String}"><code>CamiXon.fits_rename_key</code></a></li><li><a href="#CamiXon.frac-Tuple{Rational{Int64}}"><code>CamiXon.frac</code></a></li><li><a href="#CamiXon.grid_trapezoidal_integral-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_trapezoidal_integral</code></a></li><li><a href="#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.gridfunction</code></a></li><li><a href="#CamiXon.harmonic_number-Tuple{Int64}"><code>CamiXon.harmonic_number</code></a></li><li><a href="#CamiXon.harmonic_number-Tuple{Int64, Int64}"><code>CamiXon.harmonic_number</code></a></li><li><a href="#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.initE</code></a></li><li><a href="#CamiXon.integer_partitions"><code>CamiXon.integer_partitions</code></a></li><li><a href="#CamiXon.lagrange_differentiation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_differentiation</code></a></li><li><a href="#CamiXon.lagrange_extrapolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_extrapolation</code></a></li><li><a href="#CamiXon.lagrange_interpolation-Tuple{Vector{Float64}, IntervalSets.ClosedInterval{Float64}}"><code>CamiXon.lagrange_interpolation</code></a></li><li><a href="#CamiXon.listCodata-Tuple{Codata}"><code>CamiXon.listCodata</code></a></li><li><a href="#CamiXon.log10_characteristic_power-Tuple{Any}"><code>CamiXon.log10_characteristic_power</code></a></li><li><a href="#CamiXon.log10_mantissa-Tuple{Any}"><code>CamiXon.log10_mantissa</code></a></li><li><a href="#CamiXon.mendeleev-Tuple{Int64}"><code>CamiXon.mendeleev</code></a></li><li><a href="#CamiXon.myconvert-Union{Tuple{V}, Tuple{Type, V}} where V&lt;:Number"><code>CamiXon.myconvert</code></a></li><li><a href="#CamiXon.normalize_VectorRational-Tuple{Vector{Rational{Int64}}}"><code>CamiXon.normalize_VectorRational</code></a></li><li><a href="#CamiXon.parse_FITS_TABLE-Tuple{FITS_HDU}"><code>CamiXon.parse_FITS_TABLE</code></a></li><li><a href="#CamiXon.pascal_next-Tuple{Vector{Int64}}"><code>CamiXon.pascal_next</code></a></li><li><a href="#CamiXon.pascal_triangle-Tuple{Int64}"><code>CamiXon.pascal_triangle</code></a></li><li><a href="#CamiXon.permutations_unique_count-Tuple{Vector{Vector{Int64}}, Int64}"><code>CamiXon.permutations_unique_count</code></a></li><li><a href="#CamiXon.polynom_derivative-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivative</code></a></li><li><a href="#CamiXon.polynom_derivatives-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivatives</code></a></li><li><a href="#CamiXon.polynom_derivatives_all-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_derivatives_all</code></a></li><li><a href="#CamiXon.polynom_power-Tuple{Vector{&lt;:Number}, Int64}"><code>CamiXon.polynom_power</code></a></li><li><a href="#CamiXon.polynom_powers-Tuple{Vector{&lt;:Number}, Int64}"><code>CamiXon.polynom_powers</code></a></li><li><a href="#CamiXon.polynom_primitive-Tuple{Vector{&lt;:Number}}"><code>CamiXon.polynom_primitive</code></a></li><li><a href="#CamiXon.polynom_product-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T&lt;:Number"><code>CamiXon.polynom_product</code></a></li><li><a href="#CamiXon.polynom_product_expansion-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:Number"><code>CamiXon.polynom_product_expansion</code></a></li><li><a href="#CamiXon.polynomial-Union{Tuple{T}, Tuple{Vector{T}, T}} where T&lt;:Number"><code>CamiXon.polynomial</code></a></li><li><a href="#CamiXon.select125-Tuple{Any}"><code>CamiXon.select125</code></a></li><li><a href="#CamiXon.step125-Tuple{Real}"><code>CamiXon.step125</code></a></li><li><a href="#CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepcenters</code></a></li><li><a href="#CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepedges</code></a></li><li><a href="#CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.steps</code></a></li><li><a href="#CamiXon.strValue-Tuple{Value}"><code>CamiXon.strValue</code></a></li><li><a href="#CamiXon.sub-Tuple{T} where T&lt;:Real"><code>CamiXon.sub</code></a></li><li><a href="#CamiXon.summation_range-NTuple{4, Int64}"><code>CamiXon.summation_range</code></a></li><li><a href="#CamiXon.sup-Tuple{T} where T&lt;:Real"><code>CamiXon.sup</code></a></li><li><a href="#CamiXon.texp-Union{Tuple{T}, Tuple{T, T, Int64}} where T&lt;:Real"><code>CamiXon.texp</code></a></li><li><a href="#CamiXon.trapezoidal_integration-Tuple{Any, Any, Any}"><code>CamiXon.trapezoidal_integration</code></a></li><li><a href="#CamiXon.trapezoidal_weights-Tuple{Int64}"><code>CamiXon.trapezoidal_weights</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 8 April 2022 13:51">Friday 8 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
