var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CamiXon","category":"page"},{"location":"#CamiXon.jl","page":"Home","title":"CamiXon.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for image analysis of backscattered light","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CamiXon is a package for the numerical solution of the radial Schrödinger equation allowing for screening.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package the solution is obtained for a single electron, acting as a spectator in the central field of the atomic nucleus screened by 'the other' electrons (the screening electrons).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The starting point is the 1D Schrödinger equation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"tildeχ_l^+2Z_mathrmeff(ρ)ρ-l(l+1)2ρ^2+ε_ltildeχ_l=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"where tildechi_l(rho)=rhotildeR_l(rho) is the reduced radial wavefunction and ε_l=-κ _l^2 is the corresponding binding energy in Hartree atomic units (a.u.). As compared to the hydrogenic case, the atomic number Z has been replaced by Z_mathrmeff(ρ), the effective nuclear charge at radial distance ρ from the atomic center (in a.u.). In other words, the energy of the electron in the Coulomb field of the nucleus is replaced by an effective, central field potential of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"U_mathrmCF(ρ)=-Z_mathrmeff(ρ)ρ=-Zρ+U_mathrmscr(ρ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"consisting of the bare Coulomb contribution, -Zρ, and the screening field U_mathrmscr(ρ), subject to the boundary conditions U_mathrmscr(0)=Z and mathrmlim_ρinftyU_mathrmscr(ρ)=Z_cρ. Here Z_c is the Rydberg charge; i.e. the effective nuclear charge for a spectator electron in the far field (ρinfty). Within these assumptions we can optimize U_mathrmscr(ρ), while preserving the bare Coulomb field close to the nucleus as well as the Rydberg potential in the far field. The price we pay is that the radial Schrödinger equation has to be solved numerically by radial integration. Our strategy is to use both inward and outward integration and match the two branches by equating the two solutions for the wavefunction, χ(ρ), and its derivative, χ^(ρ), at a point near the classical turning point of the radial motion of the electron. The basics of the solution can be found in the book Atomic Structure Theory by Walter R. Johnson.","category":"page"},{"location":"#Illustration:-the-hydrogen-3d-orbital","page":"Home","title":"Illustration: the hydrogen 3d orbital","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Shown below are the reduced radial wavefunction (χ) and its derivative (χ^) in the near field (left), the far field (right), and in the region near the classical turning point (center). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Image)","category":"page"},{"location":"#Codata","page":"Home","title":"Codata","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Codata\nValue\nstrValue(f::Value)\nNamedValue\ncastNamedValue(val::Value; name=\" \", comment=\" \")\ncastCodata(year::Int)\nlistCodata(codata::Codata)\nconvertUnit(val, codata; unitIn=\"Hartree\", unitOut=\"xHz\")\ncalibrationReport(E, Ecal, codata::Codata; unitIn=\"Hartree\")","category":"page"},{"location":"#CamiXon.Codata","page":"Home","title":"CamiXon.Codata","text":"Codata\n\nObject to hold the natural constants from CODATA. It is best created with the function castCodata\n\nThe fields are:\n\n.∆νCs: Cs hyperfine transition frequency (::Value)\n.c: speed of light in vacuum (::Value)\n.h: Planck constant (::Value)\n.ħ: Planck constant - reduced (::Value)\n.e: elementary charge (::Value)\n.kB: Boltzmann constant (::Value)\n.NA: Avogadro constant (::Value)\n.Kcd: Luminous efficacy (::Value)\n.me: electron rest mass (::Value)\n.R∞: Rydberg constant (::Value)\n.Ry: Rydberg frequency (::Value)\n.Eh: Hartree a.u. (::Value)\n.α: fine-structure constant (::Value)\n.μ0: magnetic permitivity of vacuum (::Value)\n.ε0: electric permitivity of vacuum (::Value)\n.KJ: Josephson constant (::Value)\n.RK: Von Klitzing constant (::Value)\n.R: Molar gas constant (::Value)\n.matE: unit conversion matrix (Matrix{Float64})\n\nExample:\n\ncodata = castCodata(2018)\ncodata.μ0\n  Value(1.2566370621250601e-6, \"N A⁻²\")\n\ncodata.μ0.val\n  1.2566370621250601e-6\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Value","page":"Home","title":"CamiXon.Value","text":"Value(val::Real, unit::String)\n\nObject to hold a real numerical value together with a unit specifier.\n\nThe fields are:\n\n.val: numerical value (::Real)\n.unit: unit specifier (::String)\n\nExample:\n\nf = Value(1,\"Hz\")\n  Value(1, \"Hz\")\n\nf.val\n  1\n\nf.unit\n  \"Hz\"\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.strValue-Tuple{Value}","page":"Home","title":"CamiXon.strValue","text":"strValue(f::Value)\n\nString expression for a Value object in :compact => true representation\n\nExample:\n\nf = Value(1,\"Hz\")\nstrValue(f)\n  \"1 Hz\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.NamedValue","page":"Home","title":"CamiXon.NamedValue","text":"NamedValue(val::Value, name::String, comment::String)\n\nObject to hold a Value together with its symbolic name and a short description\n\nThe fields are:\n\n.val: Value  (::Value)\n.name: symbolic name (::String)\n.comment: description (::String)\n\nNamed Value object The object NamedValue is best created using castNamedValue.\n\nExample:\n\nf = Value(1,\"Hz\")\n  Value(1, \"Hz\", \"frequency\")\n\nf.name\n  \"frequency\"\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.castNamedValue-Tuple{Value}","page":"Home","title":"CamiXon.castNamedValue","text":"castNamedValue(val::Value; name=\" \", comment=\" \")\n\nMethod to create a NamedValue object\n\nExample\n\nv = Value(1.602176634e-19, \"C\")\nnv = castNamedValue(v; name=\"e\")\nnv.name * \" = \" * strValue2(nv.val)\n  \"e = 1.60218e-19 C\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castCodata-Tuple{Int64}","page":"Home","title":"CamiXon.castCodata","text":"castCodata(year::Int)\n\nMethod to create the Codata object\n\nExample:\n\ncodata = castCodata(2018)\nstrValue.([codata.∆νCs,codata.c,codata.h])\n 3-element Vector{String}:\n  \"9192631770 Hz\"\n  \"299792458 m s⁻¹\"\n  \"6.62607e-34 J Hz⁻¹\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listCodata-Tuple{Codata}","page":"Home","title":"CamiXon.listCodata","text":"listCodata(codata::Codata)\n\nMethod to list the fields of Codata by their symbolic name\n\nExample:\n\ncodata = castCodata(2018)\nlistCodata(codata::Codata)\n  ∆νCs = 9192631770 Hz\n  c = 299792458 m s⁻¹\n  h = 6.62607e-34 J Hz⁻¹\n  ħ = 1.05457e-34 J s\n  e = 1.60218e-19 C\n  kB = 1.38065e-23 J K⁻¹\n  NA = 6.02214e23 mol⁻¹\n  Kcd = 683 lm W⁻¹\n  mₑ = 9.10938e-31 Kg\n  R∞ = 1.09737e7 m⁻¹\n  Ry = 3.28984e15 Hz\n  Eₕ = 4.35974e-18 Hartree a.u.\n  α = 0.00729735\n  μ₀ = 1.25664e-6 N A⁻²\n  ε₀ = 8.85419e-12 F m⁻¹\n  KJ = 4.83598e14 Hz V⁻¹\n  RK = 25812.8 Ω\n  R = 8.31446 J mol⁻¹K⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.convertUnit-Tuple{Any, Any}","page":"Home","title":"CamiXon.convertUnit","text":"convertUnit(val, codata; unitIn=\"Hartree\", unitOut=\"xHz\")\n\nUnit conversion between μHz,⋯ EHz, Hartree, Rydberg, Joule, and eV\n\ndefault input: Hartree\n\ndefault output: xHz ∈ {μHz, mHz, Hz, kHz, MHz, GHz, THz, PHz, EHz}\n\nExample:\n\ncodata = castCodata(2018)\nconvertUnit(1, codata; unitIn=\"Hz\", unitOut=\"Joule\")\n  6.62607015e-34\n\nconvertUnit(1, codata; unitIn=\"Hartree\", unitOut=\"Hz\")\n  Value(6.57968392050182e15, \"Hz\")\n\nf = convertUnit(1, codata) # default input (Hartree) and output (xHz)\nstrf = strValue(f)\n  \"6.57968 PHz\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.calibrationReport-Tuple{Any, Any, Codata}","page":"Home","title":"CamiXon.calibrationReport","text":"calibrationReport(E, Ecal, codata::Codata; unitIn=\"Hartree\", msg=true)\n\nComparison of energy E with calibration value Ecal\n\ndefault input: Hartree\n\nExample:\n\ncodata = castCodata(2018)\ncalibrationReport(1.1, 1.0, codata; unitIn=\"Hartree\")\n  calibration report (Float64):\n  Ecal = 1.0 Hartree\n  E = 1.1 Hartree\n  absolute accuracy: ΔE = 0.1 Hartree (657.968 THz)\n  relative accuracy: ΔE/E = 0.0909091\n\n\n\n\n\n","category":"method"},{"location":"#Atomic-properties","page":"Home","title":"Atomic properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Element\nIsotope\nAtom\nOrbit\nSpinorbital\nTerm\nlistElement(Z::Int; fmt=Object)\nlistElements(Z1::Int, Z2::Int; fmt=Object)\ncastElement(;Z=1, msg=true)\nlistIsotope(Z::Int, A::Int; fmt=Object)\nlistIsotopes(Z1::Int, Z2::Int; fmt=Object)\nlatexIsotopeTable(Z1::Int, Z2::Int; continuation=false)\ncastIsotope(;Z=1, A=1, msg=true)\nlistAtom(Z::Int, A::Int, Q::Int; fmt=Object)\nlistAtoms(Z1::Int, Z2::Int, Q::Int; fmt=Object)\ncastAtom(;Z=1, A=1, Q=0, msg=true)\ncastOrbit(;n=1, ℓ=0, mℓ=0, msg=true)\ncastSpinorbital(o::Orbit; up=true, msg=true)\ncreateTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)","category":"page"},{"location":"#CamiXon.Element","page":"Home","title":"CamiXon.Element","text":"Element(name, symbol, weight)\n\nType with fields:\n\n.name:  name of element (::String)\n.symbol:  symbol of element  (::String)\n.weight:  relative atomic mass - atomic weight (::Float64)\n\nThe type Element is best created with the function castElement.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Isotope","page":"Home","title":"CamiXon.Isotope","text":"Isotope(symbol, name, Z, A, N, R, M, I, π, T½, mdm, eqm, ra)\n\nType with fields:\n\n.symbol: symbol (::String)\n.name: name (::String)\n.Z:  atomic number (::Int)\n.A:  atomic mass number in amu (::Int)\n.N:  neutron number (::Int)\n.R:  rms charge radius in Fermi (::Float64)\n.M:  atomic mass in amu (::Float64)\n.I:  nuclear spin in units of ħ  (::Rational{Int})\n.π:  parity of nuclear state (::Int)\n.T½:  lifetime in years (::Float64)\n.mdm: nuclear magnetic dipole moment (::Float64)\n.eqm: nuclear electric quadrupole moment (::Float64)\n.ra:  relative abundance in % (::Float64)\n\nThe type Isotope is best created with the function castIsotope.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Atom","page":"Home","title":"CamiXon.Atom","text":"Atom(Z, A, Q, Zc, element, isotope)\n\nType with fields:\n\n.Z:  atomic number (::Int)\n.A:  atomic mass number in amu (::Int)\n.Q:  ionic charge in a.u. (::Int)\n.Zc:  Rydberg charge in a.u. (::Int)\n.element:  (::Element)\n.isotope:  (::Isotope)\n\nThe type Atom is best created with the function castAtom.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Orbit","page":"Home","title":"CamiXon.Orbit","text":"Orbit(name, n, n′, ℓ, mℓ)\n\nType for specification of atomic orbitals with fields:\n\n.name: name\n.n:  principal quantum number\n.n′:  radial quantum number (number of nodes in radial wavefunction)\n.ℓ:  orbital angular momentum valence electron\n.mℓ:  orbital angular momentum projection valence electron\n\nThe type Orbit is best created with the function castOrbit.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Spinorbital","page":"Home","title":"CamiXon.Spinorbital","text":"Spinorbital\n\nType for specification of atomic Spinorbitals with fields:\n\n.name: name\n.n:  principal quantum number\n.n′:  radial quantum number (number of nodes in radial wavefunction)\n.ℓ:  orbital angular momentum valence electron\n.ms:  spin magnetic quantum number\n\nThe type Spinorbital is best created with the function castSpinorbital.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Term","page":"Home","title":"CamiXon.Term","text":"Term(name::String, n::Int, ℓ::Int, S::Real, L::Int, J::Real)\n\nType for specification of atomic fine-structure Terms with fields:\n\nname: name\n.n:  principal quantum number\n.n′:  radial quantum number (number of nodes in wavefunction)\n.ℓ:  orbital angular momentum valence electron\n.S:  total electron spin in units of ħ\n.L:  total orbital angular momentum in units of ħ\n.J:  total electronic angular momentum in units of ħ\n\nThe type Term is best created with the function createTerm.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.listElement-Tuple{Int64}","page":"Home","title":"CamiXon.listElement","text":"listElement(Z::Int[; fmt=Object])\nlistElement(elt::String[; fmt=Object])\n\nProperties of element with atomic number Z.\n\nOutput options: fmt =  Object (default), String, Info.\n\nExample:\n\nlistElement(\"H\") == listElement(1)\n  true\n\nlistElement(1; fmt=Info)\n  Element: hydrogen\n    symbol: H\n    atomic number: Z = 1\n    atomic weight (relative atomic mass): 1.008\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listElements-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.listElements","text":"listElements(Z1::Int, Z2::Int[; fmt=Object])\nlistElements(itrZ::UnitRange{Int}; fmt=Object)\n\nProperties of elements with atomic number in the range Z1:Z2.\n\nOutput options: fmt =  Object (default), String, Info.\n\nExample\n\nlistElements(1,3) == listElements(1:3)\n  true\n\nlistElements(1:3; fmt=Info)\n  Element: hydrogen\n    symbol: H\n    atomic number: Z = 1\n    atomic weight (relative atomic mass): 1.008\n  Element: helium\n    symbol: He\n    atomic number: Z = 2\n    atomic weight (relative atomic mass): 4.0026\n  Element: lithium\n    symbol: Li\n    atomic number: Z = 3\n    atomic weight (relative atomic mass): 6.94\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castElement-Tuple{}","page":"Home","title":"CamiXon.castElement","text":"castElement(;Z=1, msg=true)\ncastElement(elt::String; msg=true)\n\nCreate Atom with fields\n\n.name:  name of element\n.symbol:  symbol of element\n.weight:  relative atomic mass (atomic weight)\n\nExample:\n\ncastElement(\"Rb\"; msg=false) == castElement(Z=37, msg=false)\n  true\n\nelement = castElement(;Z=1, msg=true)\nelement\n  Element created: H, hydrogen, Z=1, weight=1.008\n\n  Element(\"hydrogen\", \"H\", 1.008)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listIsotope-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.listIsotope","text":"listIsotope(Z::Int, A::Int; fmt=Object)\n\nProperties of isotopes with atomic number Z and atomic mass number A.\n\nOutput options: fmt =  Object (default), String, Latex, Info.\n\nExample:\n\nlistIsotope(1,3; fmt=Info)\n  Isotope: tritium-3\n    symbol: ³T\n    element: tritium\n    atomic number: Z = 1\n    atomic mass number: A = 3\n    neutron number: N = 2\n    rms nuclear charge radius: R = 1.7591 fm\n    atomic mass: M = 3.016049281 amu\n    nuclear spin: I = 1/2 ħ\n    parity of nuclear state: π = even\n    nuclear magnetic dipole moment: μI = 2.97896246μN\n    nuclear electric quadrupole moment: Q = 0.0barn\n    relative abundance: RA = trace\n    lifetime: 12.33 years\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listIsotopes-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.listIsotopes","text":"listIsotopes(Z1::Int, Z2::Int; fmt=Object)\n\nAll isotopes with atomic number from Z1 to Z2.\n\nOutput options: Object (default), String, Latex, Info.\n\nExample:\n\nlistIsotopes(1,3) == listIsotopes(1:3)\n true\n\nlistIsotopes(1:1; fmt=Info)\n 3-element Vector{Any}:\n  Isotope(\"¹H\", \"hydrogen\", 1, 1, 0, 0.8783, 1.007825032, 1//2, 1, 1.0e100, 2.792847351, 0.0, 99.9855)\n  Isotope(\"²D\", \"deuterium\", 1, 2, 1, 2.1421, 2.014101778, 1, 1, 1.0e100, 0.857438231, 0.0028578, 0.0145)\n  Isotope(\"³T\", \"tritium\", 1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.latexIsotopeTable-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.latexIsotopeTable","text":"latexIsotopeTable(Z1::Int, Z2::Int; continuation=false)\nlatexIsotopeTable(itrZ::UnitRange; continuation=false)\n\nIsotope table for all isotopes with atomic number from Z1 to Z2.\n\nExample:\n\no = latexIsotopeTable(1:3);\nprintln(o)\n  \\setlength{\\tabcolsep}{3pt}\n  \\renewcommand{\\arraystretch}{1.2}\n  \\begin{table}[H]\n    \\centering\n    \\caption{\\label{table:Isotopes-a-1}Properties of selected atomic isotopes. The Table is based on three databases: (a) AME2020 (atomic mass evaluation); (b) IAEA-INDC(NDS)-794 (magnetic dipole moments); (c) IAEA-INDC(NDS)-833 (electric quadrupole moments).}\n    \\begin{tabular}{r|lr|rrrr|r|r|r|r}\n      \\multicolumn{12}{r}\\vspace{-18pt}\\\\\n      \\hline\n      \\hline\n      $Z$ & element & symbol & $A$ & $N$ & radius & atomic mass & $I\\,^\\pi$ & $\\mu_I $ & $Q$ & $RA$\\\\&  &  &  &  & (fm) & $(m_u)$ & $(\\hbar)\\ \\ $ & $(\\mu_N)$ & (barn) & (\\%)\\\\\\hline\n      1 & hydrogen & $^{1}$H & 1\\, & 0 & 0.8783 & 1.007825032 & 1/2$^+$ & 2.792847351 & 0.0 & 99.9855 \\\\\n        &  & $^{2}$H & 2\\, & 1 & 2.1421 & 2.014101778 & 1//1$^+$ & 0.857438231 & 0.0028578 & 0.0145 \\\\\n        &  & $^{3}$H & 3$*\\!\\!$ & 2 & 1.7591 & 3.016049281 & 1/2$^+$ & 2.97896246 & 0.0 & trace \\\\\n      \\hline\n      2 & helium & $^{3}$He & 3\\, & 1 & 1.9661 & 3.016029322 & 1/2$^+$ & -2.12762531 & 0.0 & 0.0002 \\\\\n        &  & $^{4}$He & 4\\, & 2 & 1.6755 & 4.002603254 & 0//1$^+$ & 0.0 & 0.0 & 99.9998\\% \\\\\n      \\hline\n      3 & lithium & $^{6}$Li & 6\\, & 3 & 2.589 & 6.015122887 & 1//1$^+$ & 0.822043 & -0.000806 & 4.85 \\\\\n        &  & $^{7}$Li & 7\\, & 4 & 2.444 & 7.016003434 & 3/2$^-$ & 3.256407 & -0.04 & 95.15 \\\\\n      \\hline\n      \\multicolumn{12}{l}{*radioactive }\\\\\n    \\end{tabular}\n  \\end{table}\n\nThe typeset result is shown in the figule below.\n\n(Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castIsotope-Tuple{}","page":"Home","title":"CamiXon.castIsotope","text":"castIsotope(;Z=1, A=1, msg=false)\ncastIsotope(elt::String; A=1, msg=false)\n\nCreate Isotope with fields\n\n.symbol: symbol (::String)\n.name: symbol (::String)\n.Z:  atomic number (::Int)\n.A:  atomic mass number in amu (::Int)\n.N:  neutron number (::Int)\n.R:  rms charge radius in Fermi (::Float64)\n.M:  atomic mass in amu (::Float64)\n.I:  nuclear spin in units of ħ (::Rational{Int})\n.π:  parity of nuclear state (::Int)\n.ra:  relative abundance in % (::Float64)\n.mdm: nuclear magnetic dipole moment (::Float64)\n.eqm: nuclear electric quadrupole moment (::Float64)\n.T½:  lifetime in years (::Float64)\n\nExamples:\n\ncastIsotope(\"Rb\"; A=87) == castIsotope(Z=37, A=87)\n  true\n\nisotope = castIsotope(Z=1, A=3)\n  Isotope(\"³T\", \"tritium\", 1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0, nothing)\n\nisotope.T½\n  12.33\n\ncastIsotope(Z=1, A=3, msg=true);\n  Isotope created: tritium-3\n      symbol: ³T\n      element: tritium\n      atomic number: Z = 1\n      atomic mass number: A = 3\n      neutron number: N = 2\n      rms nuclear charge radius: R = 1.7591 fm\n      atomic mass: M = 3.016049281 amu\n      nuclear spin: I = 1/2 ħ\n      parity of nuclear state: π = ⁺\n      nuclear magnetic dipole moment: μI = 2.97896246μN\n      nuclear electric quadrupole moment: Q = 0.0barn\n      relative abundance: RA = trace\n      lifetime: 12.33 years\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listAtom-Tuple{Int64, Int64, Int64}","page":"Home","title":"CamiXon.listAtom","text":"listAtom(Z::Int, A::Int, Q::Int[; fmt=Object])\n\nProperties of atom with atomic number Z, atomic mass number A, ionic charge Q.\n\nOutput options: fmt =  Object (default), String, Info.\n\nExample:\n\nlistAtom(\"H\", 3, 0) == listAtom(1, 3, 0)\n  true\n\nlistAtom(1, 3, 0; fmt=Info)\nElement: hydrogen\n    symbol: H\n    element: tritium\n    atomic number: Z = 1\n    atomic weight (relative atomic mass): 1.008\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listAtoms-Tuple{Int64, Int64, Int64}","page":"Home","title":"CamiXon.listAtoms","text":"listAtoms(Z1::Int, Z2::Int, Q::Int[; fmt=Object])\n\nProperties of atoms with atomic number in the range Z1:Z3 and ionic charge Q.\n\nOutput options: fmt =  Object (default), String, Info.\n\nExample\n\nlistAtoms(1,3,0) == listAtoms(1:3,0)\n  true\n\nlistAtoms(1:1, 0; fmt=Info);\n  Atom: hydrogen, neutral atom\n    symbol: ¹H\n    atomic charge: Z = 1\n    Rydberg charge: Zc = 1\n  Atom: deuterium, neutral atom\n    symbol: ²D\n    atomic charge: Z = 1\n    Rydberg charge: Zc = 1\n  Atom: tritium, neutral atom\n    symbol: ³T\n    atomic charge: Z = 1\n    Rydberg charge: Zc = 1\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castAtom-Tuple{}","page":"Home","title":"CamiXon.castAtom","text":"castAtom(;Z=1, A=1, Q=0, msg=false)\ncastAtom(elt::String; A=1, Q=0, msg=false)\n\nCreate Atom with fields:\n\n.Z:  atomic number (::Int)\n.A:  atomic mass number in amu (::Int)\n.Q:  ionic charge in a.u. (::Int)\n.Zc:  Rydberg charge in a.u. (::Int)\n.element:  (::Element)\n.isotope:  (::Isotope)\n\nExamples:\n\ncastAtom(\"Rb\"; A=87, Q=0) == castAtom(Z=37, A=87, Q=0)\n  true\n\ncastAtom(Z=1, A=3, Q=0)\n  Atom(1, 3, 0, 1, Element(\"hydrogen\", \"H\", 1.008), Isotope(\"³T\", \"tritium\",\n  1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing))\n\natom = castAtom(Z=1, A=3, Q=0, msg=true);\n  Element created: H, hydrogen, Z=1, weight=1.008\n  Isotope created: ³T, tritium, Z=1, A=3, N=2, R=1.7591, M=3.016049281, I=1/2⁺, μI=2.97896246, Q=0.0, RA=trace, (radioactive)\n  Atom created: tritium, neutral atom, ³T, Z=1, A=3, Q=0, Zc=1\n\natom\n  Atom(1, 3, 0, 1, Element(\"hydrogen\", \"H\", 1.008), Isotope(\"³T\", \"tritium\",\n  1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing))\n\natom.isotope.T½\n  12.33\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castOrbit-Tuple{}","page":"Home","title":"CamiXon.castOrbit","text":"castOrbit(;n=1, ℓ=0, mℓ=0, msg=true)\n\nCreate Orbit with fields:\n\n.name: name\n.n:  principal quantum number\n.n′:  radial quantum number (number of nodes in radial wavefunction)\n.ℓ:  orbital angular momentum valence electron\n.mℓ:  orbital angular momentum projection valence electron\n\nExamples:\n\ncastOrbit(n=1, ℓ=0)\n Orbit created: 1s (n = 1, n′ = 0, ℓ = 0)\n Orbit(\"1s\", 1, 0, 0)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castSpinorbital-Tuple{Orbit}","page":"Home","title":"CamiXon.castSpinorbital","text":"castSpinorbital(o::Orbit; up=true, msg=true)\n\nSpecify Spinorbital with fields:\n\n.name: name\n.n: principal quantum number\n.n′: radial quantum number (number of nodes in radial wavefunction)\n.ℓ: orbital angular momentum valence electron\n.ms: spin magnetic quantum number\n\nExamples:\n\ns1s = castOrbit(1,0)\ncastSpinorbital(s1s; up=true)\n  Spinorbital created: 1s↑ (n = 1, n′ = 0, ℓ = 0, ms = 1//2)\n  Spinorbital(\"1s↑\", 1, 0, 0, 1//2)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.createTerm-Tuple{Int64}","page":"Home","title":"CamiXon.createTerm","text":"createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)\n\nSpecify Term in the Term notatation with fields:\n\n.n: principal quantum number\n.n′: radial quantum number (number of nodes - autogenerated)\n.ℓ: orbital angular momentum valence electron\n.S: total electron spin\n.L: total orbital angular momentum\n.J: total electronic angular momentum\n\nExamples:\n\nterm_H1I = createTerm(1; ℓ=0, S=1//2, L=0, J=1//2)\n Term created: 1s ²S₁⸝₂, n = 1, n′ = 0, ℓ = 0, S = 1//2, L = 0, J = 1//2\n Term(\"1s ²S₁⸝₂\", 1, 0, 0, 1//2, 0, 1//2)\n\n\n\n\n\n","category":"method"},{"location":"#Hydrogen","page":"Home","title":"Hydrogen","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"bohrformula(Z::Int, n::Int)\nhydrogenic_reduced_wavefunction(Zval, orbit::Orbit, grid::Grid)\nreduce_wavefunction(Z::Vector{Complex{T}}, grid::Grid{V}) where {T<:Real, V<:Real}\nrestore_wavefunction(Z::Vector{Complex{T}}, grid::Grid{V}) where {T<:Real, V<:Real}\ndemo_hydrogen(; n=3, ℓ=2)","category":"page"},{"location":"#CamiXon.bohrformula-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.bohrformula","text":"bohrformula(Z::Int, n::Int)\n\nHydrogenic energy (in Hartree a.u.) for atom with atomic number Z and principal quantum number n.\n\n    E_n = - fracZ^22n^2\n\nExample:\n\nZ = 2\nn = 4\nbohrformula(Z,n)\n -0.125\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.hydrogenic_reduced_wavefunction-Tuple{Any, Orbit, Grid}","page":"Home","title":"CamiXon.hydrogenic_reduced_wavefunction","text":"hydrogenic_reduced_wavefunction(Zval, orbit::Orbit, grid::Grid)\n\nAnalytic expression for the hydrogenic wavefunction written in the format Z = tildeχ + i tildeχ^, where tildeχ_nℓ(ρ) is the reduced radial wavefunction and tildeχ^_nℓ(ρ) its derivative, with ρ the radial distance to the nucleus in a.u.. The expression is evaluated for a given Atom in a given Orbit on a given Grid. The argument Def completes the definition of the problem.\n\n    tildechi_nl(rho)\n    =mathcalN_nl^-12(2Zn)^l+32rho^l+1e^-Zρn\n    L_n-l-1^2l+1(2Zrhon)\n\nwhere L_n-l-1^2l+1(2Zrhon) is the generalized Laguerre polynomial CamiMath.generalized_laguerreL and\n\n    mathcalN_nl\n    = displaystyle intnolimits _0^inftyx^2l+2e^-x\n    leftL_n-l-1^2l+1(x)right^2dx\n    = frac2nGamma(n+l+1)Gamma(n-l)\n\nis the norm of the wavefunction.\n\nExample:\n\norbit = castOrbit(n=25, ℓ=10)\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, msg=true)\ndef = castDef(grid, atom, orbit, codata)\nZval = 1\nZ = hydrogenic_reduced_wavefunction(Zval, orbit, grid);\n    Orbital: 25n\n    principal quantum number: n = 25\n    radial quantum number: n′ = 14 (number of nodes in radial wavefunction)\n    orbital angular momentum of valence electron: ℓ = 10\n    Grid created: exponential, Float64, Rmax = 1935.0 a.u., Ntot = 1300, h = 0.00769231, r0 = 0.0878529\n    Def created for hydrogen 25n on exponential grid of 1300 points\n\nplot_wavefunction(Z, 1:grid.N, grid, def)\n\nThe plot is made using CairomMakie. NB.: plot_wavefunction is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.reduce_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T<:Real, V<:Real}","page":"Home","title":"CamiXon.reduce_wavefunction","text":"reduce_wavefunction(Z::Vector{Complex{T}}, grid::Grid{V}) where {T<:Real, V<:Real}\n\nConversion from the ordinary radial wavefunction tildeR_nl(ρ) to the reduced radial wavefuntion\n\n    tildechi_nl(ρ) = ρ tildeR_nl(ρ)\n\nwhere ρ is the radial distance to the nucleus in a.u..\n\nExample:\n\natom = castAtom(Z=1, A=1, Q=0; msg=false);\norbit = castOrbit(n=1, ℓ=0; msg=false);\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);\ndef = castDef(grid, atom, orbit, codata);\n\nRH1s_example = [RH1s(atom.Z, grid.r[n]) for n=1:grid.N];\nZH1s_generic = hydrogenic_reduced_wavefunction(1, orbit, grid);\n\nZH1s_example = reduce_wavefunction(RH1s_example, grid);\nRH1s_generic = restore_wavefunction(ZH1s_generic, grid);\n\nZH1s_example ≈ ZH1s_generic\n    true\n\nRH1s_example ≈ RH1s_generic\n    true\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.restore_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T<:Real, V<:Real}","page":"Home","title":"CamiXon.restore_wavefunction","text":"restore_wavefunction(Z::Vector{Complex{T}}, grid::Grid{V}) where {T<:Real, V<:Real}\n\nConversion from the reduced radial wavefunction tildechi_nl(ρ) to the ordinary radial wavefuntion tildeR_nl(ρ),\n\n    tildeR_nl(ρ)=tildechi_nl(ρ)ρ\n\nwhere ρ is the radial distance to the nucleus in a.u..\n\nExample:\n\natom = castAtom(Z=1, A=1, Q=0; msg=false);\norbit = castOrbit(n=1, ℓ=0; msg=false);\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);\ndef = castDef(grid, atom, orbit, codata);\n\nRH1s_example = [RH1s(atom.Z, grid.r[n]) for n=1:grid.N];\nZH1s_generic = hydrogenic_reduced_wavefunction(1, orbit, grid);\n\nZH1s_example = reduce_wavefunction(RH1s_example);\nRH1s_generic = restore_wavefunction(ZH1s_generic);\n\nRH1s_example ≈ RH1s_generic\n    true\n\nZH1s_example ≈ ZH1s_generic\n    true\n\nf1 = real(ZH1s_example)\nf2 = real(ZH1s_generic)\n\ncompare_functions(f1, f2, 1:grid.N, grid)\n\nThe plot is made using CairomMakie. NB.: compare_functions is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.demo_hydrogen-Tuple{}","page":"Home","title":"CamiXon.demo_hydrogen","text":"demo_hydrogen(; n=3, ℓ=2, codata=castCodata(2018))\n\nSolves Schrödinger equation for hydrogen atom with principal quantum number n and rotational quantum number ℓ.\n\nExample:\n\nEcal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);\n    Def created for hydrogen 1s on exponential grid of 100 points\n\nE = 1.5Ecal\nE, def, adams, Z = adams_moulton_master(E, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=true);\n\nplot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)\n\nThe plot is made using CairomMakie. Note the discontinuity in the derivative. NB.: plot_wavefunction is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#Some-special-cases","page":"Home","title":"Some special cases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RH1s(Z::U, r::T) where {U <: Real, T <:Real}\nRH2s(Z::U, r::T) where {U <: Real, T <:Real}\nRH2p(Z::U, r::T) where {U <: Real, T <:Real}","category":"page"},{"location":"#CamiXon.RH1s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U<:Real, T<:Real}","page":"Home","title":"CamiXon.RH1s","text":"RH1s(Z::U, r::T) where {U <: Real, T <:Real}\n\nAnalytic expression for the hydrogenic 1s radial wavefunction and its derivative in the format Z = tildeR + i tildeR^, where\n\n    tildeR_1s(ρ) = Z^32 2 e^-Zρ\n\nis the radial wavefunction and\n\n    tildeR^_1s(ρ) = -Z^52 2 e^-Zρ\n\nits derivative, with ρ the radial distance to the nucleus in a.u..\n\nExample:\n\natom = castAtom(Z=1, A=1, Q=0; msg=false);\norbit = castOrbit(n=1, ℓ=0; msg=false);\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);\ndef = castDef(grid, atom, orbit, codata);\n\nRH1s_example = [RH1s(atom.Z, grid.r[n]) for n=1:grid.N];\n\nplot_wavefunction(RH1s_example, 1:grid.N, grid, def; reduced=false)\n\nThe plot is made using CairomMakie. NB.: plot_function is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.RH2s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U<:Real, T<:Real}","page":"Home","title":"CamiXon.RH2s","text":"RH2s(Z::U, r::T) where {U <: Real, T <:Real}\n\nAnalytic expression for the hydrogenic 1s reduced radial wavefunction and its derivative in the format Z = tildeR + i tildeR^, where\n\n    tildeR_2s(ρ)=left(Z2right)^32(1-Zρ2)2e^-Zρ2\n\nis the radial wavefunction and\n\n    tildeR_2s(ρ)=-left(Z2right)^52(2-Zρ2)2e^-Zρ2\n\nits derivative, with ρ the radial distance to the nucleus in a.u..\n\nExample:\n\natom = castAtom(Z=1, A=1, Q=0; msg=false);\norbit = castOrbit(n=2, ℓ=0; msg=false);\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);\ndef = castDef(grid, atom, orbit, codata; msg=false);\n\nRH2s_example = [RH2s(atom.Z, grid.r[n]) for n=1:grid.N];\n\nplot_wavefunction(RH2s_example, 1:grid.N, grid, def; reduced=false)\n\nThe plot is made using CairomMakie. NB.: plot_wavefunction is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.RH2p-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U<:Real, T<:Real}","page":"Home","title":"CamiXon.RH2p","text":"RH2p(Z::U, r::T) where {U <: Real, T <:Real}\n\nAnalytic expression for the hydrogenic 1s reduced radial wavefunction and its derivative in the format Z = tildeR + i tildeR^, where\n\n    tildeR_2p(ρ)=left(Z2right)^32sqrt13(Zρ2)2e^-Zρ2\n\nis the radial wavefunction and\n\n    tildeR_2p(ρ)=left(Z2right)^32sqrt13(1-Zρ2)2e^-Zρ2\n\nits derivative, with ρ the radial distance to the nucleus in a.u..\n\nExample:\n\natom = castAtom(Z=1, A=1, Q=0; msg=false);\norbit = castOrbit(n=2, ℓ=1; msg=false);\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);\ndef = castDef(grid, atom, orbit, codata);\n\nRH2p_example = [RH2p(atom.Z, grid.r[n]) for n=1:grid.N];\n\nplot_wavefunction(RH2p_example, 1:grid.N, grid, def; reduced=false)\n\nThe plot is made using CairomMakie. NB.: plot_wavefunction is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#Thermodynamic-properties","page":"Home","title":"Thermodynamic properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"svp(atomicnumber::Int, temp::Real)\nlatent_heat_vaporization(atomicnumber::Int, temp::Real)","category":"page"},{"location":"#CamiXon.svp-Tuple{Int64, Real}","page":"Home","title":"CamiXon.svp","text":"svp(atomicnumber::Int, temp::Real)\nsvp(element::String, temp::Real)\n\nSaturated vapor pressure of the elements  p (in Pa), by atomicnumber or  element for a given temperature T (in K).\n\nmathrmlog_ep=A+BT+Cmathrmlog_10T+Dcdot T1000\n\nwhere A,B,C,D, are Antoine coefficients as collected in  CamiXon.dictAntoineCoefficients The quantity\n\nL(T) = B +Ccdot T mathrmlog_10T+Dcdot T^21000\n\nis the latent heat of vaporization (in Joule/K) at temperature T.\n\nCurrently, only the Antoine coefficients for the metalic elements are  implemented - see C. B. Alcock, V. P. Itkin and M. K. Horrigan,  Canadian Metallurgical Quarterly, 23, 309 (1984).\n\nExamples:\n\nTo calculate the saturated vapor pressure of Li (in Pa) at T=623 K we use\n\njulia> svp(\"Li\", 623.0)\n0.0015230367024569058\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.latent_heat_vaporization-Tuple{Int64, Real}","page":"Home","title":"CamiXon.latent_heat_vaporization","text":"latent_heat_vaporization(atomicnumber::Int, temp::Real)\nlatent_heat_vaporization(element::String, temp:Real)\n\nLatent heat of vaporization (in Joule/K) at temperature of the elements  L(T)  (in J/K), by atomicnumber or element for a given temperature T (in K),\n\nL(T) = B +Ccdot T mathrmlog_10T+Dcdot T^21000\n\nwhere A,B,C,D, are Antoine coefficients as collected in  CamiXon.dictAntoineCoefficients\n\nCurrently, only the Antoine coefficients for the metalic elements are  implemented - see C. B. Alcock, V. P. Itkin and M. K. Horrigan,  Canadian Metallurgical Quarterly, 23, 309 (1984).\n\nExample:\n\njulia> latent_heat_vaporization(\"Li\", 623.0)\n-18473.64020109123\n\n\n\n\n\n","category":"method"},{"location":"#Angular-momentum","page":"Home","title":"Angular momentum","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CGC(j1::Real, m1::Real, j2::Real, m2::Real, J::Real, M::Real; msg=false)\nthreeJsymbol(j1::Real, m1::Real, j2::Real, m2::Real, j3::Real, m3::Real; msg=false)","category":"page"},{"location":"#CamiXon.CGC-NTuple{6, Real}","page":"Home","title":"CamiXon.CGC","text":"CGC(j1::Real, m1::Real, j2::Real, m2::Real, J::Real, M::Real; msg=false)\n\nClebsch-Gordan coefficient (CGC). This is a vector-coupling coefficient in Dirac notation. The CGCs are zero unless Δ(j_1j_2j_3)0 (triangle inequality holds) and M=m_1+m_2. The relation to the Wigner 3j symbols is given by:\n\nlangle j_1m_1j_2m_2JMrangleequiv\n(-1)^j_1-j_2+Msqrt2J+1left(beginarrayccc\nj_1  j_2  J\nm_1  m_2  -M\nendarrayright)\n\nExample:\n\nj1=3; m1=0\nj2=4; m2=-1\nJ=5; M=-1\no = CGC(j1, m1, j2, m2, J, M; msg=true); println(\" = $o\")\no = CGC(j1, m1, j2, m2, J, M); println(o)\no = (-1)^(j1-j2+M) * sqrt(2J+1) * threeJsymbol(j1, m1, j2, m2, J, -M); println(o)\n    -√(361/2730) = -0.36364052611670256\n    -0.36364052611670256\n    -0.36364052611670256\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.threeJsymbol-NTuple{6, Real}","page":"Home","title":"CamiXon.threeJsymbol","text":"threeJsymbol(j1::Real, m1::Real, j2::Real, m2::Real, j3::Real, m3::Real; msg=false)\n\nWigner 3j symbol. This is a vector coupling coefficient with optimized symmetry properties. The 3j symbols are zero unless Δ(j_1j_2j_3)0 (triangle inequality holds) and m_1+m_2+m_3=0. The implementation is based on the Racah formula:\n\nleft(beginarrayccc\nj_1  j_2  j_3\nm_1  m_2  m_3\nendarrayright)=\n(-1)^j_1-j_2-m_3sqrtDelta(j_1j_2J)times\nsqrtleft(j_1+m_1right)\nleft(j_1-m_1right)\nleft(j_2+m_2right)\nleft(j_2-m_2right)\nleft(j_3+m_3right)\nleft(j_3-m_3right)\ntimessum_tfrac(-)^tt(j_3-j_2+t+m_1)\n(j_3-j_1+t-m_2)\n(j_1+j_2-j_3-t)(j_1-t-m_1)(j_2-t+m_2)\n\nExample:\n\no = threeJsymbol(3, 0, 4, -1, 5, 1; msg=true); println(\" = $o\")\n    -√(361/30030) = -0.10964174397241236\n\nthreeJsymbol(3, 0, 4, -1, 5, 1)\n    -0.10964174397241236\n\nthreeJsymbol(0, 0, 0, 0, 0, 0)\n    1.0\n\n\n\n\n\n","category":"method"},{"location":"#Grid","page":"Home","title":"Grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Grid object is the backbone for the numerical procedure on a non-uniform grid. Its principal fields are grid.r and grid.r′, which are discrete functions of N elements representing the grid function and its derivative.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grid{T}\ngridname(ID::Int)\ngridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T <: Real\ncastGrid(ID::Int, N::Int, T::Type; h=1, r0=0.001,  p=5, coords=[0,1], epn=5, k=7, msg=true)\nfindIndex(rval::T, grid::Grid{T}) where T<:Number\nautoRmax(atom::Atom, orbit::Orbit)\nautoNtot(orbit::Orbit)\nautoPrecision(Rmax::T, orbit::Orbit) where T<:Real\nautoSteps(ID::Int, Ntot::Int, Rmax::T; p=5, coords=[0,1]) where T<:Real\nautoGrid(atom::Atom, orbit::Orbit, T::Type; p=0, coords=[], Nboost=1, epn=5, k=7, msg=true)\ngrid_differentiation(f::Vector{T}, grid::Grid{T}; k=3) where T<:Real\ngrid_integration(f::Vector{T}, n1::Int, n2::Int, grid::Grid{V}) where {T<:Real, V<:Real}","category":"page"},{"location":"#CamiXon.Grid","page":"Home","title":"CamiXon.Grid","text":"Grid(ID, name, T, N, r, r′, h, r0, epn, epw, k)\n\nType with fields:\n\n.ID:   grid identifer name (::Int)\n.name: grid identifer name (::String)\n.T:    gridType (::Type)\n.N:    number of grid points (::Int)\n.r:   tabulated grid function (::Vector{T})\n.r′:   tabulated derivative of grid function (::Vector{T})\n.h :   grid step multiplyer (::T)\n.r0:   grid scale factor (::T)\n.epn:  number of endpoints used for trapezoidal endpoint correction (must be odd) (::Int)\n.epw:  trapezoidal endpoint weights for n=1:epn (::Vector{Vector{T}})\n.k:    Adams-Moulton order (::Int)\n\nThe object Grid is best created with the function castGrid.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.gridname-Tuple{Int64}","page":"Home","title":"CamiXon.gridname","text":"gridname(ID::Int)\n\nName corresponding to the grid ID.\n\nExample:\n\nn = gridname(2); println(\"The grid type with ID = 2 is called '$n'.\")\n  The grid type with ID = 2 is called 'quasi-exponential'.\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T<:Real","page":"Home","title":"CamiXon.gridfunction","text":"gridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T <: Real\n\nID = 1: exponential grid function,\n\n    fn = textexp(h(n-1)) - 10\n\nID = 2: quasi-exponential grid function degree p (linear grid for p = 1),\n\n    fn = h(n-1) + frac12(h(n-1))^2 +  + frac1p(h(n-1))^p\n\nID = 3: linear grid function,\n\n    fn = h(n-1)\n\nID = 4: polynomial grid function of degree p = length(c) based on polynom c = c_1c_2 c_p,\n\n    fn = c_1h(n-1) + c_2(h(n-1))^2 +  + c_p(h(n-1))^p\n\nExamples:\n\nh = 0.1\nr = [gridfunction(1, n-1, h) for n=1:5]                            # exponential\n [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032, 0.49182469764127035]\n\nr = [gridfunction(2, n-1, h; p = 4) for n=1:5]  # quasi exponential (degree p=4)\n [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375, 0.49173333333333336]\n\nr = [gridfunction(3, n-1, h) for n=1:5]              # linear\n  [0.0, 0.1, 0.2, 0.3, 0.4]\n\nr′= [gridfunction(3, n-1, h; deriv=1) for n=1:5]     # linear (first derivative)\n   [0.1, 0.1, 0.1, 0.1, 0.1]\n\n  r = [gridfunction(4, n-1, h; coords = [0,1,1/2,1/6,1/24]) for n=1:5]  # polynomial of degree 4)\n   [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001, 0.49173333333333336]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castGrid-Tuple{Int64, Int64, Type}","page":"Home","title":"CamiXon.castGrid","text":"castGrid(ID::Int, N::Int, T::Type; h=1, r0=1,  p=5, coords=[0,1], epn=5, k=7, msg=false)\n\nMethod to create the Grid object\n\nID = 1: exponential grid, ID = 2: quasi-exponential grid, ID = 3: linear grid ID = 4: polynomial grid\n\nExamples:\n\nh = 0.1\nr0 = 1.0\ngrid = castGrid(1, 4, Float64; h, r0, msg=true)\ngrid.r\n  create exponential Grid: Float64, Rmax = 0.491825 a.u., Ntot = 4, h = 0.1, r0 = 1.0\n  [1.0e-100, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]\n\ngrid = castGrid(2, 4, Float64; p = 4, h, r0, msg=true))\ngrid.r\n  create quasi-exponential Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, p = 4, h = 0.1, r0 = 1.0\n  [1.0e-100, 0.10517083333333321, 0.22140000000000004, 0.3498375]\n\ngrid = castGrid(3, 4, Float64; coords=[0, 1, 1/2, 1/6, 1/24], h, r0, msg=true)\ngrid.r\n  create polynomial Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, coords = [0.0, 1.0, 0.5, 0.166666, 0.0416666], h = 0.1, r0 = 1.0\n  [1.0e-100, 0.10517083333333334, 0.2214, 0.3498375000000001]\n\ngrid = castGrid(4, 4, Float64; h, r0, msg=true)\ngrid.r\n  create linear Grid: Float64, Rmax = 0.4 a.u., Ntot = 4, p = 1, h = 0.1, r0 = 1.0\n  [1.0e-100, 0.1, 0.2, 0.3]\n\ngrid.r′\n  [0.1, 0.1, 0.1, 0.1]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T<:Number","page":"Home","title":"CamiXon.findIndex","text":"findIndex(rval::T, grid::Grid{T}) where T<:Number\n\nThe grid index corresponding to the position rval on the grid.\n\nExample:\n\nh = 0.1\nr0 = 1.0\ngrid = castGrid(1, 4, Float64; h, r0)\nr = grid.r; println(\"r[3] = $(r[3])\")\n  Grid created: exponential, Float64, Rmax = 0.491825 a.u., Ntot = 4, h = 0.1, r0 = 1.0\n  r[3] = 0.22140275816016985\n\nfindIndex(0.222, grid)\n  3\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoRmax-Tuple{Atom, Orbit}","page":"Home","title":"CamiXon.autoRmax","text":"autoRmax(atom::Atom, orbit::Orbit)\n\nLargest relevant radial distance in a.u. (rule of thumb value)\n\n    R_max = (2n^2 + 20n + 62)Zc\n\nwhere n is the principal quantum number and Z_c the Rydberg charge\n\nExample:\n\ncodata = castCodata(2018)\natom = castAtom(Z=1, A=1, Q=0)\norbit = castOrbit(n=1, ℓ=0)\nrmax = autoRmax(atom::Atom, orbit::Orbit); println(\"rmax = $(rmax) a.u.\")\n    Element created: H, hydrogen, Z=1, weight=1.008\n    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)\n    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1\n    Orbital: 1s\n        principal quantum number: n = 1\n        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 0\n    rmax = 63.0 a.u.\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoNtot-Tuple{Orbit}","page":"Home","title":"CamiXon.autoNtot","text":"autoNtot(orbit::Orbit, Nboost=1)\n\nTotal number of gridpoints (rule of thumb value)\n\n    N_tot = (70 + 50 * n) * N_boost\n\nwhere n is the principal quantum number and Nboost a multiplier to boost numerical precision\n\nExample:\n\norbit = castOrbit(n=1, ℓ=0)\nautoNtot(orbit)\n Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)\n\n 100\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T<:Real","page":"Home","title":"CamiXon.autoPrecision","text":"autoPrecision(Rmax::T, orbit::Orbit) where T<:Real\n\nFloating point precision (rule of thumb value)\n\nExample:\n\natom = castAtom(Z=1)\norbit = castOrbit(n=1,ℓ=0)\nRmax = autoRmax(atom, orbit)\no = autoPrecision(Rmax, orbit); println(\"precision = $o\")\n    Element created: H, hydrogen, Z=1, weight=1.008\n    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)\n    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1\n    Orbital: 1s\n        principal quantum number: n = 1\n        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 0\n    precision = Float64\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T<:Real","page":"Home","title":"CamiXon.autoSteps","text":"autoSteps(ID::Int, Ntot::Int, Rmax::T; p=5) where T<:Real\nautoSteps(ID::Int, Ntot::Int, Rmax::T; coords=[0,1]) where T<:Real\n\nStep size parameter (h) and range parameter (r0) (rule of thumb values).\n\nExample:\n\n(h, r0) = autoSteps(1, 100, 100)\n    (0.1, 0.004540199100968777)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoGrid-Tuple{Atom, Orbit, Type}","page":"Home","title":"CamiXon.autoGrid","text":"autoGrid(atom, orbit,  T; Nboost=1, epn=5, k=7, msg=true, p=0)\nautoGrid(atom, orbits, T; Nboost=1, epn=5, k=7, msg=true, p=0)\nautoGrid(atom, orbit,  T; Nboost=1, epn=5, k=7, msg=true, coords=[])\nautoGrid(atom, orbits, T; Nboost=1, epn=5, k=7, msg=true, coords=[])\n\nAutomatic setting of grid parameters for a given orbit Orbit or an array of orbits - orbits = [orbit1, orbit2, ⋯]. Important cases:\n\np == 0 (exponential radial grid)\np == 1 (linear radial grid)\np > 1 (quasi-exponential radial grid)\ncoords=[] (free polynomial grid based on the coords)\nNboost (multiplier to boost numerical precision)\nepn (endpoint number: odd number to be used for trapezoidal integration with endpoint correction)\nk (Adams-Moulton order to be used for k+1-point Adams-Moulton integration)\n\nExample:\n\ncodata = castCodata(2018)\natom = castAtom(;Z=1, A=1, Q=0, msg=false)\norbit = castOrbit(n=75, ℓ=0, msg=false)\ngrid = autoGrid(atom, orbit, Float64);\n    Grid created: exponential, Float64, Rmax = 16935.0 a.u., Ntot = 3800, h = 0.00263158, r0 = 0.768883\n\nplot_gridfunction(grid, 1:grid.N; title=\"\")\n\nThe plot is made using CairomMakie. NB.: plot_gridfunction is not part of the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T<:Real","page":"Home","title":"CamiXon.grid_differentiation","text":"grid_differentiation(f::Vector{T}, grid::Grid{T}; k=3) where T<:Real\n\nk^th-order lagrangian differentiation of the analytic function f, tabulated in forward order on a Grid of n points, f1n.\n\nExample:\n\nID = 4 # linear grid\nf = [0.0, 1.0, 4.0, 9.0, 16.0, 25.0]\ngrid = castGrid(ID, length(f), Float64; r0=1.0, h=1.0, k=3)  # linear grid\nf′= grid_differentiation(f, grid; k=3); println(\"f′= $(f′)\")\n  Grid created: linear, Float64, Rmax = 6.0 a.u., Ntot = 6, p = 1, h = 1.0, r0 = 1.0\n  f′= [0.0, 2.0, 4.0, 6.0, 7.999999999999998, 9.999999999999993]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.grid_integration-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{V}}} where {T<:Real, V<:Real}","page":"Home","title":"CamiXon.grid_integration","text":"grid_integration(f::Vector{T}, n1::Int, n2::Int, grid::Grid{V}) where {T<:Real, V<:Real}\n\nIntegral of the function f=f_0 f_n tabulated on a Grid using the trapezoidal rule optimized with endpoint correction by the weightsvector grid.epw,\n\n    _0^r_n f(r) dr = _0^n f(x) r^prime(x) dx\n\nwhere the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see trapezoidal_integration). The rule is exact for polynonials of degree d=0 1 k-1, where k= grid.epn. For k=1 the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).\n\nExample:\n\nf1s(r) = 2.0*r*exp(-r);  # hydrogen 1s wavefunction (reduced and unit normalized)\nN = 1000;\ngrid = castGrid(1, N, Float64; h=0.01, r0=0.005)\n    create exponential Grid: Float64, Rmax = 110.127 (a.u.), Ntot = 1000, h = 0.01, r0 = 0.005\n\nr = grid.r;\nf2 = [f1s(r[n])^2 for n=1:N];\ngrid_integration(f2, 1:N, grid) == grid_integration(f2, 1, N, grid)\n    true\n\nnorm = grid_integration(f2, 1:N, grid)\n\n    1.0\n\n\n\n\n\n","category":"method"},{"location":"#Adams-Moulton-integration","page":"Home","title":"Adams-Moulton integration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Adams-Moulton method is used for numerical integration of the reduces radial wave equation. In the present implementation it is constructed on top the objects Atom, Orbit, Grid, Def and Adams using 5 globally defined instances called atom, orbit, grid, def and adams.","category":"page"},{"location":"#Def","page":"Home","title":"Def","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Def object serves to define the problem to be solved and to contain in the field def.Z the solution as a discrete function of N elements.","category":"page"},{"location":"#Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index","page":"Home","title":"Illustration: central field potential U_mathrmCF versus grid index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"codata = castCodata(2018)\natom = castAtom(Z=1, A=1, Q=0)\norbit = castOrbit(n=7, ℓ=2)\ngrid = autoGrid(atom, orbit, Float64)\ndef = castDef(grid, atom, orbit, codata)\nE = convert(grid.T,bohrformula(atom.Z, orbit.n))\nadams = castAdams(E, grid, def)\n@printf \"E = %.15g %s \\n\" E \"Hartree\"\n    Element created: H, hydrogen, Z=1, weight=1.008\n    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)\n    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1\n    Orbital: 7d\n        principal quantum number: n = 7\n        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 2\n    Grid created: exponential, Float64, Rmax = 207.0 a.u., Ntot = 400, h = 0.025, r0 = 0.00939821\n    Def created for hydrogen 7d on exponential grid of 400 points\n    E = -0.0102040816326531 Hartree\n\nplot_potentials(E, grid, def)\n    Nlctp = 234, Nmin = 259, Nuctp = 369 (Ructp = 93.0059202490 a.u.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plot is made using CairomMakie. NB.: plot_potentials is not included in the CamiXon package. (Image: Image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Def{T}\ncastDef(grid::Grid{T}, atom::Atom, orbit::Orbit, codata::Codata; scr=nothing, msg=true) where T <: Real","category":"page"},{"location":"#CamiXon.Def","page":"Home","title":"CamiXon.Def","text":"Def(T, atom, orbit, pot, scr, o1, o2, o3, pos, epn, k, am, matLD)\n\nType with fields:\n\n.T: gridType (::Type)\n.atom: atom object (::Atom)\n.orbit: orbit object (::Orbit)\n.codata: codata object (::Codata)\n.pot: tabulated potential function (::Vector{T})\n.scr: tabulated screening function (::Vector{T})\n.o1: vector of zero-filled matrices (::Vector{Matrix{T}})\n.o2: vector of zero-filled matrices (::Vector{Matrix{T}})\n.o3: vector of unit-filled matrices (::Vector{Matrix{T}})\n.pos: object containing Na, Nlctp, Nmin, Nuctp, Nb, N and nodes (::Pos)\n.epn: number of endpoints trapezoidal correction - must be odd (::Int)\n.k: Adams-Moulton order (::Int)\n.am: Adams-Moulton weight coefficients (::Vector{T})\n.matLD: Lagrangian differentiation matrix (::Matrix{T})\n\nThe object Def is best created with the function castDef.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T<:Real","page":"Home","title":"CamiXon.castDef","text":"castDef(grid::Grid{T}, atom::Atom, orbit::Orbit, codata::Codata[; scr=nothing[, msg=true]]) where T <: Real\n\nCreate the Def object starting from the Grid object and the atomic properties of the objects Atom and Orbit. Optional: scr (supply screening array)\n\nExample:\n\ncodata = castCodata(2018)\natom = castAtom(Z=1, A=1, Q=0)\norbit = castOrbit(n=7, ℓ=2)\ngrid = autoGrid(atom, orbit, Float64)\ndef = castDef(grid, atom, orbit, codata);\n    Element created: H, hydrogen, Z=1, weight=1.008\n    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)\n    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1\n    Orbital: 7d\n        principal quantum number: n = 7\n        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 2\n    Grid created: exponential, Float64, Rmax = 207.0 a.u., Ntot = 400, h = 0.025, r0 = 0.00939821\n    Def created for hydrogen 7d on exponential grid of 400 points\n\n\n\n\n\n","category":"method"},{"location":"#Pos-and-Pos-related-functions","page":"Home","title":"Pos and Pos-related functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Pos object serves within Def object to contain the position indices def.Na, def.Nb, def.Nlctp, def.Nmin, def.Nuctp used in Adams-Moulton integration. These positions are contained in the fields def.pos.Na, def.pos.Nb, def.pos.Nlctp, def.pos.Nmin, def.pos.Nuctp. Alternatively, they can be determined with the functions get_Na, get_Nb, get_Nlctp, get_Nmin, get_Nuctp.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pos\nget_Na(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\nget_Nb(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\nget_Nlctp(E::T, def::Def{T}) where T<:Real\nget_Nmin(def::Def{T}) where T<:Real\nget_Nuctp(E::T, def::Def{T}) where T<:Real\ncount_nodes(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real","category":"page"},{"location":"#CamiXon.Pos","page":"Home","title":"CamiXon.Pos","text":"Pos(Na::Int, Nlctp::Int, Nmin::Int, Nuctp::Int, Nb::Int, N::Int, nodes::Int, cWKB::Float64)\n\nType with fields:\n\n.Na: grid index of last leading point (::Int)\n.Nlctp: grid index of lower classical turning point (::Int)\n.Nmin: grid index of (screened) potential minimum (::Int)\n.Nuctp: grid index of upper classical turning point (::Int)\n.Nb: grid index first trailing point (::Int)\n.N: grid index last point (::Int)\n.nodes: number of nodes  (::Int)\n.cWKB: WKB threshold level determining Na and Nb (::Float64)\n\nMutable struct to hold special grid indices as well as the number of nodes; Pos is one of the fields of the Def object\n\nExamples:\n\npos = Pos(1, 2, 3, 4, 5, 6, 7, 8)\npos.Nuctp\n    4\n\npos.Nuctp = 8\npos\n    Pos(1, 2, 3, 9, 5, 6, 7, 8)\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.get_Na","text":"get_Na(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\n\nGrid index of the starting point for outward numerical integration. This is k+1 or the point marking the end of the quasiclassical region below the lower classical turning point (lctp) as marked by the WKB threshold value (def.pos.cWKB).\n\nExample:\n\nEcal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)\nE, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=false);\n    Orbital: 1s\n        principal quantum number: n = 1\n        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 0\n    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033\n    Def created for hydrogen 1s on exponential grid\n\nNa = get_Na(Z, def)\nprintln(\"k + 1 = $(grid.k+1); Na = $Na\")\n    k + 1 = 8; Na = 8\n\nNa == def.pos.Na\n    true\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.get_Nb","text":"get_Nb(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\n\nGrid index of the stopping for outward numerical integration. This is N-k-1 or the point marking the start of the quasiclassical region above the upper classical turning point (Nuctp) as marked by the WKB threshold value (def.pos.cWKB).\n\nExample:\n\nEcal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)\nE, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=false);\n    Orbital: 1s\n        principal quantum number: n = 1\n        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 0\n    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033\n    Def created for hydrogen 1s on exponential grid\n\nNb = get_Nb(Z, def)\nprintln(\"N - k - 1 = $(grid.N-grid.k-1); Nb = $Nb\")\n    N - k - 1 = 92; Nb = 92\n\nNb == def.pos.Nb\n    true\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.get_Nlctp","text":"get_Nlctp(E::T, def::Def{T}) where T<:Real\n\nGrid index of the *lower classical turning point * of the screened potential curve. By definition get_Nlctp(E, def) = 2 for zero orbital angular momentum (ℓ=0).\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T<:Real","page":"Home","title":"CamiXon.get_Nmin","text":"get_Nmin(def::Def{T}) where T<:Real\n\nGrid index of the minimum of the screened potential curve. By definition get_Nmin(def) = 1 for zero orbital angular momentum (ℓ=0).\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.get_Nuctp","text":"get_Nuctp(E::T, def::Def{T}) where T<:Real\n\nGrid index of the upper classical turning point of the screened potential curve. By definition get_Nuctp(E, def) = N-1 for zero orbital angular momentum (ℓ=0).\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.count_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.count_nodes","text":"count_nodes(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\n\nNumber of nodes (excluding the origin) of the reduced radial wavefunction χ(r) = real(Z).\n\nExample:\n\natom = castAtom(Z=1, A=1, Q=0, msg=false);\norbit = castOrbit(n=3, ℓ=2, msg=false);\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, epn=5, k=7, msg=false);\ndef = castDef(grid.T, atom, orbit, codata);\n    Def created for hydrogen 3d on exponential grid of 200 points\n\nE = convert(setT, bohrformula(atom.Z, orbit.n));\nadams = castAdams(E, grid, def);\nE, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=false);\n\no = count_nodes(Z, def); println(\"node count: $o nodes\")\n    node count: 0 nodes\n\n\n\n\n\n","category":"method"},{"location":"#Adams","page":"Home","title":"Adams","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Adams object serves to hold the Adams-Moulton integration matrices matG, matσ, matMinv as well as the actual normalized solution Z in the form of a tabulated function of N elements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Adams\ncastAdams(E::T, grid::Grid{T}, def::Def{T}) where T<:Real\nupdateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T<:Real\ninitE(def::Def{T}; E=nothing) where T<:Real","category":"page"},{"location":"#CamiXon.Adams","page":"Home","title":"CamiXon.Adams","text":"Adams{T}\n\nG: (:Vector{Matrix{T}})\nσ: (:Vector{Matrix{T}})\nMinv: (:Vector{Matrix{T}})\nZ: (:Vector{Complex{T}})\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.castAdams","text":"castAdams(E::T, grid::Grid{T}, def::Def{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.updateAdams!","text":"updateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T<:Real","page":"Home","title":"CamiXon.initE","text":"initE(def::Def{T}) where T<:Real\n\nAutogenerated seed value for the energy\n\nExample:\n\ncodata = castCodata(2018)\natom = castAtom(Z=1, A=1, Q=0; msg=false)\norbit = castOrbit(n=1, ℓ=0; msg=false)\ngrid = autoGrid(atom, orbit, Float64; msg=false)\ndef = castDef(grid, atom, orbit, codata);\n    Def created for hydrogen 1s on exponential grid of 100 points\n\nE = initE(def); println(\"E = $E\")\n    E = -0.03508495857961283\n\n\n\n\n\n","category":"method"},{"location":"#Adams-related-functions","page":"Home","title":"Adams related functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"matG(E::T, grid::Grid{T}, def::Def{T}) where T<:Real\nmatσ(E::T, grid::Grid{T}, def::Def{T}) where T<:Real\nmatMinv(E::T, grid::Grid{T}, def::Def{T}, amEnd::T) where T<:Real","category":"page"},{"location":"#CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.matG","text":"matG(E::T, grid::Grid{T}, def::Def{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.matσ","text":"matσ(E::T, grid::Grid{T}, def::Def{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T<:Real","page":"Home","title":"CamiXon.matMinv","text":"matMinv(E::T, grid::Grid{T}, def::Def{T}, amEnd::T) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#Adams-Moulton-numerical-solution-of-the-radial-wave-equation","page":"Home","title":"Adams-Moulton numerical solution of the radial wave equation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"adams_moulton_solve(E::T, grid::Grid{T}, def::Def{T}, adams::Adams) where T<:Real","category":"page"},{"location":"#CamiXon.adams_moulton_solve-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T<:Real","page":"Home","title":"CamiXon.adams_moulton_solve","text":"adams_moulton_solve(E::T, grid::Grid{T}, def::Def{T}, adams::Adams) where T<:Real\n\nNumerical solution of the 1D Schrödinger equation for the radial motion of a valence electron of energy E. Output: the improved Adams object, the energy convergence ΔE, and Z, where P = real(Z) is the reduced radial wavefunction and Q = imag(Z) its derivative.\n\nExample:\n\natom = castAtom(Z=1, A=1, Q=0, msg=true)\norbit = castOrbit(n=1, ℓ=0)\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, msg=true)\ndef = castDef(grid, atom, orbit, codata)\nE = Ecal = convert(grid.T, bohrformula(atom.Z, orbit.n))\nadams = castAdams(E, grid, def);\n\nadams, ΔE, Z = adams_moulton_solve(E, grid, def, adams)\nplot_wavefunction(Z, 1:grid.N, grid, def; reduced=true)\n\nThe plot is made using CairomMakie. NB.: plot_wavefunction is not part of the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#Radial-integration-outward","page":"Home","title":"Radial integration - outward","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OUTSCH(E::T, grid::Grid{T}, def::Def{T}, σ::Vector{Matrix{T}}) where T<:Real\nadams_moulton_outward(def::Def{T}, adams::Adams{T}) where T<:Real","category":"page"},{"location":"#CamiXon.OUTSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T<:Real","page":"Home","title":"CamiXon.OUTSCH","text":"OUTSCH(E::T, grid::Grid{T}, def::Def{T}, σ::Vector{Matrix{T}}})) where T<:Real\n\nSolution of the Schrödinger for the first k points on the grid, where k is the Adams-Moulton order. The WKB solution for energy E is used when the WKB approximation is valid (for nonzero angular momentum at distances below the inner classical turning point - ictp)\n\nExample:\n\nEcal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)\nZ = OUTSCH(Ecal, grid, def, adams.σ)\nprintln(\"\\nZ: standard Ansatz for wavefunction (n < Na=$(def.pos.Na)))\")\n    Orbital: 1s\n        principal quantum number: n = 1\n        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 0\n    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033\n    Def created for hydrogen 1s on exponential grid\n\n    Z: standard Ansatz for wavefunction (n < Na=8))\n\nEcal, grid, def, adams = demo_hydrogen(n=10, ℓ=5)\nZ = OUTSCH(Ecal, grid, def, adams.σ);\nprintln(\"\\nZ: WKB Ansatz for wavefunction (n < Na=$(def.pos.Na)))\")\n    Orbital: 10h\n        principal quantum number: n = 10\n        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 5\n    Grid created: exponential, Float64, Rmax = 360.0 a.u., Ntot = 550, h = 0.0181818, r0 = 0.0163447\n    Def created for hydrogen 10h on exponential grid\n\n    Z: WKB Ansatz for wavefunction (n < Na=70))\n\nplot_wavefunction(Z, 1:def.pos.Na, grid, def; reduced=true)\n\nThe plot is made using CairomMakie. NB.: plot_wavefunction is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T<:Real","page":"Home","title":"CamiXon.adams_moulton_outward","text":"adams_moulton_outward(def::Def{T}, adams::Adams{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#Radial-integration-inward","page":"Home","title":"Radial integration - inward","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"#INSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real\nINSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real\nadams_moulton_inward(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real","category":"page"},{"location":"#CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T<:Real","page":"Home","title":"CamiXon.INSCH","text":"INSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T<:Real","page":"Home","title":"CamiXon.adams_moulton_inward","text":"adams_moulton_inward(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#Radial-integration-boundary-condition-applied-and-convergence-test","page":"Home","title":"Radial integration - boundary condition applied and convergence test","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"adams_moulton_normalized(Z::Vector{Complex{T}}, ΔQ::T, grid::Grid{T}, def::Def{T}) where T<:Real\nadams_moulton_patch(Z::Vector{Complex{T}}, def::Def{T}, adams::Adams{T}) where T<:Real","category":"page"},{"location":"#CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.adams_moulton_normalized","text":"adams_moulton_normalized(Z::Vector{Complex{T}}, ΔQ::T, grid::Grid{T}, def::Def{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.adams_moulton_patch-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}, Adams{T}}} where T<:Real","page":"Home","title":"CamiXon.adams_moulton_patch","text":"adams_moulton_patch(Z::Vector{Complex{T}}, def::Def{T}, adams::Adams{T}) where T<:Real\n\nCorrect first 2k points of Z.\n\n\n\n\n\n","category":"method"},{"location":"#Adams-Moulton-Master-procedures","page":"Home","title":"Adams-Moulton Master procedures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"adams_moulton_prepare(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real\nadams_moulton_iterate(init::NTuple{4,T}, grid::Grid{T}, def::Def{T}, adams::Adams{T}; imax=25, Δν=Value(1,\"kHz\")) where T<:Real\nadams_moulton_master(E, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=true)","category":"page"},{"location":"#CamiXon.adams_moulton_prepare-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T<:Real","page":"Home","title":"CamiXon.adams_moulton_prepare","text":"adams_moulton_prepare(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real\n\nSolves the Schrödinger equation for an atom defined by def for energy E on grid the grid with the Adams-Moulton method defined by adams. E is adjusted until the wavefunction has the correct number of n′ nodes.\n\nExample:\n\nEcal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);\n    Def created for hydrogen 1s on exponential grid of 100 points\n\nE = 1.5Ecal\nmsg, adams, init, Z = adams_moulton_prepare(E, grid, def, adams);\n    Ecal = -0.5; E = -0.75; 0 nodes\n\nplot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)\n\nThe plot is made using CairomMakie. Note the discontinuity in the derivative. NB.: plot_wavefunction is not included in the CamiXon package.\n\n(Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.adams_moulton_iterate-Union{Tuple{T}, Tuple{NTuple{4, T}, Grid{T}, Def{T}, Adams{T}}} where T<:Real","page":"Home","title":"CamiXon.adams_moulton_iterate","text":"adams_moulton_iterate(init::NTuple{4,T}, grid::Grid{T}, def::Def{T}, adams::Adams{T}; imax=25, Δν=Value(1,\"kHz\")) where T<:Real\n\nSolves the Schrödinger equation for an atom defined by def for energy E on grid the grid with the Adams-Moulton method defined by adams; E is adjusted in an iteration procedure until convergence is reached within the convergence goal Δν is reached (limited to a maximum of imax iterations).\n\nExample:\n\nEcal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);\n    Def created for hydrogen 1s on exponential grid of 100 points\n\nE = 1.5Ecal;\nmsg1, adams, init, Z = adams_moulton_prepare(E, grid, def, adams);\nprintln(\"Ecal = $Ecal; E = $(init[2]); $(def.pos.nodes) nodes\")\n    Ecal = -0.5; E = -0.75; 0 nodes\n\nmsg2, adams, init, Z = adams_moulton_iterate(init, grid, def, adams; Δν=Value(1,\"MHz\"), imax=25)\nprintln(\"Ecal = $Ecal; E = $(init[2]); $(def.pos.nodes) nodes\")\n    Ecal = -0.5; E = -0.49999997841850014; 0 nodes\n\nplot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)\n\nThe plot is made using CairomMakie. NB.: plot_wavefunction is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.adams_moulton_master-NTuple{4, Any}","page":"Home","title":"CamiXon.adams_moulton_master","text":"adams_moulton_master(E, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=false)\n\nSolves the Schrödinger equation for an atom defined by def for energy E on grid the grid with the Adams-Moulton method defined by adams.\n\nΔν: convergence goal\n\nimax: maximum number of iterations\n\nExample:\n\nEcal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);\n    Def created for hydrogen 1s on exponential grid of 100 points\n\nE = 1.5Ecal;\nE, def, adams, Z = adams_moulton_master(E, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=true);\nplot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)\n\nThe plot is made using CairomMakie. NB.: plot_wavefunction is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#Coulomb-integrals","page":"Home","title":"Coulomb integrals","text":"","category":"section"},{"location":"#Angular-integrals","page":"Home","title":"Angular integrals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"a_direct(k::Int, l::Int, ml::Int, l′::Int, ml′::Int)\nb_exchange(k::Int, l::Int, ml::Int, l′::Int, ml′::Int)\nUF(k::Int, F::Vector{T}, grid::Grid{V}) where {T<:Real, V<:Real}\nUG(k::Int, P1::Vector{T}, P2::Vector{T}, grid::Grid{V}) where {T<:Real, V<:Real}","category":"page"},{"location":"#CamiXon.a_direct-NTuple{5, Int64}","page":"Home","title":"CamiXon.a_direct","text":"a_direct(k::Int, l::Int, ml::Int, l′::Int, ml′::Int)\n\nCoulomb angular integral - direct part:\n\na^k(lm_ll^primem_l^prime)=(-)^m_l+m_l^prime\n(2l+1)(2l^prime+1)left(beginarrayccc\nl  k  l\n0  0  0\nendarrayright)left(beginarrayccc\nl  k  l\n-m_l  0  m_l\nendarrayright)left(beginarrayccc\nl^prime  k  l^prime\n0  0  0\nendarrayright)left(beginarrayccc\nl^prime  k  l^prime\n-m_l^prime  0  m_l^prime\nendarrayright)\n\nExample:\n\na_direct(2,1,1,2,2)\n    2//35\n\na_direct(6,3,2,3,-1)\n    -250//20449\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.b_exchange-NTuple{5, Int64}","page":"Home","title":"CamiXon.b_exchange","text":"b_exchange(k::Int, l::Int, ml::Int, l′::Int, ml′::Int)\n\nCoulomb angular integral - exchange part:\n\nb^k(lm_ll^primem_l^prime)=(2l+1)(2l^prime+1)\nleft(beginarrayccc\nl  k  l^prime\n0  0  0\nendarrayright)^2left(beginarrayccc\nl  k  l^prime\n-m_l  (m_l-m_l^prime)  m_l^prime\nendarrayright)^2\n\nExample:\n\nb_exchange(1,1,1,2,2)\n    2//5\n\nb_exchange(6,3,2,3,-1)\n    1050//20449\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.UF-Union{Tuple{V}, Tuple{T}, Tuple{Int64, Vector{T}, Grid{V}}} where {T<:Real, V<:Real}","page":"Home","title":"CamiXon.UF","text":"UF(k::Int, P::Vector{T}, grid::Grid{V}) where {T<:Real, V<:Real}\n\nPotential for directe screening,\n\nU_F^k(rho)\n=frac1rho^k+1int_0^rhovarrho^k\nlefttildeR_nl(varrho)right^2\nvarrho^2dvarrho+rho^kint_rho^infty\nfrac1varrho^k+1\nlefttildeR_nl(varrho)right^2varrho^2dvarrho\n\nExample:\n\natom = castAtom(Z=2, A=4, Q=0; msg=true)\norbit = castOrbit(n=1, ℓ=0; msg=true)\nscr = nothing\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, msg=true)\ndef = castDef(grid, atom, orbit, codata; scr)\nE = initE(def1)\nadams = castAdams(E, grid, def)\nE, def, adams, Z = adams_moulton_master(E, grid, def, adams; Δν=Value(1,\"kHz\"), imax=50, msg=false);\n\nP1 = real(Z)\nUF0P1 = UF(0, P1, grid);\nplot_function(scrUF0P1, 1:grid.N, grid; title=\"He4(1s,1s):  direct screening potential\")\n\nThe plot is made using CairomMakie. NB.: plot_function is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.UG-Union{Tuple{V}, Tuple{T}, Tuple{Int64, Vector{T}, Vector{T}, Grid{V}}} where {T<:Real, V<:Real}","page":"Home","title":"CamiXon.UG","text":"UG(k::Int, P1::Vector{T}, P2::Vector{T}, grid::Grid{V}) where {T<:Real, V<:Real}\n\nPotential for exchange screening,\n\nU_G^k(rho)\n=frac1rho^k+1int_0^rhovarrho^ktildeR_nl(varrho)\ntildeR_n^primel^prime(varrho)\nvarrho^2dvarrho+rho^kint_rho^infty\nfrac1varrho^k+1tildeR_nl(varrho)\ntildeR_n^primel^prime(varrho)varrho^2dvarrho\n\nExample:\n\natom = castAtom(Z=2, A=4, Q=0; msg=true)\norbit1 = castOrbit(n=1, ℓ=0; msg=true)\norbit2 = castOrbit(n=2, ℓ=0; msg=true)\nscr = nothing\ngrid = autoGrid(atom, [orbit1,orbit2], Float64; Nboost=1, msg=true)\ndef1 = castDef(grid, atom, orbit1, codata; scr)\nE = initE(def1)\nadams = castAdams(E, grid, def1)\nE, def, adams, Z1 = adams_moulton_master(E, grid, def1, adams; Δν=Value(1,\"kHz\"), imax=50, msg=false);\n\ndef2 = castDef(grid, atom, orbit2, codata; scr)\nE = initE(def2)\nadams = castAdams(E, grid, def2)\nE, def, adams, Z2 = adams_moulton_master(E, grid, def2, adams; Δν=Value(1,\"kHz\"), imax=50, msg=false);\n\nP1 = real(Z1);\nP2 = real(Z2);\n\nUG0 = UG(0, P1, P2, grid);\nplot_function(UG0, 1:grid.N, grid; title=\"He4(1s,2s):  exchange screening potential\")\n\nThe plot is made using CairomMakie. NB.: plot_function is not included in the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#Plotting","page":"Home","title":"Plotting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"step125(x::Real)\nselect125(x)\nsteps(x::Vector{T} where T<:Real)\nstepcenters(x::Vector{T} where T<:Real)\nstepedges(x::Vector{T} where T<:Real)\nedges(px, Δx=1.0, x0=0.0)","category":"page"},{"location":"#CamiXon.step125-Tuple{Real}","page":"Home","title":"CamiXon.step125","text":"step125(x)\n\nStep used for deviding the number x in steps according to 1-2-5 scheme\n\nExamples:\n\nstep125.([5,10,21.3,50,100.1])\n5-element Vector{Int64}:\n  1\n  2\n  5\n 10\n 20\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.select125-Tuple{Any}","page":"Home","title":"CamiXon.select125","text":"select125(x)\n\nSelect elements of the collection x by index according to 1-2-5 scheme\n\nExamples:\n\nx = [1,2,4,6,8,10,13,16,18,20,40,60,80,100]\nselect125(x)\n [2, 6, 10, 16, 20, 60, 100]\n\nx = string.(x)\nselect125(x)\n [\"2\", \"6\", \"10\", \"16\", \"20\", \"60\", \"100\"]\n\nx = 1:100\nselect125(x)\n [20, 40, 60, 80, 100]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.steps-Tuple{Vector{T} where T<:Real}","page":"Home","title":"CamiXon.steps","text":"steps(x)\n\nHeatmap range transformation for steplength specification vector x\n\nExamples:\n\nx = [4,2,6]\nsteps(x)\n [0, 4, 6, 12]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.stepcenters-Tuple{Vector{T} where T<:Real}","page":"Home","title":"CamiXon.stepcenters","text":"stepcenters(x)\n\nStepcenter positions for steplength specification vector x\n\nExamples:\n\nx = [4,2,6]\nstepcenters(x)\n [2.0, 5.0, 9.0]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.stepedges-Tuple{Vector{T} where T<:Real}","page":"Home","title":"CamiXon.stepedges","text":"stepedges(x)\n\nStepedges for steplength specification vector x\n\nExamples:\n\nx = [4,2,6]\nstepedges(x)\n [0, 4, 6, 12]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.edges","page":"Home","title":"CamiXon.edges","text":"edges(px [, Δx[, x0]])\n\nHeatmap range transformation from pixel coordinates to physical coordinates, with pixelsize Δx and offset x0, both in physical units.\n\nExamples:\n\npx = 1:5\nΔx = 2.5\nx0 = 2.5\nedges(px)\n [0.5, 1.5, 2.5, 3.5, 4.5]\n\nedges(px, Δx)\n [1.25, 3.75, 6.25, 8.75, 11.25]\n\nedges(px, Δx, x0)\n [-1.25, 1.25, 3.75, 6.25, 8.75]\n\n\n\n\n\n","category":"function"},{"location":"#Julia-tools","page":"Home","title":"Julia tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"primitivetype(T::Type)\nlc_primitivetype(o::Any)\nlc_eltype(o)\nbigconvert(o)\nconditionalType(n::T, nc::Int; msg=true) where {T<:Integer}\nfind_all(A::Union{String,AbstractArray{T,1}}, a::T...; count=false)  where T\nfind_first(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T\nfind_last(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T","category":"page"},{"location":"#CamiXon.primitivetype-Tuple{Type}","page":"Home","title":"CamiXon.primitivetype","text":"primitivetype(T::Type)\n\nThe primitive type of a Type\n\nExamples:\n\njulia> T = Complex{Float16}};\njulia> primitivetype(T)\nFloat16\n\njulia> T = String\njulia> primitivetype(T)\nChar\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.lc_primitivetype-Tuple{Any}","page":"Home","title":"CamiXon.lc_primitivetype","text":"lc_primitivetype(o::Any)\n\nLowest comon primitive type of Any Type\n\nExamples:\n\njulia> o = ([1//2, 1//3]; (1//4, 1//1, 1//6));\njulia> lc_primitivetype(o)\nInt64\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.lc_eltype-Tuple{Any}","page":"Home","title":"CamiXon.lc_eltype","text":"lc_eltype(o)\n\nLowest common eltype of a collection.\n\nExamples:\n\njulia> o = ([1//2, 1//3]; (1//4, 1//1, 1//6));\njulia> lc_eltype(o)\nRational{Int64}\n\njulia> o = ([1//2, 1//3]; (1//4, big(1)//big(5), 1//6));\njulia> lc_eltype(o)\nRational\n\njulia> o = ([1//2, 1//3]; (1//4, [big(1)//big(5)], 1//6));\njulia> lc_eltype(o)\nAny\n\njulia> o = ([1/2, 1/3]; (1/4, 1/1, 1/6));\njulia> lc_eltype(o)\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.bigconvert-Tuple{Any}","page":"Home","title":"CamiXon.bigconvert","text":"bigconvert(o)\n\nConvert IntBased types to BigIntBased types for n > nc in accordance with dictBigConversion.\n\nExample:\n\njulia> o = [[1//1, 1//2, 1//3],[1//1, 1//2, 1//3]]\n2-element Vector{Vector{Rational{Int64}}}:\n [1//1, 1//2, 1//3]\n [1//1, 1//2, 1//3]\n\njulia> bigconvert(o)\n2-element Vector{Vector{Rational{Int64}}}:\n [1//1, 1//2, 1//3]\n [1//1, 1//2, 1//3]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.conditionalType-Union{Tuple{T}, Tuple{T, Int64}} where T<:Integer","page":"Home","title":"CamiXon.conditionalType","text":"conditionalType(n::T, nc::T [; msg=true]) where T<:Integer\n\nConvert type T to BigInt for n > nc.\n\nExample:\n\njulia> conditionalType(46, 46)\nInt64\n\njulia> conditionalType(47, 46)\nBigInt\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T","page":"Home","title":"CamiXon.find_all","text":"find_all(A [,a...]; count=false)\n\nA: string/array of elements of the same type\n\ndefault   : Array containing the index (indices) of selected elements of A (default: all elements)\n\ncount=true: The number of indices found for selected elements of A (default: all elements)\n\nExamples:\n\nA = [:📑,:📌,:📢,:📌,:📞]\nB = [1,2,3,2,5]\nstr = \"aβcβd\";\nfind_all(A) == find_all(B) == find_all(str)\ntrue\n\nfind_all(A,:📌)\n1-element Array{Array{Int64,1},1}:\n [2, 4]\n\nfind_all(str)\n4-element Array{Array{Int64,1},1}:\n [1]\n [2, 4]\n [3]\n [5]\n\nfind_all(A; count=true)\n4-element Array{Int64,1}:\n 1\n 2\n 1\n 1\n\nstr = \"📑📌📢📌📞\"\nfind_all(str,'📌')\n1-element Array{Array{Int64,1},1}:\n [2, 4]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T","page":"Home","title":"CamiXon.find_first","text":"find_first(A [,a...]; dict=false)\n\nThe first index of selected Array element\n\nA: string/array of elements of the same type\n\ndefault  : Array containing the first index (indices) of selected elements of A (default: all elements)\n\ndict=true: Dict for the first index (indices) of selected elements of A (default: all elements)\n\nExamples:\n\nA = [:📑,:📌,:📢,:📌,:📞]\nB = [1,2,3,2,5]\nstr = \"aβcβd\";\n\nfind_first(A) == find_first(B) == find_first(str)\ntrue\n\nfind_first(A,:📌)\n1-element Array{Array{Int64,1},1}:\n 2\n\nfind_last(A,:📌; dict=true)\n1-element Array{Pair{Symbol,Int64},1}:\n :📌 => 2\n\nfind_last(A; dict=true)\n4-element Array{Pair{Symbol,Int64},1}:\n :📑 => 1\n :📌 => 2\n :📢 => 3\n :📞 => 5\n\nfind_first(str)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 5\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T","page":"Home","title":"CamiXon.find_last","text":"find_last(A [,a...]; dict=false)\n\nThe last index of selected Array element\n\nA: string/array of elements of the same type\n\ndefault  : Array containing the lasst index (indices) of selected elements of A (default: all elements)\n\ndict=true: Dict for the lasst index (indices) of selected elements of A (default: all elements)\n\nExamples:\n\nA = [:📑,:📌,:📢,:📌,:📞]\nB = [1,2,3,2,5]\nstr = \"aβcβd\";\nfind_last(A) == find_first(B) == find_first(str)\ntrue\n\nfind_last(A,:📌)\n1-element Array{Array{Int64,1},1}:\n 4\n\nfind_last(A,:📌; dict=true)\n1-element Array{Pair{Symbol,Int64},1}:\n :📌 => 4\n\nfind_last(A; dict=true)\n4-element Array{Pair{Symbol,Int64},1}:\n :📑 => 1\n :📌 => 4\n :📢 => 3\n :📞 => 5\n\nfind_last(str)\n4-element Array{Int64,1}:\n 1\n 4\n 3\n 5\n\n\n\n\n\n","category":"method"},{"location":"#Finite-difference-methods","page":"Home","title":"Finite-difference methods","text":"","category":"section"},{"location":"#Finite-differences","page":"Home","title":"Finite differences","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider the analytical function f tabulated in forward order   (growing index) at n positions on a uniform grid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Forward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"In forward difference notation, the finite difference of two adjacent values on the grid is defined as","category":"page"},{"location":"","page":"Home","title":"Home","text":"Δ fn = fn+1-fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Δ is the forward difference operator. By a formal inversion   procedure we find","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn-1=(1+Δ)^-1fn=(1-Δ+Δ^2-Δ^3+)fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Δ^k is the  k^th-order forward difference defined as a weighted sum over the function values fnn+k (involving k+1 points),","category":"page"},{"location":"","page":"Home","title":"Home","text":"Δ^k fn = c_k^kfn + c_k-1^kfn+1 +   + fn+k\n= sum_j=0^k c_k-j^k fn+j","category":"page"},{"location":"","page":"Home","title":"Home","text":"The k+1 coefficients","category":"page"},{"location":"","page":"Home","title":"Home","text":"c_k-j^k=(-1)^k-jbinomkj","category":"page"},{"location":"","page":"Home","title":"Home","text":"are the summation weights (short: weights) which define the summation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Backward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"In backward difference notation, the finite difference of two adjacent values on the grid is defined as","category":"page"},{"location":"","page":"Home","title":"Home","text":" fn = fn-fn-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"where  is the backward difference operator.  By a formal inversion   procedure we find","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn+1=(1-)^-1fn=(1++^2+^3+)fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"where ^k is the  k^th-order backward difference defined as a weighted sum over the function values tabulated in backward order, fn-1n-k (involving k+1 points),","category":"page"},{"location":"","page":"Home","title":"Home","text":"^k fn = fn + c_1^kfn-1 +  + c_k^kfn-k\n= sum_j=0^k c_j^kfn-j","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the k+1 coefficients","category":"page"},{"location":"","page":"Home","title":"Home","text":"c_j^k=(-1)^jbinomkj","category":"page"},{"location":"","page":"Home","title":"Home","text":"are the summation weights (short: weights) which define the summation. Note the special cases c_0^k1, c_k^k(-1)^k and the symmetry relation","category":"page"},{"location":"","page":"Home","title":"Home","text":"c_k-j^k=(-1)^k c_j^k","category":"page"},{"location":"","page":"Home","title":"Home","text":"Coefficients:  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_weight(k,j)  c_j^k=(-1)^jbinomkj","category":"page"},{"location":"","page":"Home","title":"Home","text":"isforward(notation)\nisregular(ordering)\nfdiff_weight(k::Int, j::Int)","category":"page"},{"location":"#CamiXon.isforward-Tuple{Any}","page":"Home","title":"CamiXon.isforward","text":"function isforward(val)\n\nBoolean status of val, with options: fwd (forward) and bwd (backward).\n\nExample:\n\njulia? isforward(fwd)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.isregular-Tuple{Any}","page":"Home","title":"CamiXon.isregular","text":"function isregular(val)\n\nBoolean status of val, with options: reg (regular) and rev (reversed).\n\nExample:\n\nisregular(reg)\n  true\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.fdiff_weight-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.fdiff_weight","text":"fdiff_weight(k::Int, j::Int)\n\nFinite difference weight coefficient,\n\nc_j^k=(-1)^k+jbinomkj\n\nExample:\n\nc(k,j) = fdiff_weight(k,j)\n\n[[c(k,j) for j=0:k] for k=0:3] == [[1], [1, -1], [1, -2, 1], [1, -3, 3, -1]]\n  true\n\n[[c(k,k-j) for j=0:k] for k=0:3] == [[1], [-1, 1], [1, -2, 1], [-1, 3, -3, 1]]\n  true\n\n\n\n\n\n","category":"method"},{"location":"#Finite-difference-expansions","page":"Home","title":"Finite difference expansions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Finite-difference calculus builds on the finite-difference expansion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Forward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"In terms of forward differences the expansion takes the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_p=0^inftyα_pΔ^pfn\n=sum_p=0^kα_pΔ^pfn+","category":"page"},{"location":"","page":"Home","title":"Home","text":"A finite-difference expansion truncated at order k is defined by k+1 finite-difference expansion coefficients, represented by the vector α = α_0 α_k. It takes some bookkeeping to rewrite the expansion as a weighted sum over the k+1 function values in forward tabulated form fnn+k. Substituting the finite difference expression for Δ^k, we obtain","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_p=0^kα_pΔ^pfn\n=sum_p=0^kα_psum_j=0^pc_p-j^pfn+j\n=sum_j=0^ksum_p=j^kα_pc_p-j^pfn+j\n=sum_j=0^kF_j^kfn+j","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the weighted summation is defined by the weights","category":"page"},{"location":"","page":"Home","title":"Home","text":"F_j^k=sum_p=j^kα_pc_p-j^p\n=sum_p=j^k(-1)^p+jbinompjα_p","category":"page"},{"location":"","page":"Home","title":"Home","text":"with j=0 k. In inner product form the expansion becomes","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_p=0^kα_pΔ^pfn\n=sum_j=0^kF_j^kfn+j\n=F^k cdot fnn+k","category":"page"},{"location":"","page":"Home","title":"Home","text":"where F^k   F_0^k F_k^k.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fnn+k = leftbeginarrayc\nfn\nvdots\nfn+k\nendarrayright","category":"page"},{"location":"","page":"Home","title":"Home","text":"Coefficients:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_expansion_weights(coeffs, fwd, reg)  F^k  F_0^k F_k^k,","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the coeffs α  α_0 α_k are user supplied to define the expansion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Backward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"In terms of backward differences the expansion takes the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_p=0^inftyβ_p^pfn=sum_p=0^kβ_p^pfn+","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this case the k^th- order finite-difference expansion is defined by the vector β = β_0 β_k. The expansion can written as weighted sum over the k+1 function values in backward tabulated form fn-1n-k. Substituting the finite difference expression for ^k, we obtain","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_p=0^kβ_p^pfn\n=sum_p=0^kβ_psum_j=0^pc_j^pfn-j\n=sum_j=0^ksum_p=j^kβ_pc_j^pfn-j\n=sum_j=0^kB_j^kfn-j","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the weights are given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"B_j^k=sum_p=j^kβ_pc_j^p\n=sum_p=j^k(-1)^jbinompjβ_p","category":"page"},{"location":"","page":"Home","title":"Home","text":"with j=0 k. In inner product form the expansion becomes","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_p=0^kβ_p^pfn\n=sum_j=0^k B_j^k fn-j\n=barB^k cdot fn-kn","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the weights vector barB^k  B_k^k B_0^k contains the weights in backward order.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general there is no simple symmetry relation between B^k and F^k.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Coefficients:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_expansion_weights(coeffs, bwd, rev)  barB^k  B_k^k B_0^k,","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the coeffs  β  β_0 β_k are user supplied to define the expansion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_expansion_weights(coeffs, notation=bwd, ordering=rev)\nfdiff_expansion(coeffs, f, notation=bwd)","category":"page"},{"location":"#CamiXon.fdiff_expansion_weights","page":"Home","title":"CamiXon.fdiff_expansion_weights","text":"fdiff_expansion_weights(coeffs[, notation=bwd[, ordering=rev]])\n\nExpansion weights corresponding to the expansion coefficients coeffs of a finite difference expansion.\n\nForward difference notation (notation = fwd)\n\nWeight vector F^k  F_k^k F_0^k corresponding to the expansion coefficients α  α_0^k α_k^k of the k^th-order forward-difference expansion,\n\nsum_p=0^kα_pΔ^pfn\n=sum_j=0^kF_j^kfn+j\n=F^k cdot fnn+k\n\nwhere fnn+k are elements of the analytic function f tabulated in forward order.\n\nfdiff_expansion_weights(α, fwd, reg)  F^k  F_0^k F_k^k,\n\nwhere α  α_0 α_k has to be supplied in combination with fwd to indicate that the weights must be evaluated in forward-difference notation.\n\nBackward difference notation (notation = bwd)\n\nWeight vector barB^k  B_k^k B_0^k corresponding to the expansion coefficients β  β_0 β_k of the k^th-order backward-difference expansion,\n\nsum_p=0^kβ_p^pfn\n=sum_j=0^kB_j^kfn-j\n=barB^k cdot fn-kn\n\nwhere fn-kn are elements of the analytic function f tabulated in forward order.\n\nfdiff_expansion_weights(β, bwd, rev)  barB^k  B_k^k B_0^k,\n\nwhere β  β_0 β_k has to be supplied in combination with bwd to indicate that the weights must be evaluated in backward-difference notation.\n\nExample:\n\nConsider the expansions,\n\nfn-1=(1+Δ)^-1fn=(1-Δ+Δ^2-Δ^3+)fn\n\nfn+1=(1-)^-1fn=(1++^2+^3+)fn\n\nα = [1,-1,1,-1,1]\nβ = [1,1,1,1,1]\nFk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\n  Fk = [5, -10, 10, -5, 1]\n\nBk = fdiff_expansion_weights(β, bwd, reg); println(\"Bk = $(Bk)\")\n  Bk = [5, -10, 10, -5, 1]\n\nrevFk = fdiff_expansion_weights(α, fwd, rev); println(\"revFk = $(revFk)\")\n  revFk = [1, -5, 10, -10, 5]\n\nrevBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\n  revBk = [1, -5, 10, -10, 5]\n\n\n\n\n\n","category":"function"},{"location":"#CamiXon.fdiff_expansion","page":"Home","title":"CamiXon.fdiff_expansion","text":"fdiff_expansion(coeffs, f[, notation=bwd])\n\nFinite difference expansion of the analytical function f(x) tabulated in forward order (growing index) at k+1 positions on a uniform grid. The expansion coefficients are specified by the vector coeffs. By default coeffs are assumed to be in backward-difference notation (bwd). For coeffs in forward-difference notation the third argument must be fwd.\n\nForward difference notation (notation = fwd)\n\nsum_p=0^kα_pΔ^pfn = F^k cdot fnn+k\n\nwhere fnn+k are elements of the analytical function f (tabulated in forward order) and α  α_0 α_k is the vector coeffs, which has to be supplied to define the forward-difference expansion. The corresponding weights vector F^k is internally generated.\n\nBackward difference notation (notation = bwd)\n\nsum_p=0^kβ_p^pfn = barB^k cdot fn-kn\n\nwhere fn-kn are elements of the analytical function f (tabulated in forward order) and β  β_0 β_k is the vector coeffs, which has to be supplied to define the backward-difference expansion. The corresponding weights vector barB^k is internally generated.\n\nExamples:\n\nConsider the function f(x)=x^2 and the expansions,\n\nf(x-1)=(1+Δ)^-1=(1-Δ+Δ^2-Δ^3+)f(x)\n\nf(x+1)=(1-)^-1=(1++^2+^3+)f(x)\n\nTo fourth order (k=4) the forward- and backward-difference coefficient vectors are α=[1,-1,1,-1,1] and β=[1,1,1,1,1], respectively. We tabulate the function at k+1 points, f=[1,4,9,16,25].\n\nα = [1,-1,1,-1,1]\nFk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\n  Fk = [5, -10, 10, -5, 1]\n\nβ = [1,1,1,1,1]\nrevBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\n  revBk = [1, -5, 10, -10, 5]\n\nf = [1,4,9,16,25]\no = fdiff_expansion(α, f, fwd); println(\"f[0] = $(o)\")\n  f[0] = 0\n\nfdiff_expansion(α, f, fwd) == Fk ⋅ f == fdiff_interpolation(f, 0)\n  true\n\no = fdiff_expansion(β, f, bwd); println(\"f[6] = $(o)\")\n  f[6] = 36\n\nfdiff_expansion(β, f, bwd) == revBk ⋅ f == fdiff_interpolation(f, length(f)+1)\n  true\n\nIn these cases the results are exact because the function is quadratic and the expansion is third order (based on the polynomial of k^th degree running through the k+1 points of the tabulated function). Note the relation with fdiff_interpolation(f, v, k=3).\n\n\n\n\n\n","category":"function"},{"location":"#Lagrange-polynomial-interpolation/extrapolation","page":"Home","title":"Lagrange-polynomial interpolation/extrapolation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Lagrange polynomial of degree k on a uniform grid is the polynomial running through k+1 subsequent points on the grid. We derive expressions for interpolation/extrapolation in both forward- and backward-difference notation. Beware that Lagrange interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree k.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Forward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Starting from the relation","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn=(1+Δ)fn+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"we obtain by formal operator inversion","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn+1 = (1 + Δ)^-1 fn equiv sum_p=0^infty(-1)^p Δ^p fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn+2 = (1 + Δ)^-2 fn equiv sum_p=0^infty(-1)^p pΔ^p fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"vdots","category":"page"},{"location":"","page":"Home","title":"Home","text":"where k is called the order of the expansion and n is the reference index. For interpolation position n-σ (where σ may be real valued in index units) these expansions can be generalized to the form of lagrangian interpolation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn-σ = (1 + Δ)^-σ fn equiv sum_p=0^infty α_p(σ) Δ^p fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"α_p(σ)  (-1)^p(σ)_pp","category":"page"},{"location":"","page":"Home","title":"Home","text":"is the p^th-order finite-difference expansion coefficient for lagrangian lagrangian interpolation over the interval -k σ 0  (n le n-σ le n+k),","category":"page"},{"location":"","page":"Home","title":"Home","text":"(σ)_p=begincases\n1  p=0\nσ(σ+1)(σ+2)cdots(σ+p-1)  p0\nendcases","category":"page"},{"location":"","page":"Home","title":"Home","text":"being the Pochhammer symbol CamiMath.pochhammer. For σ outside  the interpolation interval the method corresponds to extrapolation along the Lagrange polynomial. Evaluating the finite-difference expansion up to order k we obtain  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn-σ =sum_p=0^kα_p(σ)Δ^pfn\n=sum_j=0^kF_j^k(σ)fn+j\n=F^k(σ) cdot fnn+k","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the k+1 weights","category":"page"},{"location":"","page":"Home","title":"Home","text":"F_j^k(σ)= sum_p=j^k (-1)^k α_p(σ) c_j^p\n=sum_p=j^k (-1)^j binompj(σ)_pp","category":"page"},{"location":"","page":"Home","title":"Home","text":"are the lagrangian interpolation weights corresponding to the point fn-σ.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Symmetry relation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"barF^k(-k-σ) = F^k(σ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Weight functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_expansion_weights(coeffs, fwd, reg)  F^k(σ)  F^k_0(σ) F^k_k,","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the vector","category":"page"},{"location":"","page":"Home","title":"Home","text":"coeffs =fdiff_interpolation_expansion_coeffs(σ, k, fwd)  α(σ)  α_0(σ) α_k(σ)  contains the coefficients of the lagrangian-interpolation expansion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Backward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Starting from the relation","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn=(1-)fn+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"we obtain by formal operator inversion","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn+1 = (1 - )^-1 fn equiv sum_p=0^infty^p fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn+2 = (1 - )^-2 fn equiv sum_p=0^inftyp^p fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"vdots","category":"page"},{"location":"","page":"Home","title":"Home","text":"where k is called the order of the expansion and n is the reference index. For interpolation position n-σ (where σ may be real valued in index units) these expansions can be generalized to the form of lagrangian interpolation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn+σ = (1 - )^-σ fn equiv sum_p=0^infty β_p(σ) ^p fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"β_p(σ)  (σ)_pp = (-1)^p α_p(σ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"is the p^th-order finite-difference expansion coefficient for lagrangian interpolation over the interval -k σ 0  (n-k le n+σ le n), with","category":"page"},{"location":"","page":"Home","title":"Home","text":"(σ)_p=begincases\n1  p=0\nσ(σ+1)(σ+2)cdots(σ+p-1)  p0\nendcases","category":"page"},{"location":"","page":"Home","title":"Home","text":"being the Pochhammer symbol CamiMath.pochhammer. For σ outside  the interpolation interval the method corresponds to extrapolation along the Lagrange polynomial. Evaluating the finite-difference expansion up to order k we obtain","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn+σ =sum_p=0^kβ_p(σ)^pfn\n= sum_j=0^kB^k_j(σ)fn-j\n= barB^k(σ)  fn-kn","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the k+1 weights","category":"page"},{"location":"","page":"Home","title":"Home","text":"B^k_j(σ)= sum_p=j^k β_p(σ) c_j^p","category":"page"},{"location":"","page":"Home","title":"Home","text":"are the corresponding lagrangian interpolation weights.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Symmetry relations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"B^k(σ) = F^k(σ) = barB^k(-k-σ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"barB^k(σ) = B^k(-k-σ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Weight function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_expansion_weights(coeffs, bwd, rev)  barB^k(σ)  B_k^k(σ) B_0^k(σ),","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the vector","category":"page"},{"location":"","page":"Home","title":"Home","text":"coeffs =fdiff_interpolation_expansion_coeffs(σ, k=3, notation=bwd)  β(σ)  β_0(σ) β_k(σ) contains the coefficients of the lagrangian-interpolation expansion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_interpolation_expansion_coeffs(ξ::T, k=3, notation=bwd) where T<:Real\nfdiff_interpolation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}","category":"page"},{"location":"#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real","page":"Home","title":"CamiXon.fdiff_interpolation_expansion_coeffs","text":"fdiff_interpolation_expansion_coeffs(ξ::T [, k=3 [, notation=bwd]]) where T<:Real\n\nFinite-difference expansion coefficient vector defining the k^th-order (default third order) Lagrange-polynomial interpolation of a tabulated analytic function fn at offset ξ with respect to index position n, which is positive for increasing index and negative for decreasing index.\n\nForward difference notation (notation = fwd)\n\nIn this case we consider the tabulated interval fnn+k. The interpolated value fn+ξ is given by the forward-difference expansion\n\nfn+ξ = sum_p=0^k α_p(-ξ) Δ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_coeffs(ξ, k, fwd)  α(-ξ)  α_0(-ξ) α_k(-ξ). In this notation the range 0leq ξleq k corresponds to interpolation and the ranges ξ0 and ξk to extrapolation.\n\nBackward difference notation (notation = bwd)\n\nIn this case we consider the tabulated interval fn-kn. The interpolated value fn+ξ is given by the backward-difference expansion\n\nfn+ξ = sum_p=0^k β_p(ξ) ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_coeffs(ξ, k, bwd)  β(ξ)  β_0(ξ) β_k(ξ). In this notation the range -kleq ξleq0 corresponds to interpolation and the ranges ξ-k and ξ0 to extrapolation.\n\nExamples:\n\nk = 5\nξ = -1\nα = fdiff_interpolation_expansion_coeffs(ξ, k, fwd); println(\"α = $α\")\nβ = fdiff_interpolation_expansion_coeffs(ξ, k, bwd); println(\"β = $β\")\n  α = [1, 1, 0, 0, 0, 0]\n  β = [1, 1, 1, 1, 1, 1]\n\nξ = 0\nα = fdiff_interpolation_expansion_coeffs(ξ, k, fwd); println(\"α = $α\")\nβ = fdiff_interpolation_expansion_coeffs(ξ, k, bwd); println(\"β = $β\")\n  α = [1, 0, 0, 0, 0, 0]\n  β = [1, 0, 0, 0, 0, 0]\n\nξ = 1\nα = fdiff_interpolation_expansion_coeffs(ξ, k, fwd); println(\"α = $α\")\nβ = fdiff_interpolation_expansion_coeffs(ξ, k, bwd); println(\"β = $β\")\n  α = [1, -1, 1, -1, 1, -1]\n  β = [1, -1, 0, 0, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T<:Real, V<:Real}","page":"Home","title":"CamiXon.fdiff_interpolation","text":"fdiff_interpolation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}\n\nFinite difference lagrangian interpolation (by default third order) at real position v (in index units) with respect to the elements of the uniformly tabulated analytic function f[1:N]. The interpolation points lie on a Lagrange polynomial of degree k (by default third degree) running through k+1 subsequenct points of the tabulated function. Outside the tabulated range, the method represents extrapolation on the lagrangian polynomial defined by the first/last k+1 tabulated points.\n\nBeware that the interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree k.\n\nExamples:\n\nf = [1,2,3,4,5,6,7]\n[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]\n  [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0]\n\nf = [1,4,9,16,25,36,49]\n[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]\n [1.0, 2.25, 4.0, 6.25, 9.0, 12.25, 16.0, 20.25, 25.0, 30.25, 36.0, 42.25, 49.0]\n\n f = [x^3 for x=-4:2]\n f1(v) = fdiff_interpolation(f, v; k=1)\n f2(v) = fdiff_interpolation(f, v; k=2)\n f3(v) = fdiff_interpolation(f, v; k=3)\n [[f1(v),f2(v),f3(v)] for v=1:0.5:9]\n   [[-64.0, -64.0, -64.0], [-45.5, -43.25, -42.875], [-27.0, -27.0, -27.0],\n   [-17.5, -16.0, -15.625], [-8.0, -8.0, -8.0], [-4.5, -3.75, -3.375],\n   [-1.0, -1.0, -1.0], [-0.5, -0.5, -0.125], [0.0, 0.0, 0.0],\n   [0.5, -0.25, 0.125], [1.0, 1.0, 1.0], [4.5, 3.75, 3.375], [8.0, 8.0, 8.0],\n   [11.5, 13.75, 15.625], [15.0, 21.0, 27.0], [18.5, 29.75, 42.875],\n   [22.0, 40.0, 64.0]]\n\nThe result for f3(v) is exact because the function is cubic and the expansion is third order - see Figure below. The tabulated function is given by the black points. The interpolation and extrapolation points are red.\n\n(Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#Lagrangian-differentiation","page":"Home","title":"Lagrangian differentiation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To derive the lagrangian differentiation formulas we formally differentiate","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn+x = (1 - )^-x fn","category":"page"},{"location":"","page":"Home","title":"Home","text":"with respect to x.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracdfdxn+x\n=-ln(1-) (1-)^-xfn\n=sum_q=1^ktfrac1q^qsum_p=0^kl_p(x)^pfn+","category":"page"},{"location":"","page":"Home","title":"Home","text":"Rewriting the r.h.s. as a single summation in powers of  for given values of n and x we obtain an expression of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracdfdxn+x=sum_p=1^kβ_p(x)^pfn+","category":"page"},{"location":"","page":"Home","title":"Home","text":"where β_p(x) represents the finite-difference expansion coefficients for lagrangian differentiation at position n+x. These coefficients are determined numerically by polynomial multiplication. As the expansion algorith requires the presentce of a β_0(x) coefficient we add a (vanishing) p=0 term, β_0(x)equiv 0. The corresponding coefficient vector is given by fdiff_differentiation_expansion_coeffs(k,x). Evaluating the finite-difference expansion up to order k we obtain","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracdfdxn+x\n=sum_p=0^kβ_p(x)^pfn\n=sum_j=0^kB_j^k(x)fn-j\n=B^k(x)  fn-1n-k","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the k+1 weights","category":"page"},{"location":"","page":"Home","title":"Home","text":" B_j^k(x)=sum_p=j^kβ_p(x)c_j^p","category":"page"},{"location":"","page":"Home","title":"Home","text":"are the k^th-order lagrangian differentiation weights. After changing dummy index to reverse the summation the expansion becomes","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracdfdxn+x\n=sum_j=0^kbarB^k_j(x)fn-k+j\n=barB^k(x)  fn-kn","category":"page"},{"location":"","page":"Home","title":"Home","text":"Functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_expansion_weights(β, bwd, reg)  B^k(x)  B^k_0(x) B^k_k(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_expansion_weights(β, bwd, rev)  barB^k(x)  B^k_k(x) B^k_0(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_differentiation_expansion_coeffs(o, k)  β  β_0(x) β_k(x).","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_differentiation_expansion_coeffs(ξ::T, k=3) where T<:Real\nfdiff_differentiation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}\ncreate_lagrange_differentiation_matrix(k::Int)","category":"page"},{"location":"#CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T<:Real","page":"Home","title":"CamiXon.fdiff_differentiation_expansion_coeffs","text":"fdiff_differentiation_expansion_coeffs(ξ::T [, k=3 [, notation=bwd]]) where T<:Real\n\nFinite-difference expansion coefficient vector defining k^th-order lagrangian differentiation of the tabulated analytic function fn at offset ξ (with respect to index position n), which is positive for increasing index and negative for decreasing index.\n\nForward difference notation (notation = fwd)\n\nfracdfdξn+ξ=sum_p=0^kα_p(ξ)Δ^pfn\n\nOffset convention: ξ = -σ with respect to index n in tabulated interval fnn+k\n\nBackward difference notation (notation = bwd)\n\nfracdfdξn+ξ=sum_p=0^kβ_p(ξ)^pfn\n\nwhere β(ξ)  β_0(ξ)  β_p(ξ)\n\nOffset convention: ξ = σ with respect to index n in tabulated interval fn-kn\n\nExample:\n\nk = 2; ξ = 0\no = fdiff_differentiation_expansion_coeffs(ξ, k); println(o)\n [0.0, 1.0, -1.5]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.fdiff_differentiation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T<:Real, V<:Real}","page":"Home","title":"CamiXon.fdiff_differentiation","text":"fdiff_differentiation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}\n\nk^th-order (default third order) lagrangian differentiation of the analytic function f, tabulated in forward order on a uniform grid.\n\nExample:\n\nf = [x^3 for x=-5:5]; println(round.(Int,f))\nl = length(f)\nf′ = [fdiff_differentiation(f, v) for v=1:l]; println(round.(Int,f′))\n  [-125, -64, -27, -8, -1, 0, 1, 8, 27, 64, 125]\n  [75, 48, 27, 12, 3, 0, 3, 12, 27, 48, 75]\n\nf′= fdiff_differentiation(f, 1) ; println(\"f′(1) = $(f′))\n  f′(1) = 75//1\n\nf′= fdiff_differentiation(f, 6.5) ; println(\"f′(6.5) = $(f′)\")\n    f′(6.5) = 0.75\n\nFor a cubic function the third-order lagrangian differentiation is exact - see Figure below.\n\n(Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}","page":"Home","title":"CamiXon.create_lagrange_differentiation_matrix","text":"create_lagrange_differentiation_matrix(k::Int)\n\nLagrange differentiation matrix, mij=s_k-j^k(i), for k^th-order lagrangian differentiation,\n\nfracdydxi= sum_j=0^kmijyj\n\nExample:\n\nk = 3\ncreate_lagrange_differentiation_matrix(k)\n 4×4 Matrix{Rational{Int64}}:\n  -11//6   3//1  -3//2   1//3\n   -1//3  -1//2   1//1  -1//6\n    1//6  -1//1   1//2   1//3\n   -1//3   3//2  -3//1  11//6\n\n\n\n\n\n","category":"method"},{"location":"#Integration","page":"Home","title":"Integration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"trapezoidal_epw(k::Int; rationalize=false, devisor=false)\ntrapezoidal_integration(f, x1, x2, weights)","category":"page"},{"location":"#CamiXon.trapezoidal_epw-Tuple{Int64}","page":"Home","title":"CamiXon.trapezoidal_epw","text":"trapezoidal_epw(k::Int [; rationalize=false [, devisor=false]])\n\nEndpoint weights vector a=a_1 a_k of trapeziodal rule optimized for functions of polynomial form,\n\n    _0^n f(x) dx = a_1 (f_0+f_n) +  + a_k (f_k-1+f_n-k+1)\n                                                         + (f_k++f_n-k)\n\nwhere k is odd. The rule is exact for polynonials of degree d=0 1  k-1. For k=1 the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.\n\nExample:\n\n[trapezoidal_epw(k; rationalize=true, devisor=true) for k=1:2:9]\n5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n  (1, 2, [1])\n  (3, 24, [9, 28, 23])\n  (5, 1440, [475, 1902, 1104, 1586, 1413])\n  (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])\n  (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922,\n                                                     5095890, 7783754, 7200319])\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.trapezoidal_integration-NTuple{4, Any}","page":"Home","title":"CamiXon.trapezoidal_integration","text":"trapezoidal_integration(f, x1, x2, weights)\n\nIntegral of the tabulated function f=f_0 f_n over the domain x1  x  x2 using the optimized trapezoidal rule with endpoint correction by the weights vector weights,\n\n    _0^n f(x) dx = a_1 (f_0+f_n) +  + a_k (f_k-1+f_n-k+1)\n                                                         + (f_k++f_n-k)\n\nThe rule is exact for polynonials of degree d=0 1 k-1. For k=1 the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).\n\nExamples::\n\np = 3\nc = [1 for i=0:p]\npol = ImmutablePolynomial(c,:z)\nIpol = integrate(pol)\nn = 10\n\nx1=0.0\nx2=5.0\nx = collect(range(x1, x2, n))\nf = pol.(x .-2.5)\n\nw3 = trapezoidal_epw(3)\ntrapezoidal_integration(f, x1, x2, w3)\n 15.416666666666673\n\nIpol(2.5)-Ipol(-2.5)\n 15.41666666666666\n\n\n\n\n\n","category":"method"},{"location":"#Adams-Method","page":"Home","title":"Adams Method","text":"","category":"section"},{"location":"#Adams-Bashford-expansion","page":"Home","title":"Adams-Bashford expansion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Adams-Bashford integration step is given by the expansion","category":"page"},{"location":"","page":"Home","title":"Home","text":"yn+1-yn = -frach (1-)ln(1-)fn+1=h (sum_p=0^inftyB_p^p)fn+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"A closed expression for the Adams-Bashford expansion coefficients, B_k, is not available. As we already have a finite-difference expansion for the operator (1-)^-1,","category":"page"},{"location":"","page":"Home","title":"Home","text":"frac11-equivsum_p=0^infty^p","category":"page"},{"location":"","page":"Home","title":"Home","text":"we ask for the expansion of","category":"page"},{"location":"","page":"Home","title":"Home","text":"-fracln(1-)\n=(1-frac12-frac124^2-frac112^3+)fn+1\n= (sum_p=0^inftyb_p^p)fn+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is known as the Adams-Moulton expansion. Its coefficients are calculated numerically by the function fdiff_expansion_adams_moulton_coeffs(k). The Adams-Bashford expansion is obtained as the polynomial product of the two expansions,","category":"page"},{"location":"","page":"Home","title":"Home","text":"(sum_p=0^inftyB_p^p)fn+1\n=(sum_p=0^infty^p)(sum_p=0^inftyb_p^p)fn+1\n= ( 1 + frac12 + frac512^2 + )fn+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"The coefficients B_p are calculated numerically with the function fdiff_expansion_adams_bashford_coeffs(k). Evaluating the finite-difference expansion up to order k we obtain (after changing dummy index bring the summation in forward order)","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_p=0^kB_p^pfn\n=sum_p=0^kB_psum_j=0^p c_j^ifn-j\n= sum_j=0^kA_j^k(x)fn-j\n= sum_j=0^kA_k-j^k(x)fn-k+j","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the A_j^k(x)= sum_p=j^k B_pc_j^p are the (k+1)-point Adams-Bashford integration weights.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"β = fdiff_adams_bashford_expansion_coeffs(k)   B_k^k(x) B_0^k(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"adams_bashford_integration_weights = fdiff_expansion_weights(β, bwd, rev)   A_k^k(x) A_0^k(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_adams_bashford_expansion_coeffs(k::Int)","category":"page"},{"location":"#CamiXon.fdiff_adams_bashford_expansion_coeffs-Tuple{Int64}","page":"Home","title":"CamiXon.fdiff_adams_bashford_expansion_coeffs","text":"fdiff_adams_bashford_expansion_coeffs(k [; T=Int])\n\n(k+1)-point Adams-Bashford expansion coefficients B_p.\n\n-frac(1-)ln(1-)=sum_p=0^inftyB_p^p=1+ frac12+ frac512^2+ \n\nThe weights are stored in forward order: B_0^k B_k^k - order of use in summation.\n\nExamples:\n\nk = 5\no = fdiff_adams_bashford_expansion_coeffs(k); println(o)\n Rational{Int64}[1//1, 1//2, 5//12, 3//8, 251//720, 95//288]\n\n\n\n\n\n","category":"method"},{"location":"#Adams-Moulton-expansion","page":"Home","title":"Adams-Moulton expansion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Adams-Moulton integration step is given by the expansion","category":"page"},{"location":"","page":"Home","title":"Home","text":"yn+1-yn\n= -fracln(1-)fn+1\n= ( 1 - frac12 - frac112^2 - frac124^3 +)fn+1","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the evaluation of the integration step we limit the summation to k+1 terms (order k),","category":"page"},{"location":"","page":"Home","title":"Home","text":"yn+1-yn= (sum_p=0^kb_p^p)fn+1+","category":"page"},{"location":"","page":"Home","title":"Home","text":"where b_0 b_k are the Adams-Moulton expansion coefficients, rational numbers generated numerically by the function fdiff_adams_moulton_expansion_coeff(k). Extracting the greatest common denominator, 1D, the step becomes","category":"page"},{"location":"","page":"Home","title":"Home","text":"yn+1-yn= frac1D(sum_p=0^kb_p^prime^p)fn+1+","category":"page"},{"location":"","page":"Home","title":"Home","text":"where b_0^prime b_k^prime are integers and b_p=b_p^primeD. In practice the expansion is restricted to k18 (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to k = 10). Evaluating the finite-difference expansion up to order k we obtain (after changing dummy index bring the summation in forward order)","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_p=0^kb_p^pfn\n=sum_p=0^kb_psum_j=0^p c_j^ifn-j\n= sum_j=0^ka_j^k(x)fn-j\n= sum_j=0^ka_k-j^k(x)fn-k+j","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the a_j^k(x)= sum_p=j^k b_pc_j^p are the (k+1)-point Adams-Moulton integration weights.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"β = fdiff_adams_moulton_expansion_coeff(k)  b_0 b_k","category":"page"},{"location":"","page":"Home","title":"Home","text":"adams_moulton_weights = fdiff_expansion_weights(β, bwd, rev)  a_k^k a_0^k.","category":"page"},{"location":"","page":"Home","title":"Home","text":"adams_moulton_weights = create_adams_moulton_weights(k)  a_k^k a_0^k","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiff_adams_moulton_expansion_coeff(n::T; msg=true) where {T<:Integer}\ncreate_adams_moulton_weights(k::Int; rationalize=false, devisor=false, T=Int)","category":"page"},{"location":"#CamiXon.fdiff_adams_moulton_expansion_coeff-Tuple{T} where T<:Integer","page":"Home","title":"CamiXon.fdiff_adams_moulton_expansion_coeff","text":"fdiff_adams_moulton_expansion_coeff(n::T; msg=true) where {T<:Integer}\nfdiff_adams_moulton_expansion_coeffs(n::T; msg=true) where {T<:Integer}\n\nFinite difference expansion coefficient vector β  β_0(x)  β_p(x) defining k^th-order Adams-Moulton expansion,\n\n-fracln(1-)\n= sum_p=0^inftyβ_p^p\n= 1 - frac12 - frac112^2 - frac124^3 +\n\nExamples:\n\njulia> k = 5;\njulia> β = fdiff_adams_moulton_expansion_coeffs(k); println(β)\nRational{Int64}[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]\n\njulia> D = denominator(gcd(β))\n1440\n\njulia> o = convert(Vector{Int},(β .* D)); println(o)\n[1440, -720, -120, -60, -38, -27]\n\njulia> k=20;\njulia> fdiff_adams_moulton_expansion_coeff(k)\nInteger-overflow protection: output converted to BigInt\n-12365722323469980029//4817145976189747200000\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.create_adams_moulton_weights-Tuple{Int64}","page":"Home","title":"CamiXon.create_adams_moulton_weights","text":"create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])\n\nk^th-order Adams-Moulton weights vector,\n\nyn+1 = yn + frac1Dsum_j=0^ka^kjfn+1-k+j\n\nThe weights are stored in the vector a^k equiva_k^kD a_0^kD under the convention a^kj equiv a_k-j^kD, where a_j^k are the Adams-Moulton weight coefficients and D the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational,  with or without specification of the gcd devisor.\n\nExample:\n\n[create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:8]\n8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n (1, 2, [1, 1])\n (2, 12, [-1, 8, 5])\n (3, 24, [1, -5, 19, 9])\n (4, 720, [-19, 106, -264, 646, 251])\n (5, 1440, [27, -173, 482, -798, 1427, 475])\n (6, 60480, [-863, 6312, -20211, 37504, -46461, 65112, 19087])\n (7, 120960, [1375, -11351, 41499, -88547, 123133, -121797, 139849, 36799])\n (8, 3628800, [-33953, 312874, -1291214, 3146338, -5033120, 5595358, -4604594, 4467094, 1070017])\n\n\n\n\n\n","category":"method"},{"location":"#Strings","page":"Home","title":"Strings","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"sup(i::T) where T<:Real\nsub(i::T) where T<:Real\nfrac(i::Rational{Int})\nstrRational(n::T) where T<:Union{Rational{}, Int, BigInt}","category":"page"},{"location":"#CamiXon.sup-Tuple{T} where T<:Real","page":"Home","title":"CamiXon.sup","text":"sup(i::T) where T<:Real\n\nSuperscript notation for integers and rational numbers\n\nExamples:\n\nsup(3) * 'P'\n \"³P\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.sub-Tuple{T} where T<:Real","page":"Home","title":"CamiXon.sub","text":"sub(i::T) where T<:Real\nsub(str::String)\n\nSubscript notation for integers, rational numbers and a subset of lowercase characters ('a','e','h','k','l','m','n','o','p','r','s','t','x')\n\nExamples:\n\n'D' * sub(5//2)\n \"D₅⸝₂\"\n\n\"m\" * sub(\"e\")\n \"mₑ\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.frac-Tuple{Rational{Int64}}","page":"Home","title":"CamiXon.frac","text":"frac(i)\n\nFraction notation for rational numbers\n\nExamples:\n\nfrac(-5//2)\n \"-⁵/₂\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.strRational-Tuple{T} where T<:Union{Int64, BigInt, Rational}","page":"Home","title":"CamiXon.strRational","text":"strRational(i)\n\nFraction notation for rational numbers and integers\n\nExamples:\n\nstrRational(-5//2)\n \"-5/2\"\n\n strRational(-5//2)\n  \"-5\"\n\n\n\n\n\n","category":"method"},{"location":"#Dicts","page":"Home","title":"Dicts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"dictAntoineCoefficients\ndictAtomicNumbers\ndictBigConversion\ndictElements\ndictIsotopes","category":"page"},{"location":"#CamiXon.dictAntoineCoefficients","page":"Home","title":"CamiXon.dictAntoineCoefficients","text":"dictAntoineCoefficients\n\nAntoine coefficients [A,B,C,D] for temperature ranges below and above the melting point. These coefficients are used in the Antoine equation to calculate the saturated vapor pressure p (in Pa) for metalic elements at temperature `T (in K),\n\nmathrmlnp=A+BT+Cmathrmlog_10T+Dcdot T1000\n\nThe quantity\n\nL(T) = B +Ccdot T mathrmlog_10T+Dcdot T^21000\n\nis the latent heat of vaporization (in Joule/K) at temperature T.\n\nCurrently, only the coefficients for the metalic elements are implemented - see C. B. Alcock, V. P. Itkin and M. K. Horrigan, Canadian Metallurgical Quarterly, 23, 309 (1984).\n\nExamples:\n\njulia> dictAntoineCoefficients\nDict{Int64, Tuple{Any, Any, Tuple{Any, Any, Any}}} with 102 entries:\n  5  => (nothing, nothing, (empty, 2349.0, empty))\n  56 => ([40.0897, -22312.0, -5.27062, 0.0], [20.7526, -18796.0, 0.0, 0.0], (298.0, 1000.0, 1200.0))\n  35 => (nothing, nothing, (empty, 265.8, empty))\n  55 => ([22.3736, -9208.04, 0.0, 0.0], [21.1164, -8818.9, 0.0, 0.0], (298.0, 301.7, 550.0))\n  60 => ([32.2402, -39751.8, -2.19183, 0.0], [22.8364, -36436.1, 0.0, 0.0], (298.0, 1297.0, 2000.0))\n  30 => ([25.5765, -15602.3, 0.0, 0.0], [23.9094, -14474.0, 0.0, 0.0], (298.0, 692.68, 750.0))\n  32 => (nothing, nothing, (empty, 1211.4, empty))\n  ⋮  => ⋮\n\nTo calculate the saturated vapor pressure of Li (in Pa) at T=623 K we use\n\njulia> svp(\"Li\", 623.0, dictAntoineCoefficients)\n0.0015230367024569058\n\n\n\n\n\n","category":"constant"},{"location":"#CamiXon.dictAtomicNumbers","page":"Home","title":"CamiXon.dictAtomicNumbers","text":"dictAtomicNumbers\n\njulia> dictAtomicNumbers\nDict{String, Int64} with 102 entries:\n  \"Pd\" => 46\n  \"Si\" => 14\n  \"C\"  => 6\n  \"P\"  => 15\n  \"Nb\" => 41\n    ⋮  =>  ⋮\n\njulia> Z = get(dictAtomicNumbers, \"Rb\", nothing)\n37\n\njulia> listElement(Z; fmt=Info)\nElement: rubidium\nsymbol: Rb\natomic number: Z = 37\natomic weight (relative atomic mass): 85.468\n\n\n\n\n\n","category":"constant"},{"location":"#CamiXon.dictBigConversion","page":"Home","title":"CamiXon.dictBigConversion","text":"dictBigConversion\n\nDictionary for conversion from Int-based types to BigInt-based types\n\nExample:\n\njulia> dictBigConversion\nDict{DataType, DataType} with 12 entries:\n  Vector{Rational{Int64}}         => Vector{Rational{BigInt}}\n  Int64                           => BigInt\n  Vector{Float64}                 => Vector{BigFloat}\n  ComplexF64                      => Complex{BigFloat}\n  Vector{Vector{ComplexF64}}      => Vector{Vector{Complex{BigFloat}}}\n  Vector{Int64}                   => Vector{BigInt}\n  Vector{Vector{Int64}}           => Vector{Vector{BigInt}}\n  Vector{Vector{Float64}}         => Vector{Vector{BigFloat}}\n  Vector{Vector{Rational{Int64}}} => Vector{Vector{Rational{Int64}}}\n  Float64                         => BigFloat\n  Rational{Int64}                 => Rational{BigInt}\n  Vector{ComplexF64}              => Vector{Complex{BigFloat}}\n\n\n\n\n\n","category":"constant"},{"location":"#CamiXon.dictElements","page":"Home","title":"CamiXon.dictElements","text":"dictElements\n\nSource:  Standard atomic weights of the elements 2021 (IUPAC Technical Report)\n\nExample:\n\njulia> dictElements\nDict{Int64, Tuple{String, String, Any}} with 102 entries:\n  5  => (\"boron\", \"B\", 10.81)\n  56 => (\"barium\", \"Ba\", 137.33)\n  35 => (\"bromine\", \"Br\", 79.904)\n  55 => (\"caesium\", \"Cs\", 132.91)\n  60 => (\"neodymium\", \"Nd\", 144.24)\n  30 => (\"zinc\", \"Zn\", 65.38)\n   ⋮ =>            ⋮\n\njulia> get(dictElements, 37, nothing)\n(\"rubidium\", \"Rb\", 85.468)\n\n\n\n\n\n","category":"constant"},{"location":"#CamiXon.dictIsotopes","page":"Home","title":"CamiXon.dictIsotopes","text":"dictIsotopes\n\nSources: AME2020, LINDC(NDS)-0794 and INDC(NDS)-0833\n\nExample:\n\njulia> dictIsotopes\nDict{Tuple{Int64, Int64}, Tuple{String, String, Int64, Int64, Int64, Float64, Float64, Real, Int64, Float64, Float64, Any, Any}} with 341 entries:\n  (71, 175) => (\"¹⁷⁵Lu\", \"lutetium\", 71, 175, 104, 5.37, 174.941, 7//2, 1, 1.0e…\n  (40, 92)  => (\"⁹²Zr\", \"zirconium\", 40, 92, 52, 4.3057, 91.905, 0, 1, 1.0e100,…\n  (48, 111) => (\"¹¹¹Cd\", \"cadmium\", 48, 111, 63, 4.5845, 110.904, 1//2, 1, 1.0e…\n  (72, 176) => (\"¹⁷⁶Hf\", \"hafnium\", 72, 176, 104, 5.3286, 175.941, 0, 1, 1.0e10…\n  (30, 68)  => (\"⁶⁸Zn\", \"zinc\", 30, 68, 38, 3.9658, 67.9248, 0, 1, 1.0e100, 0.0…\n  (76, 184) => (\"¹⁸⁴Os\", \"osmium\", 76, 184, 108, 5.3823, 183.952, 0, 1, 5.6e13,…\n  (54, 129) => (\"¹²⁹Xe\", \"xenon\", 54, 129, 75, 4.7775, 128.905, 1//2, 1, 1.0e10…\n      ⋮     =>                                ⋮\n\njulia> get(dictIsotopes, (37,87), nothing)\n(\"⁸⁷Rb\", \"rubidium\", 37, 87, 50, 4.1989, 86.90918053, 3//2, -1, 4.97e10, 2.75129, 0.1335, 27.83)\n\n\n\n\n\n","category":"constant"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
