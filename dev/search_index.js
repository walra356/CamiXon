var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CamiXon","category":"page"},{"location":"#CamiXon.jl","page":"Home","title":"CamiXon.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for image analysis of backscattered light","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CamiXon is a package for the numerical solution of the radial Schrödinger equation allowing for screening. In Hartree atomic units (a.u.) the equation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Numerical methods are indispensable for the structure analysis of many-electron atoms. We have selected a numerical solution of de radial wave equation for the case of a single electron in the central potential field of a many electron atom. Along with more advanced methods examples like this can be found in the book \\emph{Atomic Structure Theory} by Walter R.\\,Johnson \\cite{Johnson}.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our starting point is the 1D Schrödinger equation for one electron, acting as a spectator in the atomic central field in the presence screening by the other electrons (the screening electrons). In Hartree atomic units (a.u.) this equation is given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"tildechi_l^primeprime+2leftZ_mathrmeff(rho)rho-l(l+1)2rho^2+varepsilon_lrighttildechi_l=0\n\nwhere tildechi_l(rho)=rhotildeR_l(rho) is the reduced\nradial wavefunction and varepsilon_l=-kappa_l^2 is the\ncorresponding binding energy in Hartree atomic units As compared\nto the hydrogenic case - see Eq(ref1D-SchrodingerEquation-2)\n- the atomic number has been replaced by Z_mathrmeff(rho)\nthe empheffective nuclear charge at distance rho from the atomic\ncenterindexEffectivenuclear chargeindexNuclearchargeeffective\nIn other words the energy of the electron in the Coulomb field of\nthe nucleus -Zrho is replaced by a central potential\nU_mathrmCF(rho)=-Z_mathrmeff(rho)rho\ncomposed of the bare Coulomb contribution and the screening energy\nU_mathrmscr(rho)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math Z{\\mathrm{eff}}(\\rho)/\\rho=Z/\\rho-U{\\mathrm{scr}}(\\rho),","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwith boundary conditions $U_{\\mathrm{scr}}(0)=Z$ and\n$\\mathrm{lim}_{\\rho\\rightarrow\\infty}U_{\\mathrm{scr}}(\\rho)=Z_{c}/\\rho$\n- see e.g.~Fig.\\,\\ref{fig:h.1.he}. Here $Z$ is the atomic number\nand $Z_{c}$ the Rydberg charge. Within these boundary conditions\nwe can optimize the central potential while preserving the bare Coulomb\nfield close to the nucleus and the Rydberg potential in the far field.\nThe price we pay is that the radial Schrödinger\nequation has to be solved numerically by radial integration. Our strategy will\nbe to use both *inward* and *outward* integration and match\nthe two branches by *equating the two solutions* for the *wavefunction*\nand its *derivative* at a point near the classical turning point\nof the radial motion.\n\n\n![Image](./assets/H1_3d.png)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math y[n+1]-y[n] = -\\frac{h \\nabla}{(1-\\nabla)ln(1-\\nabla)}f[n+1]=h (\\sum{p=0}^{\\infty}Bp\\nabla^p)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Codata\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs Codata Value strValue(f::Value) NamedValue castNamedValue(val::Value; name=\" \", comment=\" \") castCodata(year::Int) listCodata(codata::Codata) convertUnit(val, codata::Codata; unitIn=\"Hartree\", unitOut=\"xHz\") myconvert(T::Type, val::V) where V <: Number calibrationReport(E, Ecal, codata::Codata; unitIn=\"Hartree\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Atomic properties\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs Atom castAtom(;Z=1, Q=0, M=1.0, I=1//2, gI=5.5, msg=true) Orbit castOrbit(;n=1, ℓ=0, msg=true) SpinOrbit createSpinOrbit(o::Orbit; up=true, msg=true) Term createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true) bohrformula(Z::Int, n::Int) mendeleev(Z::Int)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Adams-Moulton integration\n\nThe Adams-Moulton method is used for numerical integration of the reduces\nradial wave equation. In the present implementation it is constructed on top\nthe objects [`Atom`](@ref), [`Orbit`](@ref), [`Grid`](@ref), [`Def`](@ref)\nand [`Adams`](@ref) using 5 globally defined instances called `atom`, `orbit`,\n`grid`, `def` and `adams`.\n\n### Pos\n\nThe `Pos` object serves within [`Def`](@ref) object to contain the position\nindices `def.Na`, `def.Nb`, `def.Nlctp`, `def.Nmin`, `def.Nuctp` used in\nAdams-Moulton integration. These positions are contained in the fields\n`def.pos.Na`, `def.pos.Nb`, `def.pos.Nlctp`, `def.pos.Nmin`, `def.pos.Nuctp`.\nAlternatively, they can be determined with the functions [`get_Na`](@ref),\n[`get_Nb`](@ref), [`get_Nlctp`](@ref), [`get_Nmin`](@ref), [`get_Nuctp`](@ref).","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs Pos","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Def\n\nThe `Def` object serves to define the problem to be solved and to contain in\nthe field `def.Z` the solution as a discrete function of `N` elements.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs Def{T} castDef(grid::Grid{T}, atom::Atom, orbit::Orbit) where T <: Real initE(def::Def{T}; E=nothing) where T<:Real getNa(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real getNb(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real getNlctp(E::T, def::Def{T}) where T<:Real getNmin(def::Def{T}) where T<:Real getNuctp(E::T, def::Def{T}) where T<:Real getnodes(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs matG(E::T, grid::Grid{T}, def::Def{T}) where T<:Real matσ(E::T, grid::Grid{T}, def::Def{T}) where T<:Real matMinv(E::T, grid::Grid{T}, def::Def{T}, amEnd::T) where T<:Real OUTSCH(grid::Grid{T}, def::Def{T}, σ::Vector{Matrix{T}}) where T<:Real OUTSCH_WKB(E::T, grid::Grid{T}, def::Def{T}) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Adams\n\nThe `Adams` object serves to hold the Adams-Moulton integration matrices\n`matG`, `matσ`, `matMinv` as well as the *actual* normalized solution `Z` in\nthe form of a tabulated function of `N` elements.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs Adams castAdams(E::T, grid::Grid{T}, def::Def{T}) where T<:Real updateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T<:Real INSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real adamsmoultoninward(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real adamsmoultonoutward(def::Def{T}, adams::Adams{T}) where T<:Real adamsmoultonnormalized(Z::Vector{Complex{T}}, ΔQ::T, grid::Grid{T}, def::Def{T}) where T<:Real solveadamsmoulton(E::T, grid::Grid{T}, def::Def{T}, adams::Adams) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Grid\n\nThe `Grid` object is the backbone for the numerical procedure on a non-uniform\ngrid. Its principal fields are `grid.r` and `grid.r′`, which are discrete\nfunctions of `N` elements representing the grid function and its derivative.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs Grid{T} gridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T <: Real castGrid(ID::Int, N::Int, T::Type; h=1, r0=0.001,  p=5, coords=[0,1], epn=7, k=7, msg=true) autoRmax(atom::Atom, orbit::Orbit) autoNtot(orbit::Orbit) autoPrecision(Rmax::T, orbit::Orbit) where T<:Real autoSteps(ID::Int, Ntot::Int, Rmax::T; p=5, coords=[0,1]) where T<:Real autoGrid(atom::Atom, orbit::Orbit, codata::Codata, T::Type ; p=0, coords=[], Nmul=1, epn=7, k=7, msg=true) gridlagrangederivative(f::Vector{T}, grid::Grid{T}; k=5) where T<:Real gridtrapezoidalintegral(f::Vector{T}, n1::Int, n2::Int, grid::Grid{T}) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## FITS\n\nFITS stands for 'Flexible Image Transport System'. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.\n\nWithin CamiXon only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.\n\nA FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.\n\nBy the command `f = fits_read(filnam)` we asign a collection of `FITS_HDU` objects from the file `filnam` to the variable `f`.\n\n### FITS - Types\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs FITSHDU{T,V} FITSheader FITSdata FITStable FITS_name","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### FITS - HDU Methods\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fitsinfo(hdu::FITSHDU) parseFITSTABLE(hdu::FITS_HDU)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### FITS - File Methods\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs castFITSname(filename::String) fitscombine(filnamFirst::String, filnamLast::String; protect=true) fitscopy(filenameA::String, filenameB::String=\" \"; protect=true) fitscreate(filename::String, data=[]; protect=true) fitsextend(filename::String, dataextend, hdutype=\"IMAGE\") fitsread(filename::String)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### FITS - Key Methods\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fitsaddkey(filename::String, hduindex::Int, key::String, val::Real, com::String) fitsdeletekey(filename::String, hduindex::Int, key::String) fitseditkey(filename::String, hduindex::Int, key::String, val::Real, com::String) fitsrenamekey(filename::String, hduindex::Int, keyold::String, keynew::String)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## FORTRAN\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs FORTRANformat castFORTRANformat(str::String) castFORTRAN_datatype(str::String)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Plotting\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs step125(x::Real) select125(x) steps(x::Vector{T} where T<:Real) stepcenters(x::Vector{T} where T<:Real) stepedges(x::Vector{T} where T<:Real) edges(px, Δx=1.0, x0=0.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Search and conversion tools\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs findall(A::Union{String,AbstractArray{T,1}}, a::T...; count=false)  where T findfirst(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T find_last(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Math\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs bernoullinumbers(nmax::Int) canonicalpartitions(n::Int, m=0; header=true, reverse=true) faulhaberpolynom(p::Int) faulhabersummation(n::Int, p::Int; T=Int) harmonicnumber(n::Int, p::Int) harmonicnumber(n::Int) integerpartitions(n::Int, m=0; transpose=false, count=false) log10characteristicpower(x) log10mantissa(x) permutationsuniquecount(p::Array{Array{Int64,1},1}, i::Int) pascaltriangle(nmax::Int) pascalnext(a::Vector{Int}) polynomial(coords::Vector{T}, x::T; deriv=0) where T<:Number polynomderivative(coords::Vector{<:Number}) polynomderivatives(coords::Vector{<:Number}; deriv=0) polynomderivativesall(coords::Vector{<:Number}) polynompower(coords::Vector{<:Number}, power::Int) polynompowers(coords::Vector{<:Number}, pmax::Int) polynomprimitive(coeffs::Vector{<:Number}) polynomproduct(a::Vector{T}, b::Vector{T}) where T<:Number polynomproductexpansion(a::Vector{T}, b::Vector{T}, p::Int) where T<:Number texp(x::T, a::T, p::Int) where T <: Real VectorRational normalize_VectorRational(vec::Vector{Rational{Int}})","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Finite-difference methods\n\n### Finite differences\n\nConsider the analytic function ``f`` tabulated in *forward order*  (growing index) at ``n`` positions on a *grid*. The *finite difference* of two adjacent values on a *uniform grid* is defined by the relation\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\nabla f[n] = f[n]-f[n-1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nThis is called the finite difference in *backward difference* notation. In this notation the  ``k^{th}``-*order backward difference* (which involves ``k+1`` points) is defined by a *weighted sum* over the function values in backward order, ``f[n],\\ \\ldots,\\ f[n-k]``,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\nabla^k f[n] = f[n] + c1^kf[n-1] + \\cdots + ck^kf[n-k] = \\sum{j=0}^{k} cj^kf[n-j].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nThe ``k+1`` coefficients ``c_{j}^{k}=(-1)^{j}\\binom{k}{j}`` are *weight factors* (short: *weights*) defining the summation. Note that ``c_{0}^{k}\\equiv1`` and ``c_{k}^{k}=(-1)^{k}``. As the function ``f`` is tabulated in forward order it is good practice to change dummy index to also write the summation in forward order (coefficients in backward order),\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\nabla^k f[n] = \\sum_{j=0}^{k} c^k[j]f[n-k+j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"where ``c^k[j] \\equiv c_{k-j}^k``.    \n\nFunctions:  \n\n[`f_diff_weight(k,j)`](@ref) `` \\rightarrow c_j^k``\n\n[`f_diff_weights(k)`](@ref) `` \\rightarrow \\ c^k ≡ [c_k^k,\\ c_1^k,\\ldots,\\ c_0^k]``\n\n[`f_diff_weights_array(kmax)`](@ref) `` \\rightarrow \\ [\\ c^0,\\ c^1,\\ \\ldots,\\ c^{kmax} ]``\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffweight(k::Int, i::Int) fdiffweights(k::Int) fdiffweights_array(kmax::Int)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Finite difference expansion\n\nFinite-difference calculus builds on the *finite-difference expansion*, in practice truncated at *order* ``k``,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{\\infty}a{p}\\nabla^{p}f[n]=\\sum{p=0}^{k}a{p}\\nabla^{p}f[n]+\\cdots.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nBy choosing the order sufficiently high the expansion can be approximated to any desired level of accuracy. A finite-difference expansion of order ``k`` is defined by ``k+1`` *finite-difference expansion coefficients*, above denoted by ``a_{0},\\ \\ldots,\\ a_{k}``. Note that both the coefficients and the operators appear in forward order. It takes some bookkeeping to rewrite the expansion in the form of a *weighted sum* over the ``k+1`` *function values* ``f[n],\\ldots,f[n-k]`` (note the *backward order*). Substituting the finite-difference expression for ``\\nabla^k``, we obtain\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}a{p}\\nabla^{p}f[n]=\\sum{p=0}^{k}a{p}\\sum{j=0}^{p}c{j}^{i}f[n-j]=\\sum{j=0}^{k}\\sum{p=j}^{k}a{p}c{j}^{p}f[n-j]=\\sum{j=0}^{k}b{j}^{k}f[n-j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the weighted summation is defined by the *weights* ``b_{j}^{k}=\\sum_{p=j}^{k}a_{p}c_{j}^{p}``, with ``j=0,\\ \\ldots,\\ k``. By a change of dummy index we write the summation in *forward order*\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}a{p}\\nabla^{p}f[n]=\\sum_{j=0}^{k}b^k[j]f[n-k+j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"where ``b^k[j] \\equiv b_{k-j}^k``.  \nNote that the *weights vector* ``b^k`` contains the weights in backward order. It is generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), where `∇ =`[` f_diff_weights_array(kmax)`](@ref).\n\nFunctions:\n\n`coeffs` = ``[a_0,\\ \\ldots,\\ a_k]``\n\n[`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\\rightarrow b^k \\equiv [b_k^k,\\ ,\\ldots,\\ b_0^k]``\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffexpansion_weights(coeffs, ∇)","category":"page"},{"location":"","page":"Home","title":"Home","text":"### Lagrangian interpolation\n\nUsing the definition of the finite difference we can express the relation between ``f[n]`` and ``f[n+1]`` in operator form,","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n]=(1-\\nabla)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"By formal inversion of the operator we have","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+1] = (1 - \\nabla)^{-1} f[n] \\equiv \\sum_{p=0}^{\\infty}∇^p f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+2] = (1 - \\nabla)^{-2} f[n] \\equiv \\sum_{p=0}^{\\infty}p∇^p f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\vdots","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhich can be generalized to the form of *lagrangian interpolation*,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+x] = (1 - \\nabla)^{-x} f[n] \\equiv \\sum{p=0}^{\\infty}lp(x)∇^p f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``l_0\\equiv 1`` and ``l_p(x) = x(x+1)(x+2)\\cdots(x+p-1)/p!`` for ``p>0`` are the *finite-difference expansion coefficients* for *lagrangian interpolation*. These are generated by the function [`f_diff_expansion_coeffs_lagrange(k,x)`](@ref). Evaluating the finite-difference expansion up to order ``k`` we obtain\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+x] =\\sum{p=0}^{k}lp(x)\\nabla^pf[n]= \\sum{j=0}^{k}rj^k(x)f[n-j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``k+1`` *weights* ``r_j^k(x)= \\sum_{p=j}^{k} l_p(x) c_j^p`` are the  *lagrangian interpolation weights*.  After changing dummy index to bring the summation in forward order the expansion becomes","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+x] =\\sum{p=0}^{k}lp(x)\\nabla^pf[n]= \\sum{j=0}^{k}rx^k[j]f[n-k+j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"where ``r^k_x[j] ≡ r_{k-j}^k(x)``. The weights vector ``r^k_x`` is generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ =` [`f_diff_weights_array(k)`](@ref).\n\nFunctions:\n\n`coeffs` = [`f_diff_expansion_coeffs_lagrange(k,x)`](@ref) ``\\rightarrow [l_0(x),\\ \\ldots,\\ l_k(x)]``\n\n`lagrangian interpolation weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\\rightarrow r^k_x ≡ [r_k^k(x),\\ ,\\ldots,\\ r_0^k(x)]``\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs","category":"page"},{"location":"","page":"Home","title":"Home","text":"fdiffexpansioncoeffslagrange(k::Int, x::T) where T<:Real summationrange(n::Int, i::Int, k::Int, μ::Int) fdifffunctionsequences(f, k::Int, μ=0) lagrangeinterpolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, i=0) lagrangeextrapolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, e=2, μ=0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"### Lagrangian differentiation\n\nTo derive the *lagrangian differentiation* formulas we formally differentiate\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+x] = (1 - \\nabla)^{-x} f[n]","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwith respect to ``x``.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{df}{dx}[n+x]=-ln(1-\\nabla)\\ (1-\\nabla)^{-x}f[n]=\\sum{q=1}^{k}\\tfrac{1}{q}∇^{q}\\sum{p=0}^{k}l_{p}(x)∇^{p}f[n]+\\cdots.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nRewriting the r.h.s. as a single summation in powers of ``\\nabla`` for given values of ``n`` and ``x`` we obtain an expression of the form\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{df}{dx}[n+x]=\\sum{p=1}^{k}l{p}^{\\prime}(x)\\nabla^{p}f[n]+\\cdots,","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``l_{p}^{\\prime}(x)`` represents the *finite-difference expansion coefficients* for *lagrangian differentiation* at position ``n+x``. These coefficients are determined numerically by polynomial multiplication after adding the ``p=0`` term, ``l_{0}^{\\prime}(x)\\equiv 0``, to the first sum. The corresponding coefficient vector is generated in *forward order* by the function [`f_diff_expansion_coeffs_differentiation(k,x)`](@ref). Evaluating the finite-difference expansion up to order ``k`` we obtain\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{df}{dx}[n+x]=\\sum{p=0}^{k}l{p}^{\\prime}(x)\\nabla^{p}f[n]=\\sum{j=0}^{k}s{j}^{k}(x)f[n-j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``s_{j}^{k}(x)=\\sum_{p=j}^{k}l_{p}^{\\prime}(x)c_{j}^{p}`` are the ``k^{th}``-order lagrangian differentiation weights.  After changing dummy index to reverse the summation from backward to forward order the expansion becomes\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{df}{dx}[n+x]]= \\sum{j=0}^{k}s^kx[j]f[n-k+j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"where ``s^k_x[j] ≡ s^k_{k-j}(x)``. The weights vector ``s^k_x`` is generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ =` [`f_diff_weights_array(k)`](@ref).\n\nFunctions:\n\n`coeffs` = [`f_diff_expansion_coeffs_differentiation(k,x)`](@ref) ``\\rightarrow [l_0^{\\prime}(x),\\ \\ldots,\\ l_k^{\\prime}(x)]``\n\n`Lagrange differentiation weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``s^k_x[j] ≡ \\rightarrow [s_k^k(x),\\ ,\\ldots,\\ s_0^k(x)]``\n\n`Lagrange differentiation weights` = [`create_lagrange_differentiation_weights(k,x) `](@ref) ``s^k_x[j] ≡ \\rightarrow [s_k^k(x),\\ ,\\ldots,\\ s_0^k(x)]``\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffexpansioncoeffsdifferentiation(k::Int, x::T) where T<:Real createlagrangedifferentiationweights(k::Int, x::T) where T<:Real createlagrangedifferentiationmatrix(k::Int) lagrange_differentiation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=3, i=0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Integration\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs trapezoidalweights(k::Int; rationalize=false, devisor=false) trapezoidalintegration(f, domain, weights)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Adams Method\n\n#### Adams-Bashford expansion\n\nThe *Adams-Bashford integration step* is given by the expansion\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math y[n+1]-y[n] = -\\frac{h \\nabla}{(1-\\nabla)ln(1-\\nabla)}f[n+1]=h (\\sum{p=0}^{\\infty}Bp\\nabla^p)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nA closed expression for the *Adams-Bashford expansion coefficients*, ``B_k``, is not available. As we already have a finite-difference expansion for the operator ``(1-∇)^{-1}``,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{1}{1-∇}\\equiv\\sum_{p=0}^{\\infty}\\nabla^p,","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwe ask for the expansion of\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math -\\frac{∇}{ln(1-∇)}=(1-\\frac{1}{2}∇-\\frac{1}{24}∇^2-\\frac{1}{12}∇^3+\\cdots)f[n+1]= (\\sum{p=0}^{\\infty}bp\\nabla^p)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nThis is known as the *Adams-Moulton expansion*. Its coefficients are calculated numerically by the function `f_diff_expansion_adams_moulton_coeffs(k)`. The *Adams-Bashford expansion* is obtained as the polynomial product of the two expansions,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math (\\sum{p=0}^{\\infty}Bp∇^p)f[n+1]=(\\sum{p=0}^{\\infty}∇^p)(\\sum{p=0}^{\\infty}b_p∇^p)f[n+1]=\\ ( 1 + \\frac{1}{2}\\nabla + \\frac{5}{12}\\nabla^2 + \\cdots)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nThe coefficients ``B_p`` are calculated numerically with the function `f_diff_expansion_adams_bashford_coeffs(k)`. Evaluating the finite-difference expansion up to order ``k`` we obtain (after changing dummy index bring the summation in forward order)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}Bp\\nabla^pf[n]=\\sum{p=0}^{k}Bp\\sum{j=0}^{p} cj^if[n-j]= \\sum{j=0}^{k}Aj^k(x)f[n-j]= \\sum{j=0}^{k}A{k-j}^k(x)f[n-k+j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``A_j^k(x)= \\sum_{p=j}^{k} B_pc_j^p`` are the ``(k+1)``-point *Adams-Bashford integration weights*.\n\nFunction:\n\n`coeffs` = [`f_diff_expansion_coeffs_adams_bashford(k)`](@ref) ``\\rightarrow [B_k^k(x),\\ ,\\ldots,\\ B_0^k(x)]``\n\n`adams_bashford_integration_weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\\rightarrow [A_k^k(x),\\ ,\\ldots,\\ A_0^k(x)]``\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffexpansioncoeffsadams_bashford(k::Int)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Adams-Moulton expansion\n\nThe *Adams-Moulton integration* step is given by the expansion\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math y[n+1]-y[n] = -\\frac{\\nabla}{ln(1-\\nabla)}f[n+1] = ( 1 - \\frac{1}{2}\\nabla - \\frac{1}{12}\\nabla^2 - \\frac{1}{24}\\nabla^3 +\\cdots)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nFor the evaluation of the integration step we limit the summation to ``k+1`` terms (order ``k``),\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math y[n+1]-y[n]= (\\sum{p=0}^{k}bp\\nabla^p)f[n+1]+\\cdots.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``b_0,\\ldots,b_k`` are the *Adams-Moulton expansion coefficients*, rational numbers generated numerically by the function [`f_diff_expansion_coeffs_adams_moulton(k)`](@ref). Extracting the greatest common denominator, ``1/D``, the step becomes\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math y[n+1]-y[n]= \\frac{1}{D}(\\sum{p=0}^{k}bp^{\\prime}\\nabla^p)f[n+1]+\\cdots,","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``b_0^{\\prime},\\ldots,b_k^{\\prime}`` are integers and ``b_p=b_p^{\\prime}/D``. In practice the expansion is restricted to ``k<18`` (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to ``k = 10``). Evaluating the finite-difference expansion up to order ``k`` we obtain (after changing dummy index bring the summation in forward order)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}bp\\nabla^pf[n]=\\sum{p=0}^{k}bp\\sum{j=0}^{p} cj^if[n-j]= \\sum{j=0}^{k}aj^k(x)f[n-j]= \\sum{j=0}^{k}a{k-j}^k(x)f[n-k+j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``a_j^k(x)= \\sum_{p=j}^{k} b_pc_j^p`` are the ``(k+1)``-point *Adams-Moulton integration weights*. These are generated in *backward order* by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ = `[`f_diff_weights_array(k)`](@ref).\n\nFunctions:\n\n`coeffs` = [`f_diff_expansion_coeffs_adams_moulton(k)`](@ref) ``\\rightarrow [b_0,\\ldots,b_k]``\n\n`adams_moulton_weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref)``\\rightarrow [a_k^k,\\ ,\\ldots,\\ a_0^k]``\n\n`adams_moulton_weights` = [`create_adams_moulton_weights(k)`](@ref)``\\rightarrow [a_k^k,\\ ,\\ldots,\\ a_0^k]``\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffexpansioncoeffsadamsmoulton(k::Int) createadamsmoultonweights(k::Int; rationalize=false, devisor=false, T=Int)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Strings\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs sup(i::T) where T<:Real sub(i::T) where T<:Real frac(i::Rational{Int})","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Index\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@index ```","category":"page"}]
}
