var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CamiXon","category":"page"},{"location":"#CamiXon.jl","page":"Home","title":"CamiXon.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for image analysis of backscattered light","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CamiXon is a package for the numerical solution of the radial Schrödinger equation allowing for screening.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this package the solution is obtained for a single electron, acting as a spectator in the central field of the atomic nucleus screened by 'the other' electrons (the screening electrons).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The starting point is the 1D Schrödinger equation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"tildeχ_l^+2Z_mathrmeff(ρ)ρ-l(l+1)2ρ^2+ε_ltildeχ_l=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"where tildechi_l(rho)=rhotildeR_l(rho) is the reduced radial wavefunction and ε_l=-κ _l^2 is the corresponding binding energy in Hartree atomic units (a.u.). As compared to the hydrogenic case, the atomic number Z has been replaced by Z_mathrmeff(ρ), the effective nuclear charge at radial distance ρ from the atomic center (in a.u.). In other words, the energy of the electron in the Coulomb field of the nucleus is replaced by an effective, central field potential of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"U_mathrmCF(ρ)=-Z_mathrmeff(ρ)ρ=-Zρ+U_mathrmscr(ρ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"consisting of the bare Coulomb contribution, -Zρ, and the screening field U_mathrmscr(ρ), subject to the boundary conditions U_mathrmscr(0)=Z and mathrmlim_ρinftyU_mathrmscr(ρ)=Z_cρ. Here Z_c is the Rydberg charge; i.e. the effective nuclear charge for a spectator electron in the far field (ρinfty). Within these assumptions we can optimize U_mathrmscr(ρ), while preserving the bare Coulomb field close to the nucleus as well as the Rydberg potential in the far field. The price we pay is that the radial Schrödinger equation has to be solved numerically by radial integration. Our strategy is to use both inward and outward integration and match the two branches by equating the two solutions for the wavefunction, χ(ρ), and its derivative, χ^(ρ), at a point near the classical turning point of the radial motion of the electron. The basics of the solution can be found in the book Atomic Structure Theory by Walter R. Johnson.","category":"page"},{"location":"#Illustration:-the-hydrogen-3d-orbital","page":"Home","title":"Illustration: the hydrogen 3d orbital","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Shown below are the reduced radial wavefunction (χ) and its derivative (χ^) in the near field (left), the far field (right), and in the region near the classical turning point (center).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Image)","category":"page"},{"location":"#Codata","page":"Home","title":"Codata","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Codata\nValue\nstrValue(f::Value)\nNamedValue\ncastNamedValue(val::Value; name=\" \", comment=\" \")\ncastCodata(year::Int)\nlistCodata(codata::Codata)\nconvertUnit(val, codata; unitIn=\"Hartree\", unitOut=\"xHz\")\ncalibrationReport(E, Ecal, codata::Codata; unitIn=\"Hartree\")","category":"page"},{"location":"#CamiXon.Codata","page":"Home","title":"CamiXon.Codata","text":"Codata\n\nObject to hold the natural constants from CODATA. It is best created with the function castCodata\n\nThe fields are:\n\n.∆νCs: Cs hyperfine transition frequency (::Value)\n.c: speed of light in vacuum (::Value)\n.h: Planck constant (::Value)\n.ħ: Planck constant - reduced (::Value)\n.e: elementary charge (::Value)\n.kB: Boltzmann constant (::Value)\n.NA: Avogadro constant (::Value)\n.Kcd: Luminous efficacy (::Value)\n.me: electron rest mass (::Value)\n.R∞: Rydberg constant (::Value)\n.Ry: Rydberg frequency (::Value)\n.Eh: Hartree a.u. (::Value)\n.α: fine-structure constant (::Value)\n.μ0: magnetic permitivity of vacuum (::Value)\n.ε0: electric permitivity of vacuum (::Value)\n.KJ: Josephson constant (::Value)\n.RK: Von Klitzing constant (::Value)\n.R: Molar gas constant (::Value)\n.matE: unit conversion matrix (Matrix{Float64})\n\nExample:\n\ncodata = castCodata(2018)\ncodata.μ0\n  Value(1.2566370621250601e-6, \"N A⁻²\")\n\ncodata.μ0.val\n  1.2566370621250601e-6\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Value","page":"Home","title":"CamiXon.Value","text":"Value(val::Real, unit::String)\n\nObject to hold a real numerical value together with a unit specifier.\n\nThe fields are:\n\n.val: numerical value (::Real)\n.unit: unit specifier (::String)\n\nExample:\n\nf = Value(1,\"Hz\")\n  Value(1, \"Hz\")\n\nf.val\n  1\n\nf.unit\n  \"Hz\"\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.strValue-Tuple{Value}","page":"Home","title":"CamiXon.strValue","text":"strValue(f::Value)\n\nString expression for a Value object in :compact => true representation\n\nExample:\n\nf = Value(1,\"Hz\")\nstrValue(f)\n  \"1 Hz\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.NamedValue","page":"Home","title":"CamiXon.NamedValue","text":"NamedValue(val::Value, name::String, comment::String)\n\nObject to hold a Value together with its symbolic name and a short description\n\nThe fields are:\n\n.val: Value  (::Value)\n.name: symbolic name (::String)\n.comment: description (::String)\n\nNamed Value object The object NamedValue is best created using castNamedValue.\n\nExample:\n\nf = Value(1,\"Hz\")\n  Value(1, \"Hz\", \"frequency\")\n\nf.name\n  \"frequency\"\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.castNamedValue-Tuple{Value}","page":"Home","title":"CamiXon.castNamedValue","text":"castNamedValue(val::Value; name=\" \", comment=\" \")\n\nMethod to create a NamedValue object\n\nExample\n\nv = Value(1.602176634e-19, \"C\")\nnv = castNamedValue(v; name=\"e\")\nnv.name * \" = \" * strValue2(nv.val)\n  \"e = 1.60218e-19 C\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castCodata-Tuple{Int64}","page":"Home","title":"CamiXon.castCodata","text":"castCodata(year::Int)\n\nMethod to create the Codata object\n\nExample:\n\ncodata = castCodata(2018)\nstrValue.([codata.∆νCs,codata.c,codata.h])\n 3-element Vector{String}:\n  \"9192631770 Hz\"\n  \"299792458 m s⁻¹\"\n  \"6.62607e-34 J Hz⁻¹\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listCodata-Tuple{Codata}","page":"Home","title":"CamiXon.listCodata","text":"listCodata(codata::Codata)\n\nMethod to list the fields of Codata by their symbolic name\n\nExample:\n\ncodata = castCodata(2018)\nlistCodata(codata::Codata)\n  ∆νCs = 9192631770 Hz\n  c = 299792458 m s⁻¹\n  h = 6.62607e-34 J Hz⁻¹\n  ħ = 1.05457e-34 J s\n  e = 1.60218e-19 C\n  kB = 1.38065e-23 J K⁻¹\n  NA = 6.02214e23 mol⁻¹\n  Kcd = 683 lm W⁻¹\n  mₑ = 9.10938e-31 Kg\n  R∞ = 1.09737e7 m⁻¹\n  Ry = 3.28984e15 Hz\n  Eₕ = 4.35974e-18 Hartree a.u.\n  α = 0.00729735\n  μ₀ = 1.25664e-6 N A⁻²\n  ε₀ = 8.85419e-12 F m⁻¹\n  KJ = 4.83598e14 Hz V⁻¹\n  RK = 25812.8 Ω\n  R = 8.31446 J mol⁻¹K⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.convertUnit-Tuple{Any, Any}","page":"Home","title":"CamiXon.convertUnit","text":"convertUnit(val, codata; unitIn=\"Hartree\", unitOut=\"xHz\")\n\nUnit conversion between μHz,⋯ EHz, Hartree, Rydberg, Joule, and eV\n\ndefault input: Hartree\n\ndefault output: xHz ∈ {μHz, mHz, Hz, kHz, MHz, GHz, THz, PHz, EHz}\n\nExample:\n\ncodata = castCodata(2018)\nconvertUnit(1, codata; unitIn=\"Hz\", unitOut=\"Joule\")\n  6.62607015e-34\n\nconvertUnit(1, codata; unitIn=\"Hartree\", unitOut=\"Hz\")\n  Value(6.57968392050182e15, \"Hz\")\n\nf = convertUnit(1, codata) # default input (Hartree) and output (xHz)\nstrf = strValue(f)\n  \"6.57968 PHz\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.calibrationReport-Tuple{Any, Any, Codata}","page":"Home","title":"CamiXon.calibrationReport","text":"calibrationReport(E, Ecal, codata::Codata; unitIn=\"Hartree\")\n\nComparison of energy E with calibration value Ecal\n\ndefault input: Hartree\n\nExample:\n\ncodata = castCodata(2018)\ncalibrationReport(1.1, 1.0, codata; unitIn=\"Hartree\")\n  calibration report (Float64):\n  Ecal = 1.0 Hartree\n  E = 1.1 Hartree\n  absolute accuracy: ΔE = 0.1 Hartree (657.968 THz)\n  relative accuracy: ΔE/E = 0.0909091\n\n\n\n\n\n","category":"method"},{"location":"#Atomic-properties","page":"Home","title":"Atomic properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Element\nIsotope\nAtom\nOrbit\nSpinOrbit\nTerm\nlistElement(Z::Int; fmt=Object)\nlistElements(Z1::Int, Z2::Int; fmt=Object)\ncastElement(;Z=1, msg=true)\nlistIsotope(Z::Int, A::Int; fmt=Object)\nlistIsotopes(Z1::Int, Z2::Int; fmt=Object)\nlatexIsotopeTable(Z1::Int, Z2::Int; continuation=false)\ncastIsotope(;Z=1, A=1, msg=true)\nlistAtom(Z::Int, A::Int, Q::Int; fmt=Object)\nlistAtoms(Z1::Int, Z2::Int, Q::Int; fmt=Object)\ncastAtom(;Z=1, A=1, Q=0, msg=true)\ncastOrbit(;n=1, ℓ=0, msg=true)\ncreateSpinOrbit(o::Orbit; up=true, msg=true)\ncreateTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)\nbohrformula(Z::Int, n::Int)","category":"page"},{"location":"#CamiXon.Element","page":"Home","title":"CamiXon.Element","text":"Element(name, symbol, weight)\n\nType with fields:\n\n.name:  name of element (::String)\n.symbol:  symbol of element  (::String)\n.weight:  relative atomic mass - atomic weight (::Float64)\n\nThe type Element is best created with the function castElement.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Isotope","page":"Home","title":"CamiXon.Isotope","text":"Isotope(symbol, name, Z, A, N, R, M, I, π, T½, mdm, eqm, ra)\n\nType with fields:\n\n.symbol: symbol (::String)\n.name: name (::String)\n.Z:  atomic number (::Int)\n.A:  atomic mass number in amu (::Int)\n.N:  neutron number (::Int)\n.R:  rms charge radius in Fermi (::Float64)\n.M:  atomic mass in amu (::Float64)\n.I:  nuclear spin in units of ħ  (::Rational{Int})\n.π:  parity of nuclear state (::Int)\n.T½:  lifetime in years (::Float64)\n.mdm: nuclear magnetic dipole moment (::Float64)\n.eqm: nuclear electric quadrupole moment (::Float64)\n.ra:  relative abundance in % (::Float64)\n\nThe type Isotope is best created with the function castIsotope.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Atom","page":"Home","title":"CamiXon.Atom","text":"Atom(Z, A, Q, Zc, element, isotope)\n\nType with fields:\n\n.Z:  atomic number (::Int)\n.A:  atomic mass number in amu (::Int)\n.Q:  ionic charge in a.u. (::Int)\n.Zc:  Rydberg charge in a.u. (::Int)\n.element:  (::Element)\n.isotope:  (::Isotope)\n\nThe type Atom is best created with the function castAtom.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Orbit","page":"Home","title":"CamiXon.Orbit","text":"Orbit(name, n, n′, ℓ)\n\nType for specification of atomic orbitals with fields:\n\n.name: name\n.n:  principal quantum number\n.n′:  radial quantum number (number of nodes in radial wavefunction)\n.ℓ:  orbital angular momentum valence electron\n\nThe type Orbit is best created with the function castOrbit.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.SpinOrbit","page":"Home","title":"CamiXon.SpinOrbit","text":"SpinOrbit\n\nType for specification of atomic spinorbitals with fields:\n\n.name: name\n.n:  principal quantum number\n.n′:  radial quantum number (number of nodes in radial wavefunction)\n.ℓ:  orbital angular momentum valence electron\n.ms:  spin magnetic quantum number\n\nThe type SpinOrbit is best created with the function createSpinOrbit.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.Term","page":"Home","title":"CamiXon.Term","text":"Term(name::String, n::Int, ℓ::Int, S::Real, L::Int, J::Real)\n\nType for specification of atomic fine-structure Terms with fields:\n\nname: name\n.n:  principal quantum number\n.n′:  radial quantum number (number of nodes in wavefunction)\n.ℓ:  orbital angular momentum valence electron\n.S:  total electron spin in units of ħ\n.L:  total orbital angular momentum in units of ħ\n.J:  total electronic angular momentum in units of ħ\n\nThe type Term is best created with the function createTerm.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.listElement-Tuple{Int64}","page":"Home","title":"CamiXon.listElement","text":"listElement(Z::Int[; fmt=Object])\nlistElement(elt::String[; fmt=Object])\n\nProperties of element with atomic number Z.\n\nOutput options: fmt =  Object (default), String, Info.\n\nExample:\n\nlistElement(\"H\") == listElement(1)\n  true\n\nlistElement(1; fmt=Info)\n  Element: hydrogen\n    symbol: H\n    atomic number: Z = 1\n    atomic weight (relative atomic mass): 1.008\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listElements-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.listElements","text":"listElements(Z1::Int, Z2::Int[; fmt=Object])\n\nProperties of elements with atomic number in the range Z1:Z2.\n\nOutput options: fmt =  Object (default), String, Info.\n\nExample\n\nlistElements(1,3) == listElements(1:3)\n  true\n\nlistElements(1:3; fmt=Info)\n  Element: hydrogen\n    symbol: H\n    atomic number: Z = 1\n    atomic weight (relative atomic mass): 1.008\n  Element: helium\n    symbol: He\n    atomic number: Z = 2\n    atomic weight (relative atomic mass): 4.0026\n  Element: lithium\n    symbol: Li\n    atomic number: Z = 3\n    atomic weight (relative atomic mass): 6.94\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castElement-Tuple{}","page":"Home","title":"CamiXon.castElement","text":"castElement(;Z=1, msg=true)\ncastElement(elt::String; msg=true)\n\nCreate Atom with fields\n\n.name:  name of element\n.symbol:  symbol of element\n.weight:  relative atomic mass (atomic weight)\n\nExample:\n\ncastElement(\"Rb\"; msg=false) == castElement(Z=37, msg=false)\n  true\n\nelement = castElement(;Z=1, msg=true)\nelement\n  Element created: H, hydrogen, Z=1, weight=1.008\n\n  Element(\"hydrogen\", \"H\", 1.008)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listIsotope-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.listIsotope","text":"listIsotope(Z::Int, A::Int; fmt=Object)\n\nProperties of isotopes with atomic number Z and atomic mass number A.\n\nOutput options: fmt =  Object (default), String, Latex, Info.\n\nExample:\n\nlistIsotope(1,3; fmt=Info)\n  Isotope: tritium-3\n    symbol: ³T\n    element: tritium\n    atomic number: Z = 1\n    atomic mass number: A = 3\n    neutron number: N = 2\n    rms nuclear charge radius: R = 1.7591 fm\n    atomic mass: M = 3.016049281 amu\n    nuclear spin: I = 1/2 ħ\n    parity of nuclear state: π = even\n    nuclear magnetic dipole moment: μI = 2.97896246μN\n    nuclear electric quadrupole moment: Q = 0.0barn\n    relative abundance: RA = trace\n    lifetime: 12.33 years\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listIsotopes-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.listIsotopes","text":"listIsotopes(Z1::Int, Z2::Int; fmt=Object)\n\nAll isotopes with atomic number from Z1 to Z2.\n\nOutput options: Object (default), String, Latex, Info.\n\nExample:\n\nlistIsotopes(1,3) == listIsotopes(1:3)\n true\n\nlistIsotopes(1:1; fmt=Info)\n 3-element Vector{Any}:\n  Isotope(\"¹H\", \"hydrogen\", 1, 1, 0, 0.8783, 1.007825032, 1//2, 1, 1.0e100, 2.792847351, 0.0, 99.9855)\n  Isotope(\"²D\", \"deuterium\", 1, 2, 1, 2.1421, 2.014101778, 1, 1, 1.0e100, 0.857438231, 0.0028578, 0.0145)\n  Isotope(\"³T\", \"tritium\", 1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.latexIsotopeTable-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.latexIsotopeTable","text":"latexIsotopeTable(Z1::Int, Z2::Int; continuation=false)\n\nIsotope table for all isotopes with atomic number from Z1 to Z2.\n\nExample:\n\nlatexIsotopeTable(1:3)\n  \\setlength{\\tabcolsep}{3pt}\n  \\renewcommand{\\arraystretch}{1.2}\n  \\begin{table}[H]\n    \\centering\n    \\caption{\\label{table:Isotopes-a-1}Properties of selected atomic isotopes. The Table is based on three databases: (a) AME2020 (atomic mass evaluation); (b) IAEA-INDC(NDS)-794 (magnetic dipole moments); (c) IAEA-INDC(NDS)-833 (electric quadrupole moments).}\n    \\begin{tabular}{r|lr|rrrr|r|r|r|r}\n      \\multicolumn{12}{r}\\vspace{-18pt}\\\\\n      \\hline\n      \\hline\n      $Z$ & element & symbol & $A$ & $N$ & radius & atomic mass & $I\\,^\\pi$ & $\\mu_I $ & $Q$ & $RA$\\\\&  &  &  &  & (fm) & $(m_u)$ & $(\\hbar)\\ \\ $ & $(\\mu_N)$ & (barn) & (\\%)\\\\\\hline\n      1 & hydrogen & $^{1}$H & 1\\, & 0 & 0.8783 & 1.007825032 & 1/2$^+$ & 2.792847351 & 0.0 & 99.9855 \\\\\n        &  & $^{2}$H & 2\\, & 1 & 2.1421 & 2.014101778 & 1//1$^+$ & 0.857438231 & 0.0028578 & 0.0145 \\\\\n        &  & $^{3}$H & 3$*\\!\\!$ & 2 & 1.7591 & 3.016049281 & 1/2$^+$ & 2.97896246 & 0.0 & trace \\\\\n      \\hline\n      2 & helium & $^{3}$He & 3\\, & 1 & 1.9661 & 3.016029322 & 1/2$^+$ & -2.12762531 & 0.0 & 0.0002 \\\\\n        &  & $^{4}$He & 4\\, & 2 & 1.6755 & 4.002603254 & 0//1$^+$ & 0.0 & 0.0 & 99.9998\\% \\\\\n      \\hline\n      3 & lithium & $^{6}$Li & 6\\, & 3 & 2.589 & 6.015122887 & 1//1$^+$ & 0.822043 & -0.000806 & 4.85 \\\\\n        &  & $^{7}$Li & 7\\, & 4 & 2.444 & 7.016003434 & 3/2$^-$ & 3.256407 & -0.04 & 95.15 \\\\\n      \\hline\n      \\multicolumn{12}{l}{*radioactive }\\\\\n    \\end{tabular}\n  \\end{table}\n\nThe typeset result is shown in the figule below.\n\n(Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castIsotope-Tuple{}","page":"Home","title":"CamiXon.castIsotope","text":"castIsotope(;Z=1, A=1, msg=true)\ncastIsotope(elt::String; A=1, msg=true)\n\nCreate Isotope with fields\n\n.symbol: symbol (::String)\n.name: symbol (::String)\n.Z:  atomic number (::Int)\n.A:  atomic mass number in amu (::Int)\n.N:  neutron number (::Int)\n.R:  rms charge radius in Fermi (::Float64)\n.M:  atomic mass in amu (::Float64)\n.I:  nuclear spin in units of ħ (::Rational{Int})\n.π:  parity of nuclear state (::Int)\n.ra:  relative abundance in % (::Float64)\n.mdm: nuclear magnetic dipole moment (::Float64)\n.eqm: nuclear electric quadrupole moment (::Float64)\n.T½:  lifetime in years (::Float64)\n\nExamples:\n\ncastIsotope(\"Rb\"; A=87, msg=false) == castIsotope(Z=37, A=87, msg=false)\n  true\n\nisotope = castIsotope(Z=1, A=3, msg=false)\n  Isotope(\"³T\", \"tritium\", 1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0, nothing)\n\nisotope.T½\n  12.33\n\ncastIsotope(Z=1,A=3);\n  Isotope created: tritium-3\n      symbol: ³T\n      element: tritium\n      atomic number: Z = 1\n      atomic mass number: A = 3\n      neutron number: N = 2\n      rms nuclear charge radius: R = 1.7591 fm\n      atomic mass: M = 3.016049281 amu\n      nuclear spin: I = 1/2 ħ\n      parity of nuclear state: π = ⁺\n      nuclear magnetic dipole moment: μI = 2.97896246μN\n      nuclear electric quadrupole moment: Q = 0.0barn\n      relative abundance: RA = trace\n      lifetime: 12.33 years\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listAtom-Tuple{Int64, Int64, Int64}","page":"Home","title":"CamiXon.listAtom","text":"listAtom(Z::Int, A::Int, Q::Int[; fmt=Object])\n\nProperties of atom with atomic number Z, atomic mass number A, ionic charge Q.\n\nOutput options: fmt =  Object (default), String, Info.\n\nExample:\n\nlistAtom(\"H\", 3, 0) == listAtom(1, 3, 0)\n  true\n\nlistAtom(1, 3, 0; fmt=Info)\nElement: hydrogen\n    symbol: H\n    element: tritium\n    atomic number: Z = 1\n    atomic weight (relative atomic mass): 1.008\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.listAtoms-Tuple{Int64, Int64, Int64}","page":"Home","title":"CamiXon.listAtoms","text":"listAtoms(Z1::Int, Z2::Int, Q::Int[; fmt=Object])\n\nProperties of atoms with atomic number in the range Z1:Z3 and ionic charge Q.\n\nOutput options: fmt =  Object (default), String, Info.\n\nExample\n\nlistAtoms(1,3,0) == listAtoms(1:3,0)\n  true\n\nlistAtoms(1:1, 0; fmt=Info);\n  Atom: hydrogen, neutral atom\n    symbol: ¹H\n    atomic charge: Z = 1\n    Rydberg charge: Zc = 1\n  Atom: deuterium, neutral atom\n    symbol: ²D\n    atomic charge: Z = 1\n    Rydberg charge: Zc = 1\n  Atom: tritium, neutral atom\n    symbol: ³T\n    atomic charge: Z = 1\n    Rydberg charge: Zc = 1\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castAtom-Tuple{}","page":"Home","title":"CamiXon.castAtom","text":"castAtom(;Z=1, A=1, Q=0, msg=true)\ncastAtom(elt::String; A=1, Q=0, msg=true)\n\nCreate Atom with fields:\n\n.Z:  atomic number (::Int)\n.A:  atomic mass number in amu (::Int)\n.Q:  ionic charge in a.u. (::Int)\n.Zc:  Rydberg charge in a.u. (::Int)\n.element:  (::Element)\n.isotope:  (::Isotope)\n\nExamples:\n\ncastAtom(\"Rb\"; A=87, Q=0, msg=false) == castAtom(Z=37, A=87, Q=0, msg=false)\n  true\n\ncastAtom(Z=1, A=3, Q=0, msg=false)\n  Atom(1, 3, 0, 1, Element(\"hydrogen\", \"H\", 1.008), Isotope(\"³T\", \"tritium\",\n  1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing))\n\natom = castAtom(Z=1, A=3, Q=0, msg=true);\n  Element created: H, hydrogen, Z=1, weight=1.008\n  Isotope created: ³T, tritium, Z=1, A=3, N=2, R=1.7591, M=3.016049281, I=1/2⁺, μI=2.97896246, Q=0.0, RA=trace, (radioactive)\n  Atom created: tritium, neutral atom, ³T, Z=1, A=3, Q=0, Zc=1\n\natom\n  Atom(1, 3, 0, 1, Element(\"hydrogen\", \"H\", 1.008), Isotope(\"³T\", \"tritium\",\n  1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing))\n\natom.isotope.T½\n  12.33\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castOrbit-Tuple{}","page":"Home","title":"CamiXon.castOrbit","text":"castOrbit(;n=1, ℓ=0, msg=true)\n\nCreate Orbit with fields:\n\n.name: name\n.n:  principal quantum number\n.n′:  radial quantum number (number of nodes in radial wavefunction)\n.ℓ:  orbital angular momentum valence electron\n\nExamples:\n\ncastOrbit(n=1, ℓ=0)\n Orbit created: 1s (n = 1, n′ = 0, ℓ = 0)\n Orbit(\"1s\", 1, 0, 0)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.createSpinOrbit-Tuple{Orbit}","page":"Home","title":"CamiXon.createSpinOrbit","text":"createSpinOrbital(o::Orbit; up=true, msg=true)\n\nSpecify SpinOrbit with fields:\n\n.name: name\n.n: principal quantum number\n.n′: radial quantum number (number of nodes in radial wavefunction)\n.ℓ: orbital angular momentum valence electron\n.ms: spin magnetic quantum number\n\nExamples:\n\ns1s = castOrbit(1,0)\ncreateSpinOrbit(s1s; up=true)\n  SpinOrbit created: 1s↑ (n = 1, n′ = 0, ℓ = 0, ms = 1//2)\n  SpinOrbit(\"1s↑\", 1, 0, 0, 1//2)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.createTerm-Tuple{Int64}","page":"Home","title":"CamiXon.createTerm","text":"createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)\n\nSpecify Term in the Term notatation with fields:\n\n.n: principal quantum number\n.n′: radial quantum number (number of nodes - autogenerated)\n.ℓ: orbital angular momentum valence electron\n.S: total electron spin\n.L: total orbital angular momentum\n.J: total electronic angular momentum\n\nExamples:\n\nterm_H1I = createTerm(1; ℓ=0, S=1//2, L=0, J=1//2)\n Term created: 1s ²S₁⸝₂, n = 1, n′ = 0, ℓ = 0, S = 1//2, L = 0, J = 1//2\n Term(\"1s ²S₁⸝₂\", 1, 0, 0, 1//2, 0, 1//2)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.bohrformula-Tuple{Int64, Int64}","page":"Home","title":"CamiXon.bohrformula","text":"bohrformula(Z::Int, n::Int)\n\nHydrogenic energy (in Hartree a.u.) for atom with atomic number Z and principal quantum number n.\n\n    E_n = - fracZ^22n^2\n\nExample:\n\nZ = 2\nn = 4\nbohrformula(Z,n)\n -0.125\n\n\n\n\n\n","category":"method"},{"location":"#Angular-momentum","page":"Home","title":"Angular momentum","text":"","category":"section"},{"location":"#Vector-coupling-coefficients","page":"Home","title":"Vector-coupling coefficients","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"threeJsymbol(j1::Real, m1::Real, j2::Real, m2::Real, j3::Real, m3::Real; msg=false)\nCGC(j1::Real, m1::Real, j2::Real, m2::Real, J::Real, M::Real; msg=false)","category":"page"},{"location":"#CamiXon.threeJsymbol-NTuple{6, Real}","page":"Home","title":"CamiXon.threeJsymbol","text":"threeJsymbol(j1::Real, m1::Real, j2::Real, m2::Real, j3::Real, m3::Real; msg=false)\n\nWigner 3j symbol. This is a vector coupling coefficient with optimized symmetry properties. The 3j symbols are zero unless Δ(j_1j_2j_3)0 (triangle inequality holds) and m_1+m_2+m_3=0. The implementation is based on the Racah formula:\n\nleft(beginarrayccc\nj_1  j_2  j_3\nm_1  m_2  m_3\nendarrayright)=\n(-1)^j_1-j_2-m_3sqrtDelta(j_1j_2J)times\nsqrtleft(j_1+m_1right)\nleft(j_1-m_1right)\nleft(j_2+m_2right)\nleft(j_2-m_2right)\nleft(j_3+m_3right)\nleft(j_3-m_3right)\ntimessum_tfrac(-)^tt(j_3-j_2+t+m_1)\n(j_3-j_1+t-m_2)\n(j_1+j_2-j_3-t)(j_1-t-m_1)(j_2-t+m_2)\n\nExample:\n\no = threeJsymbol(3, 0, 4, -1, 5, 1; msg=true); println(\" = $o\")\n    -√(361/30030) = -0.10964174397241236\n\nthreeJsymbol(3, 0, 4, -1, 5, 1)\n    -0.10964174397241236\n\nthreeJsymbol(0, 0, 0, 0, 0, 0)\n    1.0\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.CGC-NTuple{6, Real}","page":"Home","title":"CamiXon.CGC","text":"CGC(j1::Real, m1::Real, j2::Real, m2::Real, J::Real, M::Real; msg=false)\n\nClebsch-Gordan coefficient (CGC). This is a vector-coupling coefficient in Dirac notation. The CGCs are zero unless Δ(j_1j_2j_3)0 (triangle inequality holds) and M=m_1+m_2. The relation to the Wigner 3j symbols is given by:\n\nlangle j_1m_1j_2m_2JMrangleequiv\n(-1)^j_1-j_2+Msqrt2J+1left(beginarrayccc\nj_1  j_2  J\nm_1  m_2  -M\nendarrayright)\n\nExample:\n\nj1=3; m1=0\nj2=4; m2=-1\nJ=5; M=-1\no = CGC(j1, m1, j2, m2, J, M; msg=true); println(\" = $o\")\no = CGC(j1, m1, j2, m2, J, M); println(o)\no = (-1)^(j1-j2+M) * sqrt(2J+1) * threeJsymbol(j1, m1, j2, m2, J, -M); println(o)\n    -√(361/2730) = -0.36364052611670256\n    -0.36364052611670256\n    -0.36364052611670256\n\n\n\n\n\n","category":"method"},{"location":"#Grid","page":"Home","title":"Grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Grid object is the backbone for the numerical procedure on a non-uniform grid. Its principal fields are grid.r and grid.r′, which are discrete functions of N elements representing the grid function and its derivative.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grid{T}\ngridname(ID::Int)\ngridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T <: Real\ncastGrid(ID::Int, N::Int, T::Type; h=1, r0=0.001,  p=5, coords=[0,1], epn=5, k=7, msg=true)\nfindIndex(rval::T, grid::Grid{T}) where T<:Number\nautoRmax(atom::Atom, orbit::Orbit)\nautoNtot(orbit::Orbit)\nautoPrecision(Rmax::T, orbit::Orbit) where T<:Real\nautoSteps(ID::Int, Ntot::Int, Rmax::T; p=5, coords=[0,1]) where T<:Real\nautoGrid(atom::Atom, orbit::Orbit, T::Type; p=0, coords=[], Nboost=1, epn=5, k=7, msg=true)\ngrid_differentiation(f::Vector{T}, grid::Grid{T}; k=3) where T<:Real\ngrid_trapezoidal_integral(f::Vector{T}, n1::Int, n2::Int, grid::Grid{T}) where T<:Real","category":"page"},{"location":"#CamiXon.Grid","page":"Home","title":"CamiXon.Grid","text":"Grid(ID, name, T, N, r, r′, h, r0, epn, epw, k)\n\nType with fields:\n\n.ID:   grid identifer name (::Int)\n.name: grid identifer name (::String)\n.T:    gridType (::Type)\n.N:    number of grid points (::Int)\n.r:   tabulated grid function (::Vector{T})\n.r′:   tabulated derivative of grid function (::Vector{T})\n.h :   grid step multiplyer (::T)\n.r0:   grid scale factor (::T)\n.epn:  number of endpoints used for trapezoidal endpoint correction (must be odd) (::Int)\n.epw:  trapezoidal endpoint weights for n=1:epn (::Vector{Vector{T}})\n.k:    Adams-Moulton order (::Int)\n\nThe object Grid is best created with the function castGrid.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.gridname-Tuple{Int64}","page":"Home","title":"CamiXon.gridname","text":"gridname(ID::Int)\n\nName corresponding to the grid ID.\n\nExample:\n\nn = gridname(2); println(\"The grid type with ID = 2 is called '$n'.\")\n  The grid type with ID = 2 is called 'quasi-exponential'.\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T<:Real","page":"Home","title":"CamiXon.gridfunction","text":"gridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T <: Real\n\nID = 1: exponential grid function,\n\n    fn = textexp(h(n-1)) - 10\n\nID = 2: quasi-exponential grid function degree p (linear grid for p = 1),\n\n    fn = h(n-1) + frac12(h(n-1))^2 +  + frac1p(h(n-1))^p\n\nID = 3: polynomial grid function of degree p = length(c) based on polynom c = c_1c_2 c_p,\n\n    fn = c_1h(n-1) + c_2(h(n-1))^2 +  + c_p(h(n-1))^p\n\nID = 4: linear grid function,\n\n    fn = h(n-1)\n\nExamples:\n\nh = 0.1\nr = [gridfunction(1, n-1, h) for n=1:5]                            # exponential\n [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032, 0.49182469764127035]\n\nr = [gridfunction(2, n-1, h; p = 4) for n=1:5]  # quasi exponential (degree p=4)\n [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375, 0.49173333333333336]\n\nr = [gridfunction(3, n-1, h; coords = [0,1,1/2,1/6,1/24]) for n=1:5]  # polynomial (degree p=4)\n [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001, 0.49173333333333336]\n\nr = [gridfunction(4, n-1, h) for n=1:5]              # linear\n  [0.0, 0.1, 0.2, 0.3, 0.4]\n\nr′= [gridfunction(4, n-1, h; deriv=1) for n=1:5]     # linear (first derivative)\n   [0.1, 0.1, 0.1, 0.1, 0.1]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.castGrid-Tuple{Int64, Int64, Type}","page":"Home","title":"CamiXon.castGrid","text":"castGrid(ID::Int, N::Int, T::Type; h=1, r0=1,  p=5, coords=[0,1], epn=5, k=7, msg=true)\n\nMethod to create the Grid object\n\nID = 1: exponential grid, ID = 2: quasi-exponential grid, ID = 3: polynomial grid ID = 4: linear grid\n\nExamples:\n\nh = 0.1\nr0 = 1.0\ngrid = castGrid(1, 4, Float64; h, r0)\ngrid.r\n  create exponential Grid: Float64, Rmax = 0.491825 a.u., Ntot = 4, h = 0.1, r0 = 1.0\n  [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]\n\ngrid = castGrid(2, 4, Float64; p = 4, h, r0)\ngrid.r\n  create quasi-exponential Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, p = 4, h = 0.1, r0 = 1.0\n  [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375]\n\ngrid = castGrid(3, 4, Float64; coords=[0, 1, 1/2, 1/6, 1/24], h, r0)\ngrid.r\n  create polynomial Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, coords = [0.0, 1.0, 0.5, 0.166666, 0.0416666], h = 0.1, r0 = 1.0\n  [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001]\n\ngrid = castGrid(4, 4, Float64; h, r0)\ngrid.r\n  create linear Grid: Float64, Rmax = 0.4 a.u., Ntot = 4, p = 1, h = 0.1, r0 = 1.0\n  [0.0, 0.1, 0.2, 0.3]\n\ngrid.r′\n  [0.1, 0.1, 0.1, 0.1]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T<:Number","page":"Home","title":"CamiXon.findIndex","text":"findIndex(rval::T, grid::Grid{T}) where T<:Number\n\nThe grid index corresponding to the position rval on the grid.\n\nExample:\n\nh = 0.1\nr0 = 1.0\ngrid = castGrid(1, 4, Float64; h, r0)\nr = grid.r; println(\"r[3] = $(r[3])\")\n  Grid created: exponential, Float64, Rmax = 0.491825 a.u., Ntot = 4, h = 0.1, r0 = 1.0\n  r[3] = 0.22140275816016985\n\nfindIndex(0.222, grid)\n  3\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoRmax-Tuple{Atom, Orbit}","page":"Home","title":"CamiXon.autoRmax","text":"autoRmax(atom::Atom, orbit::Orbit)\n\nLargest relevant radial distance in a.u. (rule of thumb value)\n\nExample:\n\ncodata = castCodata(2018)\natom = castAtom(Z=1, A=1, Q=0)\norbit = castOrbit(n=1, ℓ=0)\nrmax = autoRmax(atom::Atom, orbit::Orbit); println(\"rmax = $(rmax) a.u.\")\n    Element created: H, hydrogen, Z=1, weight=1.008\n    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)\n    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1\n    Orbital: 1s\n        principal quantum number: n = 1\n        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 0\n    rmax = 63.0 a.u.\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoNtot-Tuple{Orbit}","page":"Home","title":"CamiXon.autoNtot","text":"autoNtot(orbit::Orbit, Nboost=1)\n\nTotal number of gridpoints (rule of thumb value)\n\nExample:\n\norbit = castOrbit(n=1, ℓ=0)\nautoNtot(orbit)\n Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)\n\n 100\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T<:Real","page":"Home","title":"CamiXon.autoPrecision","text":"autoPrecision(Rmax::T, orbit::Orbit) where T<:Real\n\nFloating point precision (rule of thumb value)\n\nExample:\n\natom = castAtom(Z=1)\norbit = castOrbit(n=1,ℓ=0)\nRmax = autoRmax(atom, orbit)\no = autoPrecision(Rmax, orbit); println(\"precision = $o\")\n    Element created: H, hydrogen, Z=1, weight=1.008\n    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)\n    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1\n    Orbital: 1s\n        principal quantum number: n = 1\n        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 0\n    precision = Float64\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T<:Real","page":"Home","title":"CamiXon.autoSteps","text":"autoSteps(ID::Int, Ntot::Int, Rmax::T; p=5, coords=[0,1]) where T<:Real\n\nStep size parameter (h) and range parameter (r0) (rule of thumb values).\n\nExample:\n\n(h, r0) = autoSteps(1, 100, 100)\n    (0.1, 0.004540199100968777)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.autoGrid-Tuple{Atom, Orbit, Type}","page":"Home","title":"CamiXon.autoGrid","text":"autoGrid(atom::Atom, orbit::Orbit, T::Type ; p=0, coords=[], Nboost=1, epn=5, k=7, msg=true)\n\nAutomatic setting of grid parameters. Important cases:\n\np=0 (exponential grid default)\np=1 (linear grid)\np>1 (quasi-exponential grid)\n\nExample:\n\ncodata = castCodata(2018)\natom = castAtom(;Z=1, A=1, Q=0, msg=false)\norbit = castOrbit(n=75, ℓ=0, msg=false)\ngrid = autoGrid(atom, orbit, Float64);\n    Grid created: exponential, Float64, Rmax = 16935.0 a.u., Ntot = 3800, h = 0.00263158, r0 = 0.768883\n\nplot_gridfunction(grid, 1:grid.N; title=\"\")\n\nThe plot is made using CairomMakie. NB.: plot_gridfunction is not part of the CamiXon package. (Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T<:Real","page":"Home","title":"CamiXon.grid_differentiation","text":"grid_differentiation(f::Vector{T}, grid::Grid{T}; k=3) where T<:Real\n\nk^th-order lagrangian differentiation of the analytic function f, tabulated in forward order on a Grid of n points, f1n.\n\nExample:\n\nID = 4 # linear grid\nf = [0.0, 1.0, 4.0, 9.0, 16.0, 25.0]\ngrid = castGrid(ID, length(f), Float64; r0=1.0, h=1.0, k=3)  # linear grid\nf′= grid_differentiation(f, grid; k=3); println(\"f′= $(f′)\")\n  Grid created: linear, Float64, Rmax = 6.0 a.u., Ntot = 6, p = 1, h = 1.0, r0 = 1.0\n  f′= [0.0, 2.0, 4.0, 6.0, 7.999999999999998, 9.999999999999993]\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.grid_trapezoidal_integral-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{T}}} where T<:Real","page":"Home","title":"CamiXon.grid_trapezoidal_integral","text":"grid_trapezoidal_integral(f::Vector{T}, n1::Int, n2::Int, grid::Grid{T}) where T<:Real\n\nIntegral of the function f=f_0 f_n tabulated on a Grid using the trapezoidal rule optimized with endpoint correction by the weightsvector grid.epw,\n\n    _0^r_n f(r) dr = _0^n f(x) r^prime(x) dx\n\nwhere the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see trapezoidal_integration). The rule is exact for polynonials of degree d=0 1 k-1, where k= grid.epn. For k=1 the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).\n\nExample:\n\nf1s(r) = 2.0*r*exp(-r);  # hydrogen 1s wavefunction (reduced and unit normalized)\nN = 1000;\ngrid = castGrid(1, N, Float64; h=0.01, r0=0.005)\n    create exponential Grid: Float64, Rmax = 110.127 (a.u.), Ntot = 1000, h = 0.01, r0 = 0.005\n\nr = grid.r;\nf2 = [f1s(r[n])^2 for n=1:N];\ngrid_trapezoidal_integral(f2, 1:N, grid) == grid_trapezoidal_integral(f2, 1, N, grid)\n    true\n\nnorm = grid_trapezoidal_integral(f2, 1:N, grid)\n\n    1.0\n\n\n\n\n\n","category":"method"},{"location":"#Adams-Moulton-integration","page":"Home","title":"Adams-Moulton integration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Adams-Moulton method is used for numerical integration of the reduces radial wave equation. In the present implementation it is constructed on top the objects Atom, Orbit, Grid, Def and Adams using 5 globally defined instances called atom, orbit, grid, def and adams.","category":"page"},{"location":"#Def","page":"Home","title":"Def","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Def object serves to define the problem to be solved and to contain in the field def.Z the solution as a discrete function of N elements.","category":"page"},{"location":"#Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index","page":"Home","title":"Illustration: central field potential U_mathrmCF versus grid index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"codata = castCodata(2018)\natom = castAtom(Z=1, A=1, Q=0)\norbit = castOrbit(n=7, ℓ=2)\ngrid = autoGrid(atom, orbit, Float64)\ndef = castDef(grid, atom, orbit, codata)\nE = convert(grid.T,bohrformula(atom.Z, orbit.n))\nadams = castAdams(E, grid, def)\n@printf \"E = %.15g %s \\n\" E \"Hartree\"\n    Element created: H, hydrogen, Z=1, weight=1.008\n    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)\n    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1\n    Orbital: 7d\n        principal quantum number: n = 7\n        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 2\n    Grid created: exponential, Float64, Rmax = 207.0 a.u., Ntot = 400, h = 0.025, r0 = 0.00939821\n    Def created for hydrogen 7d on exponential grid of 400 points\n    E = -0.0102040816326531 Hartree\n\nplot_potentials(E, grid, def)\n    Nlctp = 234, Nmin = 259, Nuctp = 369 (Ructp = 93.0059202490 a.u.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The plot is made using CairomMakie. NB.: plot_potentials is not included in the CamiXon package. (Image: Image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Def{T}\ncastDef(grid::Grid{T}, atom::Atom, orbit::Orbit, codata::Codata; scr=nothing, msg=true) where T <: Real","category":"page"},{"location":"#CamiXon.Def","page":"Home","title":"CamiXon.Def","text":"Def(T, atom, orbit, pot, scr, o1, o2, o3, pos, epn, k, am, matLD)\n\nType with fields:\n\n.T: gridType (::Type)\n.atom: atom object (::Atom)\n.orbit: orbit object (::Orbit)\n.codata: codata object (::Codata)\n.pot: tabulated potential function (::Vector{T})\n.scr: tabulated screening function (::Vector{T})\n.o1: vector of zero-filled matrices (::Vector{Matrix{T}})\n.o2: vector of zero-filled matrices (::Vector{Matrix{T}})\n.o3: vector of unit-filled matrices (::Vector{Matrix{T}})\n.pos: object containing Na, Nlctp, Nmin, Nuctp, Nb, N and nodes (::Pos)\n.epn: number of endpoints trapezoidal correction - must be odd (::Int)\n.k: Adams-Moulton order (::Int)\n.am: Adams-Moulton weight coefficients (::Vector{T})\n.matLD: Lagrangian differentiation matrix (::Matrix{T})\n\nThe object Def is best created with the function castDef.\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T<:Real","page":"Home","title":"CamiXon.castDef","text":"castDef(grid::Grid{T}, atom::Atom, orbit::Orbit, codata::Codata[; scr=nothing[, msg=true]]) where T <: Real\n\nCreate the Def object starting from the Grid object and the atomic properties of the objects Atom and Orbit. Optional: scr (supply screening array)\n\nExample:\n\ncodata = castCodata(2018)\natom = castAtom(Z=1, A=1, Q=0)\norbit = castOrbit(n=7, ℓ=2)\ngrid = autoGrid(atom, orbit, Float64)\ndef = castDef(grid, atom, orbit, codata);\n    Element created: H, hydrogen, Z=1, weight=1.008\n    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)\n    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1\n    Orbital: 7d\n        principal quantum number: n = 7\n        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 2\n    Grid created: exponential, Float64, Rmax = 207.0 a.u., Ntot = 400, h = 0.025, r0 = 0.00939821\n    Def created for hydrogen 7d on exponential grid of 400 points\n\n\n\n\n\n","category":"method"},{"location":"#Pos-and-Pos-related-functions","page":"Home","title":"Pos and Pos-related functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Pos object serves within Def object to contain the position indices def.Na, def.Nb, def.Nlctp, def.Nmin, def.Nuctp used in Adams-Moulton integration. These positions are contained in the fields def.pos.Na, def.pos.Nb, def.pos.Nlctp, def.pos.Nmin, def.pos.Nuctp. Alternatively, they can be determined with the functions get_Na, get_Nb, get_Nlctp, get_Nmin, get_Nuctp.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pos\nget_Na(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\nget_Nb(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\nget_Nlctp(E::T, def::Def{T}) where T<:Real\nget_Nmin(def::Def{T}) where T<:Real\nget_Nuctp(E::T, def::Def{T}) where T<:Real\ncount_nodes(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real","category":"page"},{"location":"#CamiXon.Pos","page":"Home","title":"CamiXon.Pos","text":"Pos(Na::Int, Nlctp::Int, Nmin::Int, Nuctp::Int, Nb::Int, N::Int, nodes::Int)\n\nType with fields:\n\n.Na: grid index of last leading point (::Int)\n.Nlctp: grid index of lower classical turning point (::Int)\n.Nmin: grid index of (screened) potential minimum (::Int)\n.Nuctp: grid index of upper classical turning point (::Int)\n.Nb: grid index first trailing point (::Int)\n.N: grid index last point (::Int)\n.nodes: number of nodes  (::Int)\n\nMutable struct to hold special grid indices as well as the number of nodes; Pos is one of the fields of the Def object\n\nExamples:\n\npos = Pos(1, 2, 3, 4, 5, 6, 7, false)\npos.Nuctp\n 4\n\npos.Nuctp = 8\npos\n Pos(1, 2, 3, 8, 5, 6, 7, false)\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.get_Na","text":"get_Na(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\n\nGrid index of the starting point for outward numerical integration. This is k+1 or the first point where the integration threshold value (1.0e-10) is exceeded.\n\nExample:\n\nEcal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)\nE, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=false);\n    Orbital: 1s\n        principal quantum number: n = 1\n        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 0\n    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033\n    Def created for hydrogen 1s on exponential grid\n\nNa = get_Na(Z, def)\nprintln(\"k + 1 = $(grid.k+1); Na = $Na\")\n    k + 1 = 8; Na = 8\n\nNa == def.pos.Na\n    true\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.get_Nb","text":"get_Nb(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\n\nGrid index of the stopping for outward numerical integration. This is N-k-1 or the last point where the integration threshold value (1.0e-10) is exceeded.\n\nExample:\n\nEcal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)\nE, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=false);\n    Orbital: 1s\n        principal quantum number: n = 1\n        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)\n        orbital angular momentum of valence electron: ℓ = 0\n    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033\n    Def created for hydrogen 1s on exponential grid\n\nNb = get_Nb(Z, def)\nprintln(\"N - k - 1 = $(grid.N-grid.k-1); Nb = $Nb\")\n    N - k - 1 = 92; Nb = 92\n\nNb == def.pos.Nb\n    true\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.get_Nlctp","text":"get_Nlctp(E::T, def::Def{T}) where T<:Real\n\nGrid index of the *lower classical turning point * of the screened potential curve. By definition get_Nlctp(E, def) = 2 for zero orbital angular momentum (ℓ=0).\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T<:Real","page":"Home","title":"CamiXon.get_Nmin","text":"get_Nmin(def::Def{T}) where T<:Real\n\nGrid index of the minimum of the screened potential curve. By definition get_Nmin(def) = 1 for zero orbital angular momentum (ℓ=0).\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.get_Nuctp","text":"get_Nuctp(E::T, def::Def{T}) where T<:Real\n\nGrid index of the upper classical turning point of the screened potential curve. By definition get_Nuctp(E, def) = N-1 for zero orbital angular momentum (ℓ=0).\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.count_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.count_nodes","text":"count_nodes(Z::Vector{Complex{T}}, def::Def{T}) where T<:Real\n\nNumber of nodes (excluding the origin) of the reduced radial wavefunction χ(r) = real(Z).\n\nExample:\n\natom = castAtom(Z=1, A=1, Q=0, msg=false);\norbit = castOrbit(n=3, ℓ=2, msg=false);\ngrid = autoGrid(atom, orbit, Float64; Nboost=1, epn=5, k=7, msg=false);\ndef = castDef(grid.T, atom, orbit, codata);\n    Def created for hydrogen 3d on exponential grid of 200 points\n\nE = convert(setT, bohrformula(atom.Z, orbit.n));\nadams = castAdams(E, grid, def);\nE, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=false);\n\no = count_nodes(Z, def); println(\"node count: $o nodes\")\n    node count: 0 nodes\n\n\n\n\n\n","category":"method"},{"location":"#Adams","page":"Home","title":"Adams","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Adams object serves to hold the Adams-Moulton integration matrices matG, matσ, matMinv as well as the actual normalized solution Z in the form of a tabulated function of N elements.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Adams\ncastAdams(E::T, grid::Grid{T}, def::Def{T}) where T<:Real\nupdateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T<:Real\ninitE(def::Def{T}; E=nothing) where T<:Real","category":"page"},{"location":"#CamiXon.Adams","page":"Home","title":"CamiXon.Adams","text":"Adams\n\nG: (:Vector{Matrix{T}})\nσ: (:Vector{Matrix{T}})\nMinv: (:Vector{Matrix{T}})\nZ: (:Vector{Complex{T}})\n\n\n\n\n\n","category":"type"},{"location":"#CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.castAdams","text":"castAdams(E::T, grid::Grid{T}, def::Def{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T<:Real","page":"Home","title":"CamiXon.updateAdams!","text":"updateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T<:Real\n\n\n\n\n\n","category":"method"},{"location":"#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T<:Real","page":"Home","title":"CamiXon.initE","text":"initE(def::Def{T}) where T<:Real\n\nAutogenerated seed value for the energy\n\nExample:\n\ncodata = castCodata(2018)\natom = castAtom(Z=1, A=1, Q=0; msg=false)\norbit = castOrbit(n=1, ℓ=0; msg=false)\ngrid = autoGrid(atom, orbit, Float64; msg=false)\ndef = castDef(grid, atom, orbit, codata);\n    Def created for hydrogen 1s on exponential grid of 100 points\n\nE = initE(def); println(\"E = $E\")\n    E = -0.03508495857961283\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"\n#### Adams related functions\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs matG(E::T, grid::Grid{T}, def::Def{T}) where T<:Real matσ(E::T, grid::Grid{T}, def::Def{T}) where T<:Real matMinv(E::T, grid::Grid{T}, def::Def{T}, amEnd::T) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n#### Adams-Moulton numerical solution of the radial wave equation","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs adamsmoultonsolve(E::T, grid::Grid{T}, def::Def{T}, adams::Adams) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n#### Radial integration - outward","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs OUTSCH(E::T, grid::Grid{T}, def::Def{T}, σ::Vector{Matrix{T}}) where T<:Real adamsmoultonoutward(def::Def{T}, adams::Adams{T}) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n#### Radial integration - inward","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs INSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real adamsmoultoninward(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n#### Radial integration - boundary condition applied and convergence test","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs adamsmoultonnormalized(Z::Vector{Complex{T}}, ΔQ::T, grid::Grid{T}, def::Def{T}) where T<:Real adamsmoultonpatch(Z::Vector{Complex{T}}, def::Def{T}, adams::Adams{T}) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n#### Adams-Moulton Master procedures","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs adamsmoultonprepare(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real adamsmoultoniterate(init::NTuple{4,T}, grid::Grid{T}, def::Def{T}, adams::Adams{T}; imax=25, Δν=Value(1,\"kHz\")) where T<:Real adamsmoultonmaster(E, grid, def, adams; Δν=Value(1,\"kHz\"), imax=25, msg=true) demo_hydrogen(; n=3, ℓ=2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n#### Wavefunction conversion","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs wavefunction(Z::Vector{Complex{T}}, grid::Grid{T}) where T<:Real","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Coulomb integrals\n\n### Angular integrals\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs acoeff(k::Int, l::Int, ml::Int, l′::Int, ml′::Int) bcoeff(k::Int, l::Int, ml::Int, l′::Int, ml′::Int)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## FITS\n\nFITS stands for 'Flexible Image Transport System'. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.\n\nWithin CamiXon only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.\n\nA FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.\n\nBy the command `f = fits_read(filnam)` we asign a collection of `FITS_HDU` objects from the file `filnam` to the variable `f`.\n\n### FITS - Types\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs FITSHDU{T,V} FITSheader FITSdata FITStable FITS_name","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### FITS - HDU Methods\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fitsinfo(hdu::FITSHDU) parseFITSTABLE(hdu::FITS_HDU)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### FITS - File Methods\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs castFITSname(filename::String) fitscombine(filnamFirst::String, filnamLast::String; protect=true) fitscopy(filenameA::String, filenameB::String=\" \"; protect=true) fitscreate(filename::String, data=[]; protect=true) fitsextend(filename::String, dataextend, hdutype=\"IMAGE\") fitsread(filename::String)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### FITS - Key Methods\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fitsaddkey(filename::String, hduindex::Int, key::String, val::Real, com::String) fitsdeletekey(filename::String, hduindex::Int, key::String) fitseditkey(filename::String, hduindex::Int, key::String, val::Real, com::String) fitsrenamekey(filename::String, hduindex::Int, keyold::String, keynew::String)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## FORTRAN\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs FORTRANformat castFORTRANformat(str::String) castFORTRAN_datatype(str::String)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Plotting\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs step125(x::Real) select125(x) steps(x::Vector{T} where T<:Real) stepcenters(x::Vector{T} where T<:Real) stepedges(x::Vector{T} where T<:Real) edges(px, Δx=1.0, x0=0.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Search and conversion tools\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs findall(A::Union{String,AbstractArray{T,1}}, a::T...; count=false)  where T findfirst(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T find_last(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Math\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs bernoullinumbers(nmax::Int) canonicalpartitions(n::Int, m=0; header=true, reverse=true) factorialbig(n::Int) faulhaberpolynom(p::Int) faulhabersummation(n::Int, p::Int; T=Int) harmonicnumber(n::Int, p::Int) harmonicnumber(n::Int) integerpartitions(n::Int, m=0; transpose=false, count=false) log10characteristicpower(x) log10mantissa(x) permutationsuniquecount(p::Array{Array{Int64,1},1}, i::Int) pascaltriangle(nmax::Int) pascalnext(a::Vector{Int}) pochhammer(x::T, p::Int) where T<:Real laguerrecoords(n::T) where T<:Real generalizedlaguerrecoords(n::Int, α::T) where T<:Real trianglecoefficient(a::Real, b::Real, c::Real) istriangle(a::Real, b::Real, c::Real) texp(x::T, a::T, p::Int) where T <: Real VectorRational normalize_VectorRational(vec::Vector{Rational{Int}})","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Polynom\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs polynomial(coords::Vector{T}, x::T; deriv=0) where T<:Number polynomderivative(coords::Vector{<:Number}) polynomderivatives(coords::Vector{<:Number}; deriv=0) polynomderivativesall(coords::Vector{<:Number}) polynompower(coords::Vector{<:Number}, power::Int) polynompowers(coords::Vector{<:Number}, pmax::Int) polynomprimitive(coeffs::Vector{<:Number}) polynomproduct(a::Vector{T}, b::Vector{T}) where T<:Number polynomproductexpansion(a::Vector{T}, b::Vector{T}, p::Int) where T<:Number","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Finite-difference methods\n\n### Finite differences\n\nConsider the analytical function ``f`` tabulated in *forward order*  \n(growing index) at ``n`` positions on a *uniform grid*.\n\n**Forward difference notation**\n\nIn *forward difference* notation, the *finite difference* of two adjacent\nvalues on the grid is defined as\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math Δ f[n] = f[n+1]-f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``Δ`` is the forward difference operator. By a formal inversion  \nprocedure we find\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n-1]=(1+Δ)^{-1}f[n]=(1-Δ+Δ^2-Δ^3+⋯)f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``Δ^k`` is the  ``k^{th}``-*order forward difference* defined as\na *weighted sum* over the function values ``f[n:n+k]`` (involving\n``k+1`` points),\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math Δ^k f[n] = c{k}^kf[n] + c{k-1}^kf[n+1] + ⋯  + f[n+k] = \\sum{j=0}^{k} c{k-j}^k f[n+j].","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ``k+1`` coefficients\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math c_{k-j}^{k}=(-1)^{k-j}\\binom{k}{j}","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nare the *summation weights* (short: *weights*) which define the summation.\n\n**Backward difference notation**\n\nIn *backward difference* notation, the *finite difference* of two adjacent\nvalues on the grid is defined as\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math ∇ f[n] = f[n]-f[n-1],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``∇`` is the backward difference operator.  By a formal inversion  \nprocedure we find\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+1]=(1-∇)^{-1}f[n]=(1+∇+∇^2+∇^3+⋯)f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``∇^k`` is the  ``k^{th}``-*order backward difference* defined as\na *weighted sum* over the function values tabulated in backward order,\n``f[n:-1:n-k]`` (involving ``k+1`` points),\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math ∇^k f[n] = f[n] + c1^kf[n-1] + ⋯ + ck^kf[n-k] = \\sum{j=0}^{k} cj^kf[n-j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``k+1`` coefficients\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math c_{j}^{k}=(-1)^{j}\\binom{k}{j}","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nare the *summation weights* (short: *weights*) which define the summation.\nNote the special cases ``c_{0}^{k}≡1``, ``c_{k}^{k}≡(-1)^{k}`` and the symmetry\nrelation\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math c{k-j}^k=(-1)^k cj^k.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nCoefficients:  \n\n[`fdiff_weight(k,j)`](@ref) `` → c_j^k=(-1)^j\\binom{k}{j}``\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs isforward(notation) isregular(ordering) fdiff_weight(k::Int, j::Int)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Finite difference expansions\n\nFinite-difference calculus builds on the *finite-difference expansion*.\n\n**Forward difference notation**\n\nIn terms of forward differences the expansion takes the form\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{\\infty}α{p}Δ^{p}f[n] =\\sum{p=0}^{k}α{p}Δ^{p}f[n]+⋯.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nA finite-difference expansion truncated at order ``k`` is defined\nby ``k+1`` *finite-difference expansion coefficients*, represented by the\nvector ``α = [α_{0},⋯\\ α_{k}]``. It takes some bookkeeping to rewrite the\nexpansion as a *weighted sum* over the ``k+1``\n*function values in forward tabulated form* ``f[n:n+k]``.\nSubstituting the finite difference expression for ``Δ^k``, we obtain\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}α{p}Δ^{p}f[n] =\\sum{p=0}^{k}α{p}\\sum{j=0}^{p}c{p-j}^{p}f[n+j] =\\sum{j=0}^{k}\\sum{p=j}^{k}α{p}c{p-j}^{p}f[n+j] =\\sum{j=0}^{k}F{j}^{k}f[n+j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the weighted summation is defined by the *weights*","category":"page"},{"location":"","page":"Home","title":"Home","text":"math F{j}^{k}=\\sum{p=j}^{k}α{p}c{p-j}^{p} =\\sum{p=j}^{k}(-1)^{p+j}\\binom{p}{j}α{p},","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwith ``j=0,⋯\\ k``. In inner product form the expansion becomes","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}α{p}Δ^{p}f[n] =\\sum{j=0}^{k}F{j}^{k}f[n+j] =F^{k} \\cdot f[n:n+k],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``F^k  ≡ [F_0^k,⋯\\ F_k^k]``.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n:n+k] = \\left[\\begin{array}{c} f[n]\\\n\\vdots\\\nf[n+k] \\end{array}\\right].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nCoefficients:\n\n[`fdiff_expansion_weights(coeffs, fwd, reg)`](@ref)\n``→ F^k ≡ [F_0^k,⋯\\ F_k^k]``,\n\nwhere the `coeffs` ``  α ≡ [α_0,⋯\\ α_k]`` are user supplied to define the\nexpansion.\n\n**Backward difference notation**\n\nIn terms of backward differences the expansion takes the form\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{\\infty}β{p}∇^{p}f[n]=\\sum{p=0}^{k}β{p}∇^{p}f[n]+⋯.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nIn this case the ``k^{th}``- order *finite-difference expansion* is defined\nby the vector ``β = [β_{0},⋯\\ β_{k}]``. The expansion can written as\n*weighted sum* over the ``k+1`` *function values in backward tabulated form*\n``f[n:-1:n-k]``. Substituting the finite\ndifference expression for ``∇^k``, we obtain\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}β{p}∇^{p}f[n] =\\sum{p=0}^{k}β{p}\\sum{j=0}^{p}c{j}^{p}f[n-j] =\\sum{j=0}^{k}\\sum{p=j}^{k}β{p}c{j}^{p}f[n-j] =\\sum{j=0}^{k}B{j}^{k}f[n-j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the *weights* are given by\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math B{j}^{k}=\\sum{p=j}^{k}β{p}c{j}^{p} =\\sum{p=j}^{k}(-1)^{j}\\binom{p}{j}β{p},","category":"page"},{"location":"","page":"Home","title":"Home","text":"with ``j=0,⋯\\ k``. In inner product form the expansion becomes\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}β{p}∇^{p}f[n] =\\sum{j=0}^k Bj^k f[n-j] =\\bar{B}^k \\cdot f[n-k:n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the *weights vector* ``\\bar{B}^{k} ≡ [B_k^k,⋯\\ B_0^k]`` contains\nthe weights in backward order.\n\nIn general there is *no simple symmetry relation* between\n``B^k`` and ``F^k``.\n\nCoefficients:\n\n[`fdiff_expansion_weights(coeffs, bwd, rev)`](@ref)\n`` → \\bar{B}^{k} ≡ [B_k^k,⋯\\ B_0^k]``,\n\nwhere the `coeffs`  ``  β ≡ [β_0,⋯\\ β_k]`` are user supplied to\ndefine the expansion.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffexpansionweights(coeffs, notation=bwd, ordering=rev) fdiff_expansion(coeffs, f, notation=bwd)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Lagrange-polynomial interpolation/extrapolation\n\nThe Lagrange polynomial of degree k on a uniform grid is the polynomial running through k+1 subsequent points on the grid. We derive expressions for interpolation/extrapolation in both forward- and backward-difference notation. Beware that Lagrange interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree k.\n\n**Forward difference notation**\n\nStarting from the relation","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n]=(1+Δ)f[n+1],","category":"page"},{"location":"","page":"Home","title":"Home","text":"we obtain by formal operator inversion","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+1] = (1 + Δ)^{-1} f[n] \\equiv \\sum_{p=0}^{\\infty}(-1)^p Δ^p f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+2] = (1 + Δ)^{-2} f[n] \\equiv \\sum_{p=0}^{\\infty}(-1)^p pΔ^p f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\vdots","category":"page"},{"location":"","page":"Home","title":"Home","text":"where ``k`` is called the order of the expansion and ``n`` is the reference\nindex. For interpolation position ``n-σ`` (where σ may be *real* valued in\nindex units) these expansions can be generalized to the form of\n*lagrangian interpolation*,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n-σ] = (1 + Δ)^{-σ} f[n] \\equiv \\sum{p=0}^{\\infty} αp(σ) Δ^p f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"where\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math αp(σ) ≡ (-1)^p(σ)p/p!","category":"page"},{"location":"","page":"Home","title":"Home","text":"is the ``p^{th}``-order *finite-difference expansion coefficient*\nfor lagrangian lagrangian interpolation over the\ninterval ``-k ≤σ ≤0\\ \\ (n \\le n-σ \\le n+k)``,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math (σ)_{p}=\\begin{cases} 1 & p=0\\\nσ(σ+1)(σ+2)\\cdots(σ+p-1) & p>0 \\end{cases}","category":"page"},{"location":"","page":"Home","title":"Home","text":"being the Pochhammer symbol ([`pochhammer`](@ref)). For ``σ`` outside the\ninterpolation interval the method corresponds to *extrapolation* along the\nLagrange polynomial. Evaluating the finite-difference expansion up to\norder ``k`` we obtain\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n-σ] =\\sum{p=0}^{k}αp(σ)Δ^pf[n] =\\sum{j=0}^{k}Fj^k(σ)f[n+j] =F^k(σ) \\cdot f[n:n+k],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``k+1`` *weights*\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math Fj^k(σ)= \\sum{p=j}^{k} (-1)^k αp(σ) cj^p =\\sum{p=j}^{k} (-1)^j \\binom{p}{j}(σ)p/p!","category":"page"},{"location":"","page":"Home","title":"Home","text":"are the *lagrangian interpolation weights* corresponding to the point\n``f[n-σ]``.\n\nSymmetry relation:\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\bar{F}^k(-k-σ) = F^k(σ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nWeight functions:\n\n[`fdiff_expansion_weights(coeffs, fwd, reg)`](@ref)\n`` → F^k(σ) ≡ [F^k_0(σ),⋯\\ F^k_k]``,\n\nwhere the vector\n\n`coeffs = `[`fdiff_interpolation_expansion_coeffs(σ, k, fwd)`](@ref)\n`` → α(σ) ≡ [α_0(σ),⋯\\ α_k(σ)]``  contains the coefficients of the\nlagrangian-interpolation expansion.\n\n**Backward difference notation**\n\nStarting from the relation","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n]=(1-∇)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"we obtain by formal operator inversion","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+1] = (1 - ∇)^{-1} f[n] \\equiv \\sum_{p=0}^{\\infty}∇^p f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+2] = (1 - ∇)^{-2} f[n] \\equiv \\sum_{p=0}^{\\infty}p∇^p f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\vdots","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``k`` is called the order of the expansion and ``n`` is the reference\nindex. For interpolation position ``n-σ`` (where σ may be *real* valued in\nindex units) these expansions can be generalized to the form of\n*lagrangian interpolation*,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+σ] = (1 - ∇)^{-σ} f[n] \\equiv \\sum{p=0}^{\\infty} βp(σ) ∇^p f[n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"where\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math βp(σ) ≡ (σ)p/p! = (-1)^p α_p(σ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nis the ``p^{th}``-order *finite-difference expansion coefficient* for\nlagrangian interpolation over the interval ``-k ≤σ ≤0\\ \\ (n-k \\le n+σ \\le n)``,\nwith\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math (σ)_{p}=\\begin{cases} 1 & p=0\\\nσ(σ+1)(σ+2)\\cdots(σ+p-1) & p>0 \\end{cases}","category":"page"},{"location":"","page":"Home","title":"Home","text":"being the Pochhammer symbol ([`pochhammer`](@ref)). For ``σ`` outside the\ninterpolation interval the method corresponds to *extrapolation* along the\nLagrange polynomial. Evaluating the finite-difference expansion up to\norder ``k`` we obtain\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+σ] =\\sum{p=0}^{k}βp(σ)∇^pf[n] = \\sum{j=0}^{k}B^kj(σ)f[n-j] = \\bar{B}^k(σ) ⋅ f[n-k:n],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``k+1`` *weights*\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math B^kj(σ)= \\sum{p=j}^{k} βp(σ) cj^p","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nare the corresponding *lagrangian interpolation weights*.  \n\nSymmetry relations:\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math B^k(σ) = F^k(σ) = \\bar{B}^k(-k-σ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\bar{B}^k(σ) = B^k(-k-σ)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nWeight function:\n\n[`fdiff_expansion_weights(coeffs, bwd, rev)`](@ref)\n`` → \\bar{B}^k(σ) ≡ [B_k^k(σ),⋯\\ B_0^k(σ)]``,\n\nwhere the vector\n\n`coeffs = `[`fdiff_interpolation_expansion_coeffs(σ, k=3, notation=bwd)`](@ref)\n`` → β(σ) ≡ [β_0(σ),⋯\\ β_k(σ)]`` contains the coefficients of the\nlagrangian-interpolation expansion.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffinterpolationexpansioncoeffs(ξ::T, k=3, notation=bwd) where T<:Real fdiffinterpolation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Lagrangian differentiation\n\nTo derive the *lagrangian differentiation* formulas we formally differentiate\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math f[n+x] = (1 - ∇)^{-x} f[n]","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwith respect to ``x``.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{df}{dx}[n+x] =-ln(1-∇)\\ (1-∇)^{-x}f[n] =\\sum{q=1}^{k}\\tfrac{1}{q}∇^{q}\\sum{p=0}^{k}l_{p}(x)∇^{p}f[n]+⋯.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nRewriting the r.h.s. as a single summation in powers of ``∇`` for given values\nof ``n`` and ``x`` we obtain an expression of the form\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{df}{dx}[n+x]=\\sum{p=1}^{k}βp(x)∇^{p}f[n]+⋯,","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``β_p(x)`` represents the *finite-difference expansion coefficients*\nfor *lagrangian differentiation* at position ``n+x``. These\ncoefficients are determined numerically by polynomial multiplication. As the\nexpansion algorith requires the presentce of a ``β_0(x)`` coefficient we add\na (vanishing) ``p=0`` term, ``β_0(x)\\equiv 0``. The corresponding coefficient\nvector is given by [`fdiff_differentiation_expansion_coeffs(k,x)`](@ref).\nEvaluating the finite-difference expansion up to order ``k`` we obtain\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{df}{dx}[n+x] =\\sum{p=0}^{k}βp(x)∇^pf[n] =\\sum{j=0}^{k}Bj^k(x)f[n-j] =B^k(x) ⋅ f[n:-1:n-k],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``k+1`` *weights*\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math  Bj^k(x)=\\sum{p=j}^{k}βp(x)c{j}^{p}","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nare the ``k^{th}``-order lagrangian differentiation weights. After changing\ndummy index to reverse the summation the expansion becomes\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{df}{dx}[n+x] =\\sum{j=0}^{k}\\bar{B}^kj(x)f[n-k+j] =\\bar{B}^k(x) ⋅ f[n-k:n].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nFunctions:\n\n[`fdiff_expansion_weights(β, bwd, reg)`](@ref)\n`` → B^k(x) ≡ [B^k_0(x),⋯\\ B^k_k(x)]``\n\n[`fdiff_expansion_weights(β, bwd, rev)`](@ref)\n`` → \\bar{B}^k(x) ≡ [B^k_k(x),⋯\\ B^k_0(x)]``\n\nwhere\n\n[`fdiff_differentiation_expansion_coeffs(o, k)`](@ref)\n``→ β ≡ [β_0(x),⋯\\ β_k(x)]``.\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffdifferentiationexpansioncoeffs(ξ::T, k=3) where T<:Real fdiffdifferentiation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real} createlagrangedifferentiation_matrix(k::Int)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Integration\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs trapezoidalweights(k::Int; rationalize=false, devisor=false) trapezoidalintegration(f, x1, x2, weights)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Adams Method\n\n#### Adams-Bashford expansion\n\nThe *Adams-Bashford integration step* is given by the expansion\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math y[n+1]-y[n] = -\\frac{h ∇}{(1-∇)ln(1-∇)}f[n+1]=h (\\sum{p=0}^{\\infty}Bp∇^p)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nA closed expression for the *Adams-Bashford expansion coefficients*, ``B_k``,\nis not available. As we already have a finite-difference expansion for the\noperator ``(1-∇)^{-1}``,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\frac{1}{1-∇}\\equiv\\sum_{p=0}^{\\infty}∇^p,","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwe ask for the expansion of\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math -\\frac{∇}{ln(1-∇)} =(1-\\frac{1}{2}∇-\\frac{1}{24}∇^2-\\frac{1}{12}∇^3+⋯)f[n+1] = (\\sum{p=0}^{\\infty}bp∇^p)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nThis is known as the *Adams-Moulton expansion*. Its coefficients are\ncalculated numerically by the function\n`fdiff_expansion_adams_moulton_coeffs(k)`. The *Adams-Bashford expansion* is\nobtained as the polynomial product of the two expansions,\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math (\\sum{p=0}^{\\infty}Bp∇^p)f[n+1] =(\\sum{p=0}^{\\infty}∇^p)(\\sum{p=0}^{\\infty}b_p∇^p)f[n+1] =\\ ( 1 + \\frac{1}{2}∇ + \\frac{5}{12}∇^2 + ⋯)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nThe coefficients ``B_p`` are calculated numerically with the function\n`fdiff_expansion_adams_bashford_coeffs(k)`. Evaluating the finite-difference\nexpansion up to order ``k`` we obtain (after changing dummy index bring the\nsummation in forward order)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}Bp∇^pf[n] =\\sum{p=0}^{k}Bp\\sum{j=0}^{p} cj^if[n-j] = \\sum{j=0}^{k}Aj^k(x)f[n-j] = \\sum{j=0}^{k}A{k-j}^k(x)f[n-k+j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``A_j^k(x)= \\sum_{p=j}^{k} B_pc_j^p`` are the ``(k+1)``-point\n*Adams-Bashford integration weights*.\n\nFunction:\n\n`β` = [`fdiff_adams_bashford_expansion_coeffs(k)`](@ref)\n ``→ [B_k^k(x),⋯\\ B_0^k(x)]``\n\n`adams_bashford_integration_weights`\n= [`fdiff_expansion_weights(β, bwd, rev)`](@ref)\n ``→ [A_k^k(x),⋯\\ A_0^k(x)]``\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffadamsbashfordexpansioncoeffs(k::Int)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n### Adams-Moulton expansion\n\nThe *Adams-Moulton integration* step is given by the expansion\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math y[n+1]-y[n] = -\\frac{∇}{ln(1-∇)}f[n+1] = ( 1 - \\frac{1}{2}∇ - \\frac{1}{12}∇^2 - \\frac{1}{24}∇^3 +⋯)f[n+1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nFor the evaluation of the integration step we limit the summation to ``k+1``\nterms (order ``k``),\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math y[n+1]-y[n]= (\\sum{p=0}^{k}bp∇^p)f[n+1]+⋯.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``b_0,⋯\\ b_k`` are the *Adams-Moulton expansion coefficients*,\nrational numbers generated numerically by the function\n[`fdiff_adams_moulton_expansion_coeffs(k)`](@ref). Extracting the greatest\ncommon denominator, ``1/D``, the step becomes\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math y[n+1]-y[n]= \\frac{1}{D}(\\sum{p=0}^{k}bp^{\\prime}∇^p)f[n+1]+⋯,","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere ``b_0^{\\prime},⋯\\ b_k^{\\prime}`` are integers and\n``b_p=b_p^{\\prime}/D``. In practice the expansion is restricted to ``k<18``\n(as limited by integer overflow). Note that this limit is much higher than\nvalues used in calculations (typically up to ``k = 10``). Evaluating the\nfinite-difference expansion up to order ``k`` we obtain (after changing\ndummy index bring the summation in forward order)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"math \\sum{p=0}^{k}bp∇^pf[n] =\\sum{p=0}^{k}bp\\sum{j=0}^{p} cj^if[n-j] = \\sum{j=0}^{k}aj^k(x)f[n-j] = \\sum{j=0}^{k}a{k-j}^k(x)f[n-k+j],","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nwhere the ``a_j^k(x)= \\sum_{p=j}^{k} b_pc_j^p`` are the ``(k+1)``-point\n*Adams-Moulton integration weights*.\n\nFunctions:\n\n`β` = [`fdiff_adams_moulton_expansion_coeffs(k)`](@ref) ``→ [b_0,⋯\\ b_k]``\n\n`adams_moulton_weights`\n= [`fdiff_expansion_weights(β, bwd, rev)`](@ref)\n``→ [a_k^k,⋯\\ a_0^k]``.\n\n`adams_moulton_weights` = [`create_adams_moulton_weights(k)`](@ref)\n``→ [a_k^k,⋯\\ a_0^k]``\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs fdiffadamsmoultonexpansioncoeffs(k::Int) createadamsmoulton_weights(k::Int; rationalize=false, devisor=false, T=Int)","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Strings\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs sup(i::T) where T<:Real sub(i::T) where T<:Real frac(i::Rational{Int}) strRational(n::T) where T<:Union{Rational{}, Int, BigInt}","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Dicts\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@docs dictAtomicNumbers dictElements dictIsotopes","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n## Index\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"@index ```","category":"page"}]
}
