```@meta
CurrentModule = CamiXon
```

# CamiXon.jl

A package for image analysis of backscattered light

---
## Table of contents

```@contents
```

## Strings

```@docs
sup(i::T) where T<:Real
sub(i::T) where T<:Real
frac(i::Rational{Int})
```

## Codata

```@docs
Codata
Value
strValue(f::Value)
NamedValue
castNamedValue(val::Value; name=" ", comment=" ")
castCodata(year::Int)
listCodata(codata::Codata)
convertUnit(val, codata::Codata; unitIn="Hartree", unitOut="xHz")
myconvert(T::Type, val::V) where V <: Number
calibrationReport(E, Ecal, codata::Codata; unitIn="Hartree")
```

## Atomic properties

```@docs
Atom
castAtom(;Z=1, Q=0, M=1.0, I=1//2, gI=5.5, msg=true)
Orbit
castOrbit(;n=1, ℓ=0, msg=true)
SpinOrbit
createSpinOrbit(o::Orbit; up=true, msg=true)
Term
createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)
bohrformula(Z::Int, n::Int)
mendeleev(Z::Int)
```

## Finite-difference methods

### Finite differences

Consider the analytic function ``f`` tabulated in *forward order*  (growing index) at ``n`` positions on a *grid*. The *finite difference* of two adjacent values on a *uniform grid* is defined by the relation

```math
\nabla f[n] = f[n]-f[n-1].
```

This is called the finite difference in *backward difference* notation. In this notation the  ``k^{th}``-*order backward difference* (which involves ``k+1`` points) is defined by a *weighted sum* over the function values in backward order, ``f[n],\ \ldots,\ f[n-k]``,

```math
\nabla^k f[n] = f[n] + c_1^kf[n-1] + \cdots + c_k^kf[n-k] = \sum_{j=0}^{k} c_j^kf[n-j].
```

The ``k+1`` coefficients ``c_{j}^{k}=(-1)^{j}\binom{k}{j}`` are *weight factors* (short: *weights*) defining the summation. Note that ``c_{0}^{k}\equiv1`` and ``c_{k}^{k}=(-1)^{k}``. As the function ``f`` is tabulated in forward order it is good practice to change dummy index to also write the summation in forward order (coefficients in backward order),

```math
\nabla^k f[n] = \sum_{j=0}^{k} c^k[j]f[n-k+j],
```
where ``c^k[j] \equiv c_{k-j}^k``.    

Functions:  

[`f_diff_weight(k,j)`](@ref) `` \rightarrow c_j^k``

[`f_diff_weights(k)`](@ref) `` \rightarrow \ c^k ≡ [c_k^k,\ c_1^k,\ldots,\ c_0^k]``

[`f_diff_weights_array(kmax)`](@ref) `` \rightarrow \ [\ c^0,\ c^1,\ \ldots,\ c^{kmax} ]``

```@docs
f_diff_weight(k::Int, i::Int)
f_diff_weights(k::Int)
f_diff_weights_array(kmax::Int)
```

### Finite difference expansion

Finite-difference calculus builds on the *finite-difference expansion*, in practice truncated at *order* ``k``,

```math
\sum_{p=0}^{\infty}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]+\cdots.
```

By choosing the order sufficiently high the expansion can be approximated to any desired level of accuracy. A finite-difference expansion of order ``k`` is defined by ``k+1`` *finite-difference expansion coefficients*, above denoted by ``a_{0},\ \ldots,\ a_{k}``. Note that both the coefficients and the operators appear in forward order. It takes some bookkeeping to rewrite the expansion in the form of a *weighted sum* over the ``k+1`` *function values* ``f[n],\ldots,f[n-k]`` (note the *backward order*). Substituting the finite-difference expression for ``\nabla^k``, we obtain

```math
\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\sum_{j=0}^{p}c_{j}^{i}f[n-j]=\sum_{j=0}^{k}\sum_{p=j}^{k}a_{p}c_{j}^{p}f[n-j]=\sum_{j=0}^{k}b_{j}^{k}f[n-j],
```

where the weighted summation is defined by the *weights* ``b_{j}^{k}=\sum_{p=j}^{k}a_{p}c_{j}^{p}``, with ``j=0,\ \ldots,\ k``. By a change of dummy index we write the summation in *forward order*

```math
\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]=\sum_{j=0}^{k}b^k[j]f[n-k+j],
```
where ``b^k[j] \equiv b_{k-j}^k``.  
Note that the *weights vector* ``b^k`` contains the weights in backward order. It is generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), where `∇ =`[` f_diff_weights_array(kmax)`](@ref).

Functions:

`coeffs` = ``[a_0,\ \ldots,\ a_k]``

[`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow b^k \equiv [b_k^k,\ ,\ldots,\ b_0^k]``

```@docs
f_diff_expansion_weights(coeffs, ∇)
```
### Lagrangian interpolation

Using the definition of the finite difference we can express the relation between ``f[n]`` and ``f[n+1]`` in operator form,
```math
f[n]=(1-\nabla)f[n+1].
```
By formal inversion of the operator we have
```math
f[n+1] = (1 - \nabla)^{-1} f[n] \equiv \sum_{p=0}^{\infty}∇^p f[n],
```
```math
f[n+2] = (1 - \nabla)^{-2} f[n] \equiv \sum_{p=0}^{\infty}p∇^p f[n],
```
```math
\vdots
```

which can be generalized to the form of *lagrangian interpolation*,

```math
f[n+x] = (1 - \nabla)^{-x} f[n] \equiv \sum_{p=0}^{\infty}l_p(x)∇^p f[n],
```

where ``l_0\equiv 1`` and ``l_p(x) = x(x+1)(x+2)\cdots(x+p-1)/p!`` for ``p>0`` are the *finite-difference expansion coefficients* for *lagrangian interpolation*. These are generated by the function [`f_diff_expansion_coeffs_lagrange(k,x)`](@ref). Evaluating the finite-difference expansion up to order ``k`` we obtain

```math
f[n+x] =\sum_{p=0}^{k}l_p(x)\nabla^pf[n]= \sum_{j=0}^{k}r_j^k(x)f[n-j],
```

where the ``k+1`` *weights* ``r_j^k(x)= \sum_{p=j}^{k} l_p(x) c_j^p`` are the  *lagrangian interpolation weights*.  After changing dummy index to bring the summation in forward order the expansion becomes
```math
f[n+x] =\sum_{p=0}^{k}l_p(x)\nabla^pf[n]= \sum_{j=0}^{k}r_x^k[j]f[n-k+j],
```
where ``r^k_x[j] ≡ r_{k-j}^k(x)``. The weights vector ``r^k_x`` is generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ =` [`f_diff_weights_array(k)`](@ref).

Functions:

`coeffs` = [`f_diff_expansion_coeffs_lagrange(k,x)`](@ref) ``\rightarrow [l_0(x),\ \ldots,\ l_k(x)]``

`lagrangian interpolation weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow r^k_x ≡ [r_k^k(x),\ ,\ldots,\ r_0^k(x)]``

```@docs

f_diff_expansion_coeffs_lagrange(k::Int, x::T) where T<:Real
summation_range(n::Int, i::Int, k::Int, μ::Int)
f_diff_function_sequences(f, k::Int, μ=0)
lagrange_interpolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, i=0)
lagrange_extrapolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, e=2, μ=0)

```
### Lagrangian differentiation

To derive the *lagrangian differentiation* formulas we formally differentiate

```math
f[n+x] = (1 - \nabla)^{-x} f[n]
```

with respect to ``x``.

```math
\frac{df}{dx}[n+x]=-ln(1-\nabla)\ (1-\nabla)^{-x}f[n]=\sum_{q=1}^{k}\tfrac{1}{q}∇^{q}\sum_{p=0}^{k}l_{p}(x)∇^{p}f[n]+\cdots.
```

Rewriting the r.h.s. as a single summation in powers of ``\nabla`` for given values of ``n`` and ``x`` we obtain an expression of the form

```math
\frac{df}{dx}[n+x]=\sum_{p=1}^{k}l_{p}^{\prime}(x)\nabla^{p}f[n]+\cdots,
```

where ``l_{p}^{\prime}(x)`` represents the *finite-difference expansion coefficients* for *lagrangian differentiation* at position ``n+x``. These coefficients are determined numerically by polynomial multiplication after adding the ``p=0`` term, ``l_{0}^{\prime}(x)\equiv 0``, to the first sum. The corresponding coefficient vector is generated in *forward order* by the function [`f_diff_expansion_coeffs_differentiation(k,x)`](@ref). Evaluating the finite-difference expansion up to order ``k`` we obtain

```math
\frac{df}{dx}[n+x]=\sum_{p=0}^{k}l_{p}^{\prime}(x)\nabla^{p}f[n]=\sum_{j=0}^{k}s_{j}^{k}(x)f[n-j],
```

where the ``s_{j}^{k}(x)=\sum_{p=j}^{k}l_{p}^{\prime}(x)c_{j}^{p}`` are the ``k^{th}``-order lagrangian differentiation weights.  After changing dummy index to reverse the summation from backward to forward order the expansion becomes

```math
\frac{df}{dx}[n+x]]= \sum_{j=0}^{k}s^k_x[j]f[n-k+j],
```
where ``s^k_x[j] ≡ s^k_{k-j}(x)``. The weights vector ``s^k_x`` is generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ =` [`f_diff_weights_array(k)`](@ref).

Functions:

`coeffs` = [`f_diff_expansion_coeffs_differentiation(k,x)`](@ref) ``\rightarrow [l_0^{\prime}(x),\ \ldots,\ l_k^{\prime}(x)]``

`Lagrange differentiation weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``s^k_x[j] ≡ \rightarrow [s_k^k(x),\ ,\ldots,\ s_0^k(x)]``

`Lagrange differentiation weights` = [`create_lagrange_differentiation_weights(k,x) `](@ref) ``s^k_x[j] ≡ \rightarrow [s_k^k(x),\ ,\ldots,\ s_0^k(x)]``

```@docs
f_diff_expansion_coeffs_differentiation(k::Int, x::T) where T<:Real
create_lagrange_differentiation_weights(k::Int, x::T) where T<:Real
create_lagrange_differentiation_matrix(k::Int)
lagrange_differentiation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=3, i=0)
```

### Integration

```@docs
trapezoidal_weights(k::Int; rationalize=false, devisor=false)
trapezoidal_integration(f, domain, weights)
```

### Adams Method

#### Adams-Bashford expansion

The *Adams-Bashford integration step* is given by the expansion

```math
y[n+1]-y[n] = -\frac{h \nabla}{(1-\nabla)ln(1-\nabla)}f[n+1]=h (\sum_{p=0}^{\infty}B_p\nabla^p)f[n+1].
```

A closed expression for the *Adams-Bashford expansion coefficients*, ``B_k``, is not available. As we already have a finite-difference expansion for the operator ``(1-∇)^{-1}``,

```math
\frac{1}{1-∇}\equiv\sum_{p=0}^{\infty}\nabla^p,
```

we ask for the expansion of

```math
-\frac{∇}{ln(1-∇)}=(1-\frac{1}{2}∇-\frac{1}{24}∇^2-\frac{1}{12}∇^3+\cdots)f[n+1]= (\sum_{p=0}^{\infty}b_p\nabla^p)f[n+1].
```

This is known as the *Adams-Moulton expansion*. Its coefficients are calculated numerically by the function `f_diff_expansion_adams_moulton_coeffs(k)`. The *Adams-Bashford expansion* is obtained as the polynomial product of the two expansions,

```math
(\sum_{p=0}^{\infty}B_p∇^p)f[n+1]=(\sum_{p=0}^{\infty}∇^p)(\sum_{p=0}^{\infty}b_p∇^p)f[n+1]=\ ( 1 + \frac{1}{2}\nabla + \frac{5}{12}\nabla^2 + \cdots)f[n+1].
```

The coefficients ``B_p`` are calculated numerically with the function `f_diff_expansion_adams_bashford_coeffs(k)`. Evaluating the finite-difference expansion up to order ``k`` we obtain (after changing dummy index bring the summation in forward order)

```math
\sum_{p=0}^{k}B_p\nabla^pf[n]=\sum_{p=0}^{k}B_p\sum_{j=0}^{p} c_j^if[n-j]= \sum_{j=0}^{k}A_j^k(x)f[n-j]= \sum_{j=0}^{k}A_{k-j}^k(x)f[n-k+j],
```

where the ``A_j^k(x)= \sum_{p=j}^{k} B_pc_j^p`` are the ``(k+1)``-point *Adams-Bashford integration weights*.

Function:

`coeffs` = [`f_diff_expansion_coeffs_adams_bashford(k)`](@ref) ``\rightarrow [B_k^k(x),\ ,\ldots,\ B_0^k(x)]``

`adams_bashford_integration_weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow [A_k^k(x),\ ,\ldots,\ A_0^k(x)]``

```@docs
f_diff_expansion_coeffs_adams_bashford(k::Int)
```

### Adams-Moulton expansion

The *Adams-Moulton integration* step is given by the expansion

```math
y[n+1]-y[n] = -\frac{\nabla}{ln(1-\nabla)}f[n+1] = ( 1 - \frac{1}{2}\nabla - \frac{1}{12}\nabla^2 - \frac{1}{24}\nabla^3 +\cdots)f[n+1].
```

For the evaluation of the integration step we limit the summation to ``k+1`` terms (order ``k``),

```math
y[n+1]-y[n]= (\sum_{p=0}^{k}b_p\nabla^p)f[n+1]+\cdots.
```

where ``b_0,\ldots,b_k`` are the *Adams-Moulton expansion coefficients*, rational numbers generated numerically by the function [`f_diff_expansion_coeffs_adams_moulton(k)`](@ref). Extracting the greatest common denominator, ``1/D``, the step becomes

```math
y[n+1]-y[n]= \frac{1}{D}(\sum_{p=0}^{k}b_p^{\prime}\nabla^p)f[n+1]+\cdots,
```

where ``b_0^{\prime},\ldots,b_k^{\prime}`` are integers and ``b_p=b_p^{\prime}/D``. In practice the expansion is restricted to ``k<18`` (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to ``k = 10``). Evaluating the finite-difference expansion up to order ``k`` we obtain (after changing dummy index bring the summation in forward order)

```math
\sum_{p=0}^{k}b_p\nabla^pf[n]=\sum_{p=0}^{k}b_p\sum_{j=0}^{p} c_j^if[n-j]= \sum_{j=0}^{k}a_j^k(x)f[n-j]= \sum_{j=0}^{k}a_{k-j}^k(x)f[n-k+j],
```

where the ``a_j^k(x)= \sum_{p=j}^{k} b_pc_j^p`` are the ``(k+1)``-point *Adams-Moulton integration weights*. These are generated in *backward order* by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ = `[`f_diff_weights_array(k)`](@ref).

Functions:

`coeffs` = [`f_diff_expansion_coeffs_adams_moulton(k)`](@ref) ``\rightarrow [b_0,\ldots,b_k]``

`adams_moulton_weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref)``\rightarrow [a_k^k,\ ,\ldots,\ a_0^k]``

`adams_moulton_weights` = [`create_adams_moulton_weights(k)`](@ref)``\rightarrow [a_k^k,\ ,\ldots,\ a_0^k]``

```@docs
f_diff_expansion_coeffs_adams_moulton(k::Int)
create_adams_moulton_weights(k::Int; rationalize=false, devisor=false, T=Int)
```

## Adams-Moulton integration

### Def

The `Def` object serves to define the problem to be solved and to contain in
the field `def.Z` the solution as a discrete function of `N` elements.

```@docs
Pos
Def{T}
castDef(grid::Grid{T}, atom::Atom, orbit::Orbit) where T <: Real
initE(def::Def{T}; E=nothing) where T<:Real
```

```@docs
matG(E::T, grid::Grid{T}, def::Def{T}) where T<:Real
matσ(E::T, grid::Grid{T}, def::Def{T}) where T<:Real
matMinv(E::T, grid::Grid{T}, def::Def{T}, amEnd::T) where T<:Real
OUTSCH(grid::Grid{T}, def::Def{T}, σ::Vector{Matrix{T}}) where T<:Real
OUTSCH_WKB(E::T, grid::Grid{T}, def::Def{T}) where T<:Real
Adams
castAdams(E::T, grid::Grid{T}, def::Def{T}) where T<:Real
updateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T<:Real
INSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T<:Real
```

## Grid

The `Grid` object is the backbone for the numerical procedure on a non-uniform grid. Its principal fields are `grid.r` and `grid.r′`, which are discrete functions of `N` elements representing the grid function and its derivative.

```@docs
Grid{T}
gridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T <: Real
castGrid(ID::Int, N::Int, T::Type; h=1, r0=0.001,  p=5, coords=[0,1], epn=7, k=7, msg=true)
autoRmax(atom::Atom, orbit::Orbit)
autoNtot(orbit::Orbit)
autoPrecision(Rmax::T, orbit::Orbit) where T<:Real
autoSteps(ID::Int, Ntot::Int, Rmax::T; p=5, coords=[0,1]) where T<:Real
grid_lagrange_derivative(f::Vector{T}, grid::Grid{T}; k=5) where T<:Real
grid_trapezoidal_integral(f::Vector{T}, n1::Int, n2::Int, grid::Grid{T}) where T<:Real
```


## FITS

FITS stands for 'Flexible Image Transport System'. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.

Within CamiXion only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.

A FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.

By the command `f = fits_read(filnam)` we asign a collection of `FITS_HDU` objects from the file `filnam` to the variable `f`.

### FITS - Types

```@docs
FITS_HDU{T,V}
FITS_header
FITS_data
FITS_table
FITS_name
```

### FITS - HDU Methods

```@docs
fits_info(hdu::FITS_HDU)
parse_FITS_TABLE(hdu::FITS_HDU)
```

### FITS - File Methods

```@docs
cast_FITS_name(filename::String)
fits_combine(filnamFirst::String, filnamLast::String; protect=true)
fits_copy(filenameA::String, filenameB::String=" "; protect=true)
fits_create(filename::String, data=[]; protect=true)
fits_extend(filename::String, data_extend, hdutype="IMAGE")
fits_read(filename::String)
```

### FITS - Key Methods

```@docs
fits_add_key(filename::String, hduindex::Int, key::String, val::Real, com::String)
fits_delete_key(filename::String, hduindex::Int, key::String)
fits_edit_key(filename::String, hduindex::Int, key::String, val::Real, com::String)
fits_rename_key(filename::String, hduindex::Int, keyold::String, keynew::String)
```

## FORTRAN

```@docs
FORTRAN_format
cast_FORTRAN_format(str::String)
cast_FORTRAN_datatype(str::String)
```

## Plotting

```@docs
step125(x::Real)
select125(x)
steps(x::Vector{T} where T<:Real)
stepcenters(x::Vector{T} where T<:Real)
stepedges(x::Vector{T} where T<:Real)
edges(px, Δx=1.0, x0=0.0)
```

## Search and conversion tools

```@docs
find_all(A::Union{String,AbstractArray{T,1}}, a::T...; count=false)  where T
find_first(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T
find_last(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T
```

## Math

```@docs
bernoulli_numbers(nmax::Int)
canonical_partitions(n::Int, m=0; header=true, reverse=true)
faulhaber_polynom(p::Int)
faulhaber_summation(n::Int, p::Int; T=Int)
harmonic_number(n::Int, p::Int)
harmonic_number(n::Int)
integer_partitions(n::Int, m=0; transpose=false, count=false)
log10_characteristic_power(x)
log10_mantissa(x)
permutations_unique_count(p::Array{Array{Int64,1},1}, i::Int)
pascal_triangle(nmax::Int)
pascal_next(a::Vector{Int})
polynomial(coords::Vector{T}, x::T; deriv=0) where T<:Number
polynom_derivative(coords::Vector{<:Number})
polynom_derivatives(coords::Vector{<:Number}; deriv=0)
polynom_derivatives_all(coords::Vector{<:Number})
polynom_power(coords::Vector{<:Number}, power::Int)
polynom_powers(coords::Vector{<:Number}, pmax::Int)
polynom_primitive(coeffs::Vector{<:Number})
polynom_product(a::Vector{T}, b::Vector{T}) where T<:Number
polynom_product_expansion(a::Vector{T}, b::Vector{T}, p::Int) where T<:Number
texp(x::T, a::T, p::Int) where T <: Real
VectorRational
normalize_VectorRational(vec::Vector{Rational{Int}})
```

## Index

```@index
```
