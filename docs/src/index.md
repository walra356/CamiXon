```@meta
CurrentModule = CamiXon
```

# CamiXon.jl

A package for image analysis of backscattered light

---
## Table of contents

```@contents
```
## Finite-difference methods

### Finite differences

Consider an analytic function ``f`` tabulated in *standard ordering of growing index* at ``n`` positions on a *grid*. The *finite difference* of two adjacent values on a *uniform grid* is given by the relation

```math
\nabla f[n] = f[n]-f[n-1].
```

This is called the *backward difference* notation. In this notation the  ``k^{th}``-*order finite differences* (``k+1``-point finite differences) are defined given by a *weighted sum* over the function values ``f[n],\ \ldots,\ f[n-k]``,

```math
\nabla^k f[n] = f[n] + c_1^kf[n-1] + \cdots + c_k^kf[n-k] = \sum_{j=0}^{k} c_j^kf[n-j].
```

The k+1 coefficients ``c_{j}^{k}=(-1)^{j}\binom{k}{j}`` are *weight factors* (short: *weights*) defining the summation. Note that ``c_{0}^{k}\equiv1$ and $c_{k}^{k}=(-1)^{k}``.

As the function ``f`` is tabulated in standard ordering we change dummy index to write the summation in standard order

```math
\nabla^k f[n] = \sum_{j=0}^{k} c_{k-j}^kf[n-k+j].
```

Functions:  

[`f_diff_weight(k,i)`](@ref) `` \rightarrow c_i^k``

[`f_diff_weights(k)`](@ref) `` \rightarrow \ [c_k^k,\ c_1^k,\ldots,\ c_0^k]$``

[`f_diff_weights_array(kmax)`](@ref) `` \rightarrow \ [\ [c_0^0],\ [c_1^1,c_0^1],\ \ldots,\ [c_k^k,\ c_{k-1}^k,\ldots,\ c_0^k] ]``

```@docs
f_diff_weight(k::Int, i::Int)
f_diff_weights(k::Int)
f_diff_weights_array(kmax::Int)
```

### Finite difference expansion

The key procedure of finite-difference calculus is the finite-difference expansion, in practice truncated at *order* ``k``,

```math
\sum_{p=0}^{\infty}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]+\cdots.
```

By choosing the order sufficiently high the expansion can be approximated to any desired level of accuracy. A finite-difference expansion of order `k` is defined by `k+1` *finite-difference expansion coefficients*, above denoted by ``a_{0},\ \ldots,\ a_{k}``. It takes some bookkeeping to rewrite the expansion in the form of a *weighted sum* over the ``k+`` function values ``f[n],\ldots,f[n-k]``. Substituting the backward-difference expression, ``\nabla^k f[n] = \sum_{i=0}^{k} c_i^kf[n-i]``, we find

```math
\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\sum_{j=0}^{p}c_{j}^{i}f[n-j]=\sum_{j=0}^{k}\sum_{p=j}^{k}a_{p}c_{j}^{p}f[n-j]=\sum_{j=0}^{k}b_{j}^{k}f[n-j],
```

where the weighted summation is defined by the *weights* ``b_{j}^{k}=\sum_{p=j}^{k}a_{p}c_{j}^{p}$, with $j=0,\,\ldots,\,k``. These are generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ =`[` f_diff_weights_array(k)`](@ref). Note the difference between the *finite-difference expansion coefficients*,  ``a_{0},\ \ldots,\ a_{k}``, and the *finite-difference expansion weights*, ``b_{0}^{k},\ \ldots,\ b_{k}^{k}``. Whereas the *coefficients*, ``a_i``, are *independent of* ``k``, the *weights*, ``b_i^k``, are ``k``*-dependent*. Furthermore, note the difference between the *finite-difference weights*, ``c_{0}^{k},\ \ldots,\ c_{k}^{k}``, and the *finite-difference expansion weights*, ``b_{0}^{k},\ \ldots,\ b_{k}^{k}``.

Functions:

`coeffs` = ``[a_0,\ \ldots,\ a_k]``

[`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow [b_0^k,\ ,\ldots,\ b_k^k]``

```@docs
f_diff_expansion_weights(coeffs, ∇)
f_diff_expansion_coeffs_interpolation(k::Int, x::T) where T<:Real
interpolation_offset_positions(n::Int, k::Int, i::Int)
summation_range(n::Int, j::Int, k::Int, i::Int)
```

## FITS

FITS stands for 'Flexible Image Transport System'. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.

Within CamiXion only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.

A FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.

By the command `f = fits_read(filnam)` we asign a collection of `FITS_HDU` objects from the file `filnam` to the variable `f`.

### FITS - Types

```@docs
FITS_HDU
FITS_header
FITS_data
FITS_table
FITS_name
```

### FITS - HDU Methods

```@docs
fits_info(hdu::FITS_HDU)
parse_FITS_TABLE(hdu::FITS_HDU)
```

### FITS - File Methods

```@docs
cast_FITS_name(filename::String)
fits_combine(filnamFirst::String, filnamLast::String; protect=true)
fits_copy(filenameA::String, filenameB::String=" "; protect=true)
fits_create(filename::String, data=[]; protect=true)
fits_extend(filename::String, data_extend, hdutype="IMAGE")
fits_read(filename::String)
```

### FITS - Key Methods

```@docs
fits_add_key(filename::String, hduindex::Int, key::String, val::Real, com::String)
fits_delete_key(filename::String, hduindex::Int, key::String)
fits_edit_key(filename::String, hduindex::Int, key::String, val::Real, com::String)
fits_rename_key(filename::String, hduindex::Int, keyold::String, keynew::String)
```

## FORTRAN

```@docs
FORTRAN_format
cast_FORTRAN_format(str::String)
cast_FORTRAN_datatype(str::String)
```

## Plotting

```@docs
step125(x::Real)
select125(x)
steps(x::Vector{T} where T<:Real)
stepcenters(x::Vector{T} where T<:Real)
stepedges(x::Vector{T} where T<:Real)
edges(px, Δx=1.0, x0=0.0)
```

## Search algorithms

```@docs
find_all(A::Union{String,AbstractArray{T,1}}, a::T...; count=false)  where T
find_first(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T
find_last(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T
```

## Math

```@docs
canonical_partitions(n::Int, m=0; header=true, reverse=true)
integer_partitions(n::Int, m=0; transpose=false, count=false)
log10_characteristic_power(x)
log10_mantissa(x)
polynom_deriv_coeffs(c,deriv=0)
polynom(c::Vector{T}, x::T) where T<:Real
```

## Index

```@index
```
