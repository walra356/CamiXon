```@meta
CurrentModule = CamiXon
```

# CamiXon.jl

A package for image analysis of backscattered light

---
## Table of contents

```@contents
```
## Finite-difference methods

### Finite differences

Consider an analytic function ``f`` tabulated in *normal ordering of growing index* at ``n`` positions on a *grid*. The *finite difference* of two adjacent values on a *uniform grid* is given by the relation

```math
\nabla f[n] = f[n]-f[n-1].
```

This is called the *backward difference* notation. In this notation the  ``k^{th}``-*order backward difference* (``k+1``-point finite difference) is defined given by a *weighted sum* over the function values ``f[n],\ \ldots,\ f[n-k]``,

```math
\nabla^k f[n] = f[n] + c_1^kf[n-1] + \cdots + c_k^kf[n-k] = \sum_{j=0}^{k} c_j^kf[n-j].
```

The k+1 coefficients ``c_{j}^{k}=(-1)^{j}\binom{k}{j}`` are *weight factors* (short: *weights*) defining the summation. Note that ``c_{0}^{k}\equiv1$ and $c_{k}^{k}=(-1)^{k}``.

As the function ``f`` is tabulated in standard ordering we change dummy index to write the summation in normal order

```math
\nabla^k f[n] = \sum_{j=0}^{k} c_{k-j}^kf[n-k+j].
```

Functions:  

[`f_diff_weight(k,j)`](@ref) `` \rightarrow c_j^k``

[`f_diff_weights(k)`](@ref) `` \rightarrow \ [c_k^k,\ c_1^k,\ldots,\ c_0^k]$``

[`f_diff_weights_array(kmax)`](@ref) `` \rightarrow \ [\ [c_0^0],\ [c_1^1,c_0^1],\ \ldots,\ [c_k^k,\ c_{k-1}^k,\ldots,\ c_0^k] ]``

```@docs
f_diff_weight(k::Int, i::Int)
f_diff_weights(k::Int)
f_diff_weights_array(kmax::Int)
```

### Finite difference expansion

The key relation of finite-difference calculus is the finite-difference expansion, in practice truncated at *order* ``k``,

```math
\sum_{p=0}^{\infty}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]+\cdots.
```

By choosing the order sufficiently high the expansion can be approximated to any desired level of accuracy. A finite-difference expansion of order ``k`` is defined by ``k+1`` *finite-difference expansion coefficients*, above denoted by ``a_{0},\ \ldots,\ a_{k}``. It takes some bookkeeping to rewrite the expansion in the form of a *weighted sum* over the ``k+1`` function values ``f[n],\ldots,f[n-k]``. Substituting the backward-difference expression for ``\nabla^k``, we find in *reversed* function ordering

```math
\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\sum_{j=0}^{p}c_{j}^{i}f[n-j]=\sum_{j=0}^{k}\sum_{p=j}^{k}a_{p}c_{j}^{p}f[n-j]=\sum_{j=0}^{k}b_{j}^{k}f[n-j],
```

where the weighted summation is defined by the *weights* ``b_{j}^{k}=\sum_{p=j}^{k}a_{p}c_{j}^{p}$, with $j=0,\,\ldots,\,k``. For *normal* ordering the weights are generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), where `∇ =`[` f_diff_weights_array(kmax)`](@ref).

Functions:

`coeffs` = ``[a_0,\ \ldots,\ a_k]``

[`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow [b_k^k,\ ,\ldots,\ b_0^k]``

```@docs
f_diff_expansion_weights(coeffs, ∇)
```
### Lagrangian interpolation

The expansion coefficients are generated by the function TODO

```@docs
f_diff_expansion_coeffs_interpolation(k::Int, x::T) where T<:Real
f_diff_expansion_coeffs_array_interpolation(k::Int, m::Int)
f_diff_expansion_coeffs_differentiation(k::Int, x::T) where T<:Real
f_diff_expansion_coeffs_array_differentiation(k::Int, m::Int)
f_diff_expansion_weights_array(n::Int, k::Int, m::Int, l::Vector{Vector{T}}) where T<:Real
summation_ranges(n::Int, i::Int, k::Int, m::Int)
f_diff_function_sequences(f, k::Int, m::Int)
lagrangian_interpolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, i=0)
lagrangian_differentiation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=3, i=0)

```


## FITS

FITS stands for 'Flexible Image Transport System'. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.

Within CamiXion only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.

A FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.

By the command `f = fits_read(filnam)` we asign a collection of `FITS_HDU` objects from the file `filnam` to the variable `f`.

### FITS - Types

```@docs
FITS_HDU
FITS_header
FITS_data
FITS_table
FITS_name
```

### FITS - HDU Methods

```@docs
fits_info(hdu::FITS_HDU)
parse_FITS_TABLE(hdu::FITS_HDU)
```

### FITS - File Methods

```@docs
cast_FITS_name(filename::String)
fits_combine(filnamFirst::String, filnamLast::String; protect=true)
fits_copy(filenameA::String, filenameB::String=" "; protect=true)
fits_create(filename::String, data=[]; protect=true)
fits_extend(filename::String, data_extend, hdutype="IMAGE")
fits_read(filename::String)
```

### FITS - Key Methods

```@docs
fits_add_key(filename::String, hduindex::Int, key::String, val::Real, com::String)
fits_delete_key(filename::String, hduindex::Int, key::String)
fits_edit_key(filename::String, hduindex::Int, key::String, val::Real, com::String)
fits_rename_key(filename::String, hduindex::Int, keyold::String, keynew::String)
```

## FORTRAN

```@docs
FORTRAN_format
cast_FORTRAN_format(str::String)
cast_FORTRAN_datatype(str::String)
```

## Plotting

```@docs
step125(x::Real)
select125(x)
steps(x::Vector{T} where T<:Real)
stepcenters(x::Vector{T} where T<:Real)
stepedges(x::Vector{T} where T<:Real)
edges(px, Δx=1.0, x0=0.0)
```

## Search algorithms

```@docs
find_all(A::Union{String,AbstractArray{T,1}}, a::T...; count=false)  where T
find_first(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T
find_last(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T
```

## Math

```@docs
canonical_partitions(n::Int, m=0; header=true, reverse=true)
integer_partitions(n::Int, m=0; transpose=false, count=false)
log10_characteristic_power(x)
log10_mantissa(x)
polynom_deriv_coeffs(c,deriv=0)
polynom(c::Vector{T}, x::T) where T<:Real
polynom_multiplication_coeffs(a::Vector{<:Number}, b::Vector{<:Number})
```

## Index

```@index
```
