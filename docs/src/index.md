```@meta
CurrentModule = CamiXon
```

# CamiXon.jl

A package for image analysis of backscattered light

---
## Table of contents

```@contents
```
## Finite-difference methods

### Finite differences

Consider the analytic function ``f`` tabulated in *forward order*  (growing index) at ``n`` positions on a *grid*. The *finite difference* of two adjacent values on a *uniform grid* is given by the relation

```math
\nabla f[n] = f[n]-f[n-1].
```

This called the finite difference in *backward difference* notation. In this notation the  ``k^{th}``-*order backward difference*, which involves ``k+1`` points) is defined by a *weighted sum* over the function values in backward order, ``f[n],\ \ldots,\ f[n-k]``,

```math
\nabla^k f[n] = f[n] + c_1^kf[n-1] + \cdots + c_k^kf[n-k] = \sum_{j=0}^{k} c_j^kf[n-j].
```

The k+1 coefficients ``c_{j}^{k}=(-1)^{j}\binom{k}{j}`` are *weight factors* (short: *weights*) defining the summation. Note that ``c_{0}^{k}\equiv1$ and $c_{k}^{k}=(-1)^{k}``.

As the function ``f`` is tabulated in forward order we change dummy index to write also the summation in forward order (coefficients in backward order)

```math
\nabla^k f[n] = \sum_{j=0}^{k} c_{k-j}^kf[n-k+j].
```

Functions:  

[`f_diff_weight(k,j)`](@ref) `` \rightarrow c_j^k``

[`f_diff_weights(k)`](@ref) `` \rightarrow \ [c_k^k,\ c_1^k,\ldots,\ c_0^k]``

[`f_diff_weights_array(kmax)`](@ref) `` \rightarrow \ [\ [c_0^0],\ [c_1^1,c_0^1],\ \ldots,\ [c_k^k,\ c_{k-1}^k,\ldots,\ c_0^k] ]``

```@docs
f_diff_weight(k::Int, i::Int)
f_diff_weights(k::Int)
f_diff_weights_array(kmax::Int)
```

### Finite difference expansion

Finite-difference calculus builds on the *finite-difference expansion*, in practice truncated at *order* ``k``,

```math
\sum_{p=0}^{\infty}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]+\cdots.
```

By choosing the order sufficiently high the expansion can be approximated to any desired level of accuracy. A finite-difference expansion of order ``k`` is defined by ``k+1`` *finite-difference expansion coefficients*, above denoted by ``a_{0},\ \ldots,\ a_{k}``. Note that both the coefficients and the operators appear in forward order. It takes some bookkeeping to rewrite the expansion in the form of a *weighted sum* over the ``k+1`` function values in *backward order* ``f[n],\ldots,f[n-k]``. Substituting the backward-difference expression for ``\nabla^k``, we find

```math
\sum_{p=0}^{k}a_{p}\nabla^{p}f[n]=\sum_{p=0}^{k}a_{p}\sum_{j=0}^{p}c_{j}^{i}f[n-j]=\sum_{j=0}^{k}\sum_{p=j}^{k}a_{p}c_{j}^{p}f[n-j]=\sum_{j=0}^{k}b_{j}^{k}f[n-j],
```

where the weighted summation is defined by the *weights* ``b_{j}^{k}=\sum_{p=j}^{k}a_{p}c_{j}^{p}$, with $j=0,\ \ldots,\ k``. After changing dummy index to obtain *forward order*  (coefficients in backward order) by the weights are generated by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), where `∇ =`[` f_diff_weights_array(kmax)`](@ref).

Functions:

`coeffs` = ``[a_0,\ \ldots,\ a_k]``

[`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow [b_k^k,\ ,\ldots,\ b_0^k]``

```@docs
f_diff_expansion_weights(coeffs, ∇)
```
### Lagrangian interpolation

The definition of the finite difference can be rewritten in the form
```math
(1-\nabla)f[n+1] = f[n].
```
Inverting this expression we have
```math
f[n+1] = (1 - \nabla)^{-1} f[n] = \sum_{p=0}^{\infty}∇^p f[n],
```
```math
f[n+2] = (1 - \nabla)^{-2} f[n] = \sum_{p=0}^{\infty}p∇^p f[n],
```
```math
\vdots
```

which can be generalized into the form

```math
f[n+x] = (1 - \nabla)^{-x} f[n] = \sum_{p=0}^{\infty}l_p(x)∇^p f[n],
```

where ``l_0\equiv 1`` and ``l_p(x) = x(x+1)(x+2)\cdots(x+p-1)/p!`` for ``p>0`` are the *finite-difference expansion coefficients* for *lagrangian interpolation*. These are generated by the function [`f_diff_expansion_coeffs_interpolation(k,x)`](@ref). Evaluating the finite-difference expansion up to order ``k`` we obtain (after changing dummy index to reverse the summation from backward to forward order)

```math
f[n+x] =\sum_{p=0}^{k}l_p(x)\nabla^pf[n]= \sum_{j=0}^{k}r_j^k(x)f[n-j]= \sum_{j=0}^{k}r_{k-j}^k(x)f[n-k+j],
```

where the ``k+1`` *weights* ``r_j^k(x)= \sum_{p=j}^{k} l_p(x) c_j^p`` are the  *lagrangian interpolation weights*. These are generated for use in *backward order* by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ =` [`f_diff_weights_array(k)`](@ref).

Functions:

`coeffs` = [`f_diff_expansion_coeffs_interpolation(k,x)`](@ref) ``\rightarrow [l_0(x),\ \ldots,\ l_k(x)]``

`lagrangian interpolation weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow [r_k^k(x),\ ,\ldots,\ r_0^k(x)]``

```@docs

f_diff_expansion_coeffs_lagrange(k::Int, x::T) where T<:Real
#f_diff_expansion_coeffs_interpolation(k::Int, x::T) where T<:Real
#f_diff_expansion_coeffs_extrapolation(k::Int, x::T) where T<:Real
#f_diff_expansion_coeffs_array_interpolation(k::Int, m::Int)
#f_diff_expansion_weights_extrapolation(k::Int, x::T) where T<:Real
#f_diff_expansion_weights_array(n::Int, k::Int, m::Int, l::Vector{Vector{T}}) where T<:Real
summation_range(n::Int, i::Int, k::Int, μ::Int)
f_diff_function_sequences(f, k::Int, μ=0)
lagrange_interpolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, i=0)
lagrange_extrapolation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=1, e=2, μ=0)

```
### Lagrangian differentiation

To derive the *lagrangian differentiation* formulas we differentiate

```math
f[n+x] = (1 - \nabla)^{-x} f[n]
```

analytically with respect to ``x``.

```math
\frac{df}{dx}[n+x]=-ln(1-\nabla)\ (1-\nabla)^{-x}f[n]=\sum_{q=1}^{k}\tfrac{1}{q}∇^{q}\sum_{p=0}^{k}l_{p}(x)∇^{p}f[n].
```

Expanding the r.h.s. in powers of ``\nabla`` for given values of ``n`` and ``x`` we obtain an expression of the form

```math
\frac{df}{dx}[n+x]=\sum_{p=1}^{k}l_{p}^{\prime}(x)\nabla^{p}f[n],
```

where ``l_{p}^{\prime}(x)`` represents the *finite-difference expansion coefficients* for *lagrangian differentiation* at position ``n+x``. These coefficients are determined numerically by polynomial multiplication after adding the ``p=0`` term ``l_{0}^{\prime}(x)\equiv 0``. These are generated by the function [`f_diff_expansion_coeffs_differentiation(k,x)`](@ref). Evaluating the finite-difference expansion up to order ``k`` we obtain (after changing dummy index to reverse the summation from backward to forward order)

```math
f[n+x]=\sum_{p=0}^{k}l_{p}^{\prime}(x)\nabla^{p}f[n]=\sum_{j=0}^{k}s_{j}^{k}(x)f[n-j]= \sum_{j=0}^{k}s_{k-j}^k(x)f[n-k+j],
```

where the ``s_{j}^{k}(x)=\sum_{p=j}^{k}l_{p}^{\prime}(x)c_{j}^{p}`` are the ``k``-point lagrangian differentiation weights. These are generated for use in *backward order* by the function [`f_diff_expansion_weights(coeffs,∇)`](@ref), with `∇ =` [`f_diff_weights_array(k)`](@ref).

Functions:

`coeffs` = [`f_diff_expansion_coeffs_differentiation(k,x)`](@ref) ``\rightarrow [l_0(x),\ \ldots,\ l_k(x)]``

`lagrangian differentiation weights` = [`f_diff_expansion_weights(coeffs,∇)`](@ref) ``\rightarrow [s_k^k(x),\ ,\ldots,\ s_0^k(x)]``

```@docs
f_diff_expansion_coeffs_differentiation(k::Int, x::T) where T<:Real
# f_diff_expansion_coeffs_array_differentiation(k::Int, m::Int)
lagrange_differentiation(f::Vector{Float64}, domain::ClosedInterval{Float64}; k=3, i=0)
```
### Adams-Bashford expansion

### Adams-Moulton expansion

The *Adams-Moulton integration* step is given by the expansion

```math
y[n+1]-y[n] = -\frac{h \nabla}{ln(1-\nabla)}f[n+1] = h\ ( 1 - \frac{1}{2}\nabla - \frac{1}{12}\nabla^2 - \frac{1}{24}\nabla^3 +\cdots)f[n+1].
```

For the evaluation of the integration step we limit the summation to ``k+1`` terms (order ``k``),

```math
y[n+1]-y[n]= h\ (\sum_{p=0}^{k}b_p\nabla^p)f[n+1]+\cdots.
```

where ``b_0,\ldots,b_k`` are the *Adams-Moulton expansion coefficients*, rational numbers generated numerically by the function [`f_diff_expansion_coeffs_adams_moulton(k)`](@ref). Extracting the greatest common denominator, ``1/D``, the step becomes

```math
y[n+1]-y[n]= \frac{h}{D}(\sum_{p=0}^{k}b_p^{\prime}\nabla^p)f[n+1]+\cdots,
```

where ``b_0^{\prime},\ldots,b_k^{\prime}`` are integers and ``b_p=b_p^{\prime}/D``. In practice the expansion is restricted to ``k<18`` (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to ``k = 10``).

Function:

`coeffs` = [`f_diff_expansion_coeffs_adams_moulton(k)`](@ref) ``\rightarrow [b_k^k(x),\ ,\ldots,\ b_0^k(x)]``

```@docs
f_diff_expansion_coeffs_adams_moulton(k::Int)
```

## FITS

FITS stands for 'Flexible Image Transport System'. This is an open standard origionally developed for the astronomy community to store telescope images together with tables of spectral information. Over the years it has developed into a scientific standard - http://fits.gsfc.nasa.gov/iaufwg.

Within CamiXion only the basic FITS functionality is implemented for users not requiring celestal coordinates. The user can create, read and extend .fits files as well as create, edit and delete user-defined metainformation.

A FITS file consists of a sequence of one or more header-data-units (HDUs), each containing a data block preceeded by header records of metainformation.

By the command `f = fits_read(filnam)` we asign a collection of `FITS_HDU` objects from the file `filnam` to the variable `f`.

### FITS - Types

```@docs
FITS_HDU
FITS_header
FITS_data
FITS_table
FITS_name
```

### FITS - HDU Methods

```@docs
fits_info(hdu::FITS_HDU)
parse_FITS_TABLE(hdu::FITS_HDU)
```

### FITS - File Methods

```@docs
cast_FITS_name(filename::String)
fits_combine(filnamFirst::String, filnamLast::String; protect=true)
fits_copy(filenameA::String, filenameB::String=" "; protect=true)
fits_create(filename::String, data=[]; protect=true)
fits_extend(filename::String, data_extend, hdutype="IMAGE")
fits_read(filename::String)
```

### FITS - Key Methods

```@docs
fits_add_key(filename::String, hduindex::Int, key::String, val::Real, com::String)
fits_delete_key(filename::String, hduindex::Int, key::String)
fits_edit_key(filename::String, hduindex::Int, key::String, val::Real, com::String)
fits_rename_key(filename::String, hduindex::Int, keyold::String, keynew::String)
```

## FORTRAN

```@docs
FORTRAN_format
cast_FORTRAN_format(str::String)
cast_FORTRAN_datatype(str::String)
```

## Plotting

```@docs
step125(x::Real)
select125(x)
steps(x::Vector{T} where T<:Real)
stepcenters(x::Vector{T} where T<:Real)
stepedges(x::Vector{T} where T<:Real)
edges(px, Δx=1.0, x0=0.0)
```

## Search algorithms

```@docs
find_all(A::Union{String,AbstractArray{T,1}}, a::T...; count=false)  where T
find_first(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T
find_last(A::Union{String,AbstractArray{T,1}}, a::T...; dict=false)  where T
```

## Math

```@docs
canonical_partitions(n::Int, m=0; header=true, reverse=true)
integer_partitions(n::Int, m=0; transpose=false, count=false)
log10_characteristic_power(x)
log10_mantissa(x)
polynom_deriv_coeffs(c,deriv=0)
polynom(c::Vector{T}, x::T) where T<:Real
polynom_multiplication_coeffs(a::Vector{<:Number}, b::Vector{<:Number})
permutations_unique_count(p::Array{Array{Int64,1},1}, i::Int)
```

## Index

```@index
```
